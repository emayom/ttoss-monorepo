{"results":[{"id":23345,"updatedTime":"2023-11-08T10:46:06+09:00","createdTime":"2023-11-06T11:11:01+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"null 리턴은 왜 나쁠까?","subtitle":"코드 복잡성 관리 측면에서 의미를 축약한 표현의 문제와 해결 방법을 예제로 알아봐요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/ml-illust/programmer-handling-code-box-with-highlighting-lines_20231106_111448975.png","videoUrl":null,"backgroundColor":null,"isFill":true,"imageAlt":"개발자가 커다란 화면 옆에서 코드 살펴보고 있는 모습"},"thumbnailConfig":{"imageUrl":"https://static.toss.im/ml-illust/_20231108_104549157.png","backgroundColor":null,"isFill":true,"imageAlt":"개발자가 커다란 화면 옆에서 코드 살펴보고 있는 모습"},"key":"engineering-note-2","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-11-08T10:00:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":23345,"title":null,"description":"코드 복잡성 관리 측면에서 의미를 축약한 표현의 문제와 해결 방법을 예제로 알아봐요.","urlSlug":"engineering-note-2","primaryKeyword":{"id":13797,"content":"코드복잡성","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":13801,"content":"코드관리","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"null 리턴은 왜 나쁠까?","description":"코드 복잡성 관리 측면에서 의미를 축약한 표현의 문제와 해결 방법을 예제로 알아봐요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/ml-illust/_20231108_104549157.png","imageType":"썸네일 이미지"},"relatedPostConfig":null,"editor":{"id":1583,"name":"나재은","slug":"jaeeun-na","shortDescription":null,"description":"토스페이먼츠 나재은","imageUrl":"https://static.toss.im/3d-emojis/u1F9D0.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"엔지니어링 노트 2: 코드 복잡성 관리하기\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 두 번째로 코드 복잡성을 관리하는 방법을 소개합니다.\n\n\n개발자의 고객은 누구라고 생각하시나요? 우리 제품을 사용하는 사용자(End-user)죠. 그런데 또 다른 고객이 있어요. 컴파일 타임의 고객, 바로 동료 개발자입니다. 복잡하고 나쁜 코드는 사용자 고객에게는 버그와 장애를, 개발자 고객에게는 낮은 생산성을 줍니다. 이번 시리즈에서는 사용자 고객뿐 아니라 개발자 고객을 위한 코드 복잡성 관리에 대해 이야기해 볼게요.\n\n먼저 내 코드가 얼마나 복잡한지 체크리스트로 확인해 볼게요.\n\n내 코드는 얼마나 복잡할까?\n✅ 코드를 읽고 있을 때 누군가 말을 걸면 어디까지 읽었는지 놓쳐서 처음부터 다시 읽어야 한다.\n\n✅ 코드 한 줄을 바꾸기 위해 바꿔야 할 다른 코드가 많다.\n\n✅ 새로운 사람이 팀에 합류하면 그 사람이 몇 주 내내 프로젝트 코드를 읽을 시간을 확보해야 한다.\n\n✅ 메서드 인자에 값을 전달하기 위해 지나가는 모든 메서드 인자 값을 추가한 적이 있다. 혹은 이 문제를 해결하기 위해 전역 변수를 사용하고 싶은 유혹을 받은 적이 있다.\n\n✅ 프로젝트 코드가 너무 복잡해서 처음부터 다시 만들면 적어도 지금보단 나았을 거라는 생각을 해본 적이 있다.\n\n사실 모두 제 경험담인데요. 혹시 체크리스트를 읽으며 ‘개발자의 당연한 삶’이라는 생각이 들었다면, 만성적으로 높은 코드 복잡성을 경험하고 있는 거라고 해도 될 거예요. 이제부터 예시를 보면서 함께 복잡성 관리를 시작해 봐요.\n\nnull 리턴은 왜 나쁠까?\nnull이 왜 나쁜지에 대해서는 이미 많은 의견을 접해봤을 거예요. ‘백만 달러짜리 실수다’, ‘Optional 타입을 도입하면 해결되는 문제다’, ‘Null Object Pattern 사용으로 해결할 수 있다’ 등이죠. 지금 이 예제에서는 이런 생각들을 뒤로하고, 오로지 코드를 읽는 사람 입장에서 null이 왜 복잡성을 만드는 ‘나쁜 코드’인지 알아볼게요.\n\n문제: 의미를 축약한 코드 표현\n\n위 예제 코드에서 user 변수가 null이라면 그 이유는 무엇일까요? 아래와 같이 여러 생각을 할 수 있어요.\n\n데이터베이스에 “김토스”라는 이름을 가진 사람이 없는 것 아닐까?\n데이터베이스와의 네트워크 연결이 불안정했던 것 아닐까?\n“김토스”는 탈퇴한 회원인 것 아닐까?\n“김토스”는 운영 환경에서만 존재하는 사용자인 것 아닐까?\n사실은 이런 이유가 있었어요. (글의 이해를 돕기 위한 예시입니다.)\n\n매주 월요일마다 새로운 직원이 입사한다.\n매주 월요일마다 인사 관리 시스템에 새로운 직원의 입사 정보가 추가된다.\n인사 관리 시스템에 정보가 업데이트되는 정확한 시점은 알 수 없다.\n이 코드가 동작하는 서버의 데이터베이스는 매주 월요일에서 화요일로 넘어가는 00시에 인사 관리 시스템과 동기화된다.\n“김토스”는 예외적으로 월요일이 아닌 수요일에 입사했다.\n따라서 “김토스” 유저는 아직 이 코드가 동작하는 서버의 데이터베이스에 존재하지 않는다.\n모든 배경을 이해한 개발자가 null을 리턴하기로 결정했어요. 이 결정은 코드를 읽는 사람에게 위의 모든 문맥 정보를 null 값 하나로 추론하게 만드는 거예요.\n\n또, 읽는 사람이 같은 프로젝트 안에서 null을 리턴하는 비슷한 코드를 만날 수도 있겠죠.\n\n\npullRequest 변수는 왜 null일까요? user가 null인 이유와 같을까요? 비슷한 이유일 수도 있고, 자신만의 고유한 원인과 히스토리가 있을지도 모르죠. 자세히 알아보기 위해 userRepository.findByName('김토스') 의 세부 구현을 들여다보기 시작하는 순간 개발자의 생산성은 이미 떨어집니다.\n\n비슷한 문제들\nnull이 아니더라도 여러 원인을 하나의 표현으로 가려버리는 방식이라면 비슷한 문제를 만들게 될 거예요. 빈 문자열과 Int 타입, 리스트로 표현한 예시도 살펴볼게요.\n\n빈 문자열 “”을 사용한 코드를 읽었을 때\n사용자가 입력 시도를 하지 않았나?\n사용자가 무언가를 입력했지만 잘못된 입력이었나?\n사용자가 실제로 빈 문자열을 입력했나?\nperson.getAge() 함수가 Int 타입의 -1을 반환하는 코드를 읽었을 때\n함수 실행이 잘 됐고, person의 age 데이터는 실수로 누락되어서 알 수 없는 걸까?\n함수 실행이 잘 됐고, person의 age 데이터는 입력 선택 사항이라 알 수 없는 걸까?\n함수 실행에 실패했고, 원인은 알 수 없는 걸까?\nperson.getPhoneNumbers() 함수가 리스트를 반환하는 코드를 읽었을 때\n빈 리스트 []가 돌아왔다면 함수 실행이 잘 되었고, 이 사람은 핸드폰 번호가 없는 걸까?\nnull이 돌아왔다면 함수 실행이 잘 되었고, 이 사람은 핸드폰 번호가 없는 걸까?\n해결 1단계: 로그에 맥락 남기기\n이런 문제를 만들지 않으려면 코드에 담긴 다양한 의미를 축약하거나 없애지 않고 자세히 풀어 코드에 녹여내면 됩니다. 주석으로는 충분하지 않아요. 실제 코드가 아니기 때문입니다. 실제 동작하는 코드, 즉 로그에 직접 찍히는 내용만이 믿을 수 있는 정보라고 할 수 있어요.\n\nuser가 null인 이유를 IllegalStateException 예외 인스턴스에 상세하게 적었어요.\n\n\n이제 코드를 자세히 들여다보지 않아도, user가 null인 이유는 물론이고 그 배경까지 별다른 노력 없이 알게 되었어요. 코드 형태만 단순한 게 아니라, 원인 파악도 복잡하지 않고 간단하게 할 수 있어요.\n\n여기서 던진 예외는 @ExceptionHandler 어노테이션을 통해 처리할 수도 있고, 예외로 던지지 않고 로깅만 남길 수도 있겠네요. 핵심은, 맥락을 코드에 명시적으로 드러내기만 하면 어떤 방법이든 더 낫다는 거예요.\n\n해결 2단계: 맥락 처리를 위한 기능 만들기\n이번에는 개발자가 findByName() 함수 바깥에서 null인 경우를 알고 싶다면 어떨까요? 예를 들면 재시도 로직을 넣고 싶은 상황인 거죠. ‘인사관리 시스템과 동기화되지 않은 유저의 이름을 입력했을 때’를 User? 반환 타입으로 풍부하게 표현할 수 없으니 null을 리턴할 수 밖에 없을까요? 이 질문 역시 품질을 높이기 위한 고민이 기술적인 영역으로 넘어온 것이니 이미 절반의 성공을 했다고 볼 수 있는데요. 해결 방법을 하나씩 살펴봅시다.\n\n\n이렇게 코드를 작성하는 건 어떨까요? 여전히 null을 리턴했지만 주석으로 그 이유를 표현해주고 있죠. 그러나 여전히 중요한 문맥 정보를 주석과 null 으로 표현했고 리턴 타입이 User?이기 때문에 재시도를 수행한 뒤에도 null이 리턴되는 케이스를 설명하기 어려워요. null을 리턴하는 또 다른 상황을 표현할 수 없는 문제도 있고요.\n\n이 모든 이유와 복잡성을 findByName() 함수를 읽는 개발자에게 알아서 해석하라고 할 수는 없죠. 특히 마지막 주석인 위에서 동기화를 한 번 시켜주었기 때문에 null일 수 없다같은 내용이 반복되면, 코드를 읽는 사람은 '이 정보를 무시해야 한다'라는 생각이 머릿속을 가득 채워버려서 코드 읽기가 갈수록 버거워져요.\n\nfindByName()를 사용하는 10명 중 9명은 '이름을 통해 User 타입을 얻어가고 싶은' 개발자 고객일거에요. 그렇다면 이렇게 작성해 봅시다.\n\n\nuser도 더 이상 nullable 하지 않고, 분기문도 사라졌기 때문에 9명의 개발자 고객들은 편안해할 거예요. 그래도 아직 불편한 부분이 있네요. retryHandlerWhenMissing 를 항상 넣어줘야 한다는 점이죠.\n\n해결 3단계: 필요할 때만 제공하기\nretryHandlerWhenMissing이라는 함수를 추가했지만 이것도 역시 개발자에게 부담이 되네요. 적절한 기본값을 주거나 필요할 때만 기능을 사용할 수 있도록 제공하는 방식으로 바꿔보면 어떨까요?\n\n\nKotlin 언어를 사용한다면 default arguments 기능을 사용할 수 있어요. Kotlin이 아니라면 위와 같이 코드를 작성할 수 있고, retryHandlerWhenMissing 에 무엇을 넣어야 하는지 모르는 문제를 해결할 수 있죠. 비슷한 이유로 인자가 많은 함수는 나쁜데, 이 내용은 다음 글에서 다룰게요.\n\n이제는 retryHandlerWhenMissing을 매번 사용하지 않고, ResyncWhenUserMissing라고 미리 정의해 둔 동작을 사용할 수 있어요. 로직을 그대로 노출하지 않으면서도 코드의 의도를 더 분명히 드러냈어요.\n\n그런데 아직도 문제가 있어요. 이런 식으로 코드를 작성하려면 UserRepository를 구현하기 까다로워요.\n\n\n품질을 위해서 고민하다 보니 한 번 더 기술적인 문제에 부딪히게 됐네요. 이번엔 Spring 프레임워크에 대한 이해가 필요하겠군요. Spring은 저보다 여러분들이 더 잘 아실 테니 이건 연습 문제로 남겨둘게요. 반드시 이런 코드 형태가 아니어도 괜찮아요. 코드를 읽는 개발자가 혼란스럽지 않기만 하면 되거든요.\n\n여러 단계를 거치며 문제를 해결해 보니 어떠셨나요? '이렇게까지 해야 하나?' 혹은 '제품이 당장 내일 망할 수도 있는데… 이럴 시간 없는데…' 같은 생각을 하신 분들도 있을 거예요. 회사 코드는 오랜 시간 많은 개발자들의 손끝을 거치며 어렵고 복잡해지기 쉬워요. 문제가 수면 위로 드러났을 때 학습해서 적용하기엔 회사 코드의 난이도는 높습니다.\n\n그래서 우리는 미리 대비해야 합니다. 품질 높은 코드는 작성하는데 오래 걸리시나요? 어떻게 줄일 수 있을지 미리 고민해 보세요. 머릿속에 한 번에 넣어야 할, 기억해야 할 코드가 너무 많으신가요? 어떻게 하면 기억할 코드를 줄일 수 있을지 미리 고민해 보세요.\n\n다음 글에서는 더욱 구체적인 사례를 소개할게요. 감사합니다.\n\n\n👉 이런 문제 해결에 관심이 있다면 토스페이먼츠 서버 챕터에 지금 합류하세요!\n\n\nWriter 나재은 Edit 한주연","isDisplayingFeedback":true},{"id":23563,"updatedTime":"2023-11-22T20:35:45+09:00","createdTime":"2023-11-21T18:40:56+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"Feign 코드 분석과 서버 성능 개선","subtitle":"Feign과 다중 스레드를 사용하는 과정에서 생긴 문제를 이해하고 성능 개선까지 한 경험을 공유해요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/payments/contents/feign-thumb.jpg","videoUrl":null,"backgroundColor":null,"isFill":true,"imageAlt":"여러 코드를 다루고 있는 모습"},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/payments/contents/feign-thumb.jpg","backgroundColor":null,"isFill":true,"imageAlt":"여러 코드를 다루고 있는 모습"},"key":"engineering-note-3","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-11-22T14:30:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":23563,"title":null,"description":"Feign과 다중 스레드를 사용하는 과정에서 생긴 문제를 이해하고 성능 개선까지 한 경험을 공유해요.","urlSlug":"engineering-note-3","primaryKeyword":{"id":14007,"content":"Feign","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":14009,"content":"다중 스레드","wordType":"SEO_KEYWORD"},{"id":14013,"content":"성능 개선","wordType":"SEO_KEYWORD"},{"id":14017,"content":"HTTP Client","wordType":"SEO_KEYWORD"},{"id":14023,"content":"Keep-Alive","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"Feign 코드 분석과 서버 성능 개선","description":"Feign과 다중 스레드를 사용하는 과정에서 생긴 문제를 이해하고 성능 개선까지 한 경험을 공유해요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/finance-tips/img-financetip-og2.png","imageType":"기본 이미지"},"relatedPostConfig":null,"editor":{"id":1891,"name":"김성두","slug":"sungdukim","shortDescription":null,"description":"토스페이먼츠 서버 개발자","imageUrl":"https://static.toss.im/3d-emojis/u1F600.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"엔지니어링 노트 3: Feign 코드 분석과 서버 성능 개선\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. Feign과 다중 스레드를 사용하는 과정에서 생긴 문제를 이해하고 성능 개선까지 한 경험을 공유해요.\n\n얼마 전 토스페이먼츠 서버 모니터링 시스템을 통해 성능 저하 문제를 발견했어요. 약 15,000건 정도의 데이터를 10분 내외로 처리해야 하는 요구사항이 있어 다중 스레드를 활용했는데, 여기서 예상치 못하게 동시성 문제가 생겼습니다. 문제의 핵심은 HTTP 클라이언트 인터페이스인 Feign의 내부 구조에 숨어있었어요. 보통 Feign은 기본 설정을 그대로 사용하기 때문에 여기서 문제가 생길 거라고 예상하지 못했어요. 그래서 이번 문제를 해결하면서 직접 Feign의 내부를 들여다보았습니다. 그 내용과 문제 해결 과정을 공유드릴게요.\n\n💡 문제가 감지된 당시에 사용하던 서버 환경은 Sprinig Boot 2.7.9, 그리고 JDK 11입니다.\n1단계: 문제 이해하기\n당시 문제가 되었던 지점의 로그를 함께 살펴볼게요.\n\n\n로그 중간에 눈에 들어오는 부분이 있어요. locked가 보이네요. 토스페이먼츠 서버 모니터링 시스템은 블로킹 스레드를 탐지했을 때 스택 트레이스에 locked 문구를 추가해 줘요. 모니터링 시스템 덕분에 문제가 발생한 지점은 쉽게 찾을 수 있었지만, 원인은 아직 이해하지 못해서 좀 더 자세히 살펴보기로 했습니다.\n\n먼저, 문제가 발생한 KeepAliveCache 클래스의 put 메서드를 살펴봤어요. 다음 예시 코드에서 볼 수 있듯이 put 메서드에는 synchronized 키워드가 붙어있어요. 여러 스레드에서 대량으로 API를 호출하고 있는 상황에서 의심이 드는 지점이었죠.\n\n\n이어서 put 메서드를 호출하고 있는 지점이 어디인지 거슬러 올라가 봤어요. HttpsClient 클래스의 kac 라는 변수가 put 메서드를 호출하고 있었어요.\n\n\n마지막으로 KeepAliveCache kac이 무엇인지 알아보니 HttpClient 클래스의 정적 변수였다는 것을 알게 되었습니다.\n\n\n이제 실마리가 잡혔어요. KeepAliveCache kac 변수에 static 키워드가 붙어있기 때문에 HttpClient 클래스의 모든 인스턴스가 단 하나의 KeepAliveCache kac를 공유해서 사용하게 된 거였어요. KeepAliveCache kac는 공유자원인데 여러 스레드가 동시에 synchronized put 메서드를 수행하려고 하니 동시성 문제가 발생한 거예요.\n\n정리하자면 Feign 클라이언트를 사용한 API 호출이 엄청나게 많이 발생해서 다중 스레드를 활용했고, 그 과정에서 여러 스레드가 공유자원에 동시에 접근했어요. 결국 필요한 자원이 사용 가능해질 때까지 계속해서 대기 상태에 있었고요. 그래서 서버 성능이 저하되고, 제대로 요청을 받을 수 없는 상태가 되었던 거죠.\n\n더 알아보기: Feign 설정\n문제 원인은 알았지만 여전히 이해하기 어려운 부분이 있었습니다. 저는 분명히 Feign이 Apache HttpClient 5 버전을 사용하도록 설정해 뒀거든요. 눈썰미가 좋은 분이라면 눈치채셨을 수 있는데요. 문제가 된 sun.net.www.http.HttpClient 클래스는 Feign이 설정하는 기본 HTTP 클라이언트가 아니에요. 그럼 이 클래스는 도대체 어디서 온 걸까요?\n\nFeign의 내부 구현 코드를 따라가 보면 Feign 기본 HTTP 클라이언트는 Java Standard Library의 HttpURLConnection 클래스를 사용하는 것을 확인할 수 있어요. \n\n\n이 HttpURLConnection 클래스가 내부적으로 사용하는 HTTP 클라이언트에서 문제가 되는 sun.net.www.http.HttpClient를 사용하고 있어요.\n\n\n정리해 볼게요. Feign의 기본 HTTP 클라이언트는 내부적으로 Java Standard Library의 HttpURLConnection 클래스를 사용합니다. 자바에서는 이 클래스를 통해 HTTP 커넥션 관련 기능들을 제공하는데요. 이를 구현하는 과정에서 sun.net.www.http.HttpClient를 사용하게 되고, 이로 인해 동시성 문제가 발생할 수 있어요. (참고로 JDK 버전 17 이상에서는 Keep-Alive의 해당 구현을 개선했기 때문에, 더 이상 발생하지 않아요. 아래에서 좀 더 자세히 설명할게요.)\n\n2단계: 문제 해결과 성능 개선\n당장 문제를 해소할 수 있는 방법은 두 가지였어요. 첫 번째는 Feign 클라이언트가 사용하는 HTTP 클라이언트의 구현체를 변경하는 것, 두 번째는 JDK 버전을 17 이상으로 업그레이드하는 것이었어요.\n\n1. Feign Client 구현체 변경 (Apache HttpClient 5)\n\nFeign은 Apache HttpClient, OkHttp Client 등 다양한 HTTP 클라이언트를 주입 받아서 동작해요. 이때 특별한 설정을 하지 않으면 Feign이 제공하는 기본 클라이언트를 사용해요. 하지만 앞서 보았듯이, Feign의 기본 클라이언트는 HttpURLConnection 클래스를 사용하기 때문에 동시성 문제가 발생할 수 있어요. 즉, HttpURLConnection 클래스를 사용하지 않는 HTTP 클라이언트를 사용해야 하죠.\n\n토스페이먼츠에서는 여러 구현체 중 빠르고 효율적인 Apache HttpClient 5를 사용하고 있어요. 다음과 같이 Apache HttpClient 5 의존성을 설정해요.\n\n\n그런 뒤 Feign이 Apache HttpClient 5를 사용하도록 설정을 변경합니다.\n\n\n제가 겪은 문제는 사실 두 번째 Feign 설정을 누락하면서 발생했어요. Apache HttpClient 5 의존성만 주입해 주면 나머지는 언제나처럼 Spring Boot가 마법처럼 해결해 줄 거라 믿은 게 실수였죠. Spring Boot 2.x 버전을 사용하고 계신다면, 꼭 Feign의 위 설정을 true 로 바꿔주셔야 해요. 참고로 Spring Boot 3.x 버전부터는 의존성만 주입해도 자동 설정됩니다.\n\n\nFeign에 HTTP 클라이언트가 주입되는 방식이 궁금하다면, 아래 클래스에서 시작해서 코드를 따라가 보시는 것을 추천할게요. 다음과 같이 registerFeignClients 메서드를 따라가다 보면,\n\n\nFeign.Builder static 클래스의 client 변수가 적절하게 설정되는 것을 확인할 수 있을 거예요.\n\n\n특히 Feign이 Apache HttpClient 5 구현체를 사용하도록 설정하는 부분의 클래스 코드는 다음과 같아요. \n\n\n2. JDK 버전 17 이상으로 업데이트\n\nJDK 17 버전에서는 위의 디버깅 과정에서 보았던 동시성 문제를 야기하는 내부 구현이 개선되었어요. 코드를 보면 synchronized 키워드가 제외된 것을 확인하실 수 있어요. 따라서 위에서 제가 겪은 문제가 발생하지 않아요.\n\n위의 두 가지 해결 방법 중 어느 것을 선택해도 괜찮아요. 아주 간단한 방법이지만 동시성 문제를 해결한 결과,\n\nAPI 처리량이 최소 8배 이상 향상되는 것을 확인할 수 있었어요.\n평균 10분 정도 소요되던 작업이 1분 대로 줄었어요.\n\n지금까지 Feign과 다중 스레드를 사용하는 과정에서 생긴 문제에 대해 알아보았어요. 문제 해결과 성능 개선에서 그치지 않고 우리가 의심없이 사용하고 있는 도구 중 하나인 Feign을 깊이 있게 이해할 수 있는 기회였습니다.\n\n\n👉 이런 문제 해결에 관심이 있다면 토스페이먼츠 서버 챕터에 지금 합류하세요!\n\n\nWriter 김성두 Edit 한주연","isDisplayingFeedback":true},{"id":22999,"updatedTime":"2023-11-06T11:06:01+09:00","createdTime":"2023-10-25T10:32:50+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"웹에서 복잡한 퍼널 쉽게 관리하기","subtitle":"토스페이먼츠 프론트엔드 챕터에서 웹에서 퍼널을 손쉽게 관리하기 위해 했던 고민과 해결 방법을 공유해요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":"","imageAlt":null,"title":"이런 문제 해결에 관심이 있다면","description":null,"ctaName":"프론트엔드 챕터 합류하기","landingUrl":"https://toss.im/career/job-detail?job_id=4071101003&company=%ED%86%A0%EC%8A%A4%ED%8E%98%EC%9D%B4%EB%A8%BC%EC%B8%A0","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D4071101003%26company%3D%25ED%2586%25A0%25EC%258A%25A4%25ED%258E%2598%25EC%259D%25B4%25EB%25A8%25BC%25EC%25B8%25A0&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=4071101003&company=%ED%86%A0%EC%8A%A4%ED%8E%98%EC%9D%B4%EB%A8%BC%EC%B8%A0"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/payments/contents/engineering_thumb.jpg","videoUrl":null,"backgroundColor":null,"isFill":true,"imageAlt":"사람이 점들을 연결하고 있는 모습"},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/payments/contents/engineering_thumb.jpg","backgroundColor":null,"isFill":true,"imageAlt":"사람이 점들을 연결하고 있는 모습"},"key":"engineering-note-1","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-10-18T09:00:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22999,"title":null,"description":"토스페이먼츠 프론트엔드 챕터에서 웹에서 퍼널을 손쉽게 관리하기 위해 했던 고민과 해결 방법을 공유해요.","urlSlug":"engineering-note-1","primaryKeyword":{"id":3882,"content":"프론트엔드","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":3529,"content":"토스페이먼츠","wordType":"SEO_KEYWORD"},{"id":13506,"content":"퍼널","wordType":"SEO_KEYWORD"},{"id":13508,"content":"웹브라우저","wordType":"SEO_KEYWORD"},{"id":13510,"content":"결제 흐름","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"엔지니어링 노트 1: 웹에서 복잡한 퍼널 쉽게 관리하기","description":"토스페이먼츠 프론트엔드 챕터에서 웹에서 퍼널을 손쉽게 관리하기 위해 했던 고민과 해결 방법을 공유해요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/payments/contents/engineering_thumb.jpg","imageType":"직접입력"},"relatedPostConfig":null,"editor":{"id":1271,"name":"임재후/최수민","slug":"smile-emoji","shortDescription":null,"description":"토스페이먼츠 임재후, 최수민","imageUrl":"https://static.toss.im/3d-emojis/u1F600.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"엔지니어링 노트 1: 복잡한 퍼널 쉽게 관리하기\n\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 첫 번째는 프론트엔드 이야기인데요. 웹에서 퍼널을 손쉽게 관리할 수 있도록 만든 모듈을 소개합니다.\n토스 제품 디자인 원칙(PP: Product Principle)엔 “One thing for One Page”라는 원칙이 있어요. 화면 하나에는 명확한 목표 하나만 있어야 한다는 건데요. 이 원칙에 따라 제품을 만들다 보면 ‘퍼널’이 많이 생깁니다. 토스페이먼츠의 제품도 예외는 아니에요. 그래서 저희 프론트엔드 개발자들은 퍼널의 흐름을 잘 관리해야 하죠. 퍼널이란 사용자가 웹사이트를나 애플리케이션을 방문해서 최종 목표까지 달성하는데 거치는 단계를 뜻합니다.\n\n오늘은 토스페이먼츠의 프론트엔드 개발자들이 이 흐름을 어떻게 관리하고 있는지 소개하고, 이 방법의 좋은 점과 아쉬운 지점까지 공유해 볼게요.\n\n문제: 퍼널 관리의 어려움\n결제를 떠올리면 보통 어떤 흐름이 생각나시나요? 주문서에서 신용∙체크카드와 같은 결제 수단을 선택한 뒤(퍼널 1) 결제하기 버튼을 누르고(퍼널 2), 카드 결제창에서 내 카드사를 선택한 뒤(퍼널 3) 앱카드 등으로 인증한 뒤(퍼널 4) 다시 주문하던 페이지로 돌아오는(퍼널 5) 과정이 익숙한 흐름입니다.\n\n그런데 결제 제품에는 이렇게 최종 사용자가 경험하는 단순한 흐름 말고도 개발자가 다뤄야 하는 다른 여러 퍼널들이 있습니다. \n\n쉬운 계좌이체를 도와주는 퀵계좌결제를 처음 사용하는 시나리오에서 내 계좌를 연결하는 과정은 다음과 같아요.\n\n\n결제 페이지 - ‘계좌 추가’ 선택\n은행 선택 페이지 - 은행 선택\n계좌번호 입력 페이지 - 계좌번호 입력\nARS 인증 페이지 - ARS 인증 진행 및 완료\n계좌 등록 완료 페이지 - ‘확인’ 클릭\n결제페이지로 돌아옵니다.\n이때 각 단계에서 유저가 ‘뒤로가기’를 한다고 생각해볼게요. 2, 3, 4단계에서 뒤로가기를 하면 바로 전 단계로 이동하면 됩니다. 그런데 5, 6단계에서는 뒤로가기를 하면 어떨까요? 5단계에서 4단계로 이동한다면, 이미 인증된 ARS 페이지에 다시 접근하는 것이기 때문에 유저에게는 비정상적인 흐름이 됩니다. 6단계에서도 5단계로 이동하기보다는, 직관적으로 1단계에서 뒤로가기를 했을 때와 똑같이 작동하는게 자연스러워 보여요.\n\n이렇게 퍼널이 많아지면서 히스토리를 관리하기가 까다로워졌어요. 모바일 애플리케이션이라면 회원가입 내비게이션 스택이나 ARS 인증 내비게이션 스택을 통째로 없애면 될 텐데, 토스페이먼츠의 결제 제품들은 웹 기술로 만들고 있어요. 웹 브라우저의 히스토리는 단일 스택으로만 관리하기 때문에 같은 방식으로 구현할 수가 없었어요.\n\n해결 방법: 퍼널 관리 모듈\n이 문제를 해결하기 위해 검토했던 두 가지 방법과 최종 해결 방법을 소개할게요.\n\n첫 번째 해결 방법은 ‘각 퍼널을 싱글 페이지 앱(SPA)처럼 만들기’예요. 작은 퍼널 안에선 히스토리를 쌓지 않고 싱글 페이지로 만드는 방법이에요. 그런데 이 방법을 사용하면 퍼널 중간에 브라우저 뒤로가기를 대응할 수 없다는 문제가 있어요. 예를 들어 계좌 등록 퍼널에서 은행 선택 후 계좌번호 입력 퍼널에서 뒤로가기를 선택하면 은행 선택 페이지로 돌아갈 수 없어요. 또, 사용자가 새로고침을 하면 해당 페이지를 유지하지 못하고 시작점으로 돌아갈 수 밖에 없는 문제도 있었죠.\n\n다음으로 쿼리 파라미터로 관리하는 해결 방법을 고민했어요. 각 단계를 /user-register?step=1과 같은 URL 쿼리 파라미터로 표현하는 방식이에요. 그런데 이 방식을 사용하면 ‘작은’ 퍼널을 재사용하고 싶을 때 까다로워지더라고요. 퍼널이 끝난 뒤 어디로 돌아가야 하는지에 대한 정보를 계속 URL에 들고 다녀야 하기 때문이에요. 예를 들어 비밀번호 등록이라는 작은 퍼널이 끝났을 때, 회원가입 퍼널로 돌아가야 하는지, 계좌등록 퍼널로 돌아가야 하는지 알아야 하니까요.\n\n그래서 저희는 ‘Flow’라는 이름의 퍼널 관리 모듈을 만들었어요. 이 모듈을 사용하면 여러 개의 페이지를 오가며 퍼널에서 해야 할 일을 수행하고, 할 일을 마치면 히스토리 스택을 비울 수 있어요. 실제 모듈 코드보다 단순화한 코드로 먼저 살펴볼게요.\n\n\n여기서 핵심은 pageCount입니다. 이 모듈은 결국 시작한 지점에서 페이지를 몇 개 지나왔는지를 추적하는 객체인 셈이죠. \n\n이번에는 사용하는 쪽 코드도 살펴볼게요. 퀵계좌결제에서 에스크로 관련 정보를 등록하는 흐름이에요. 먼저 전체 흐름을 이미지로 살펴볼게요.\n\n계좌 결제 → 에스크로 서비스 정보 등록 → SMS 인증 → 비밀번호 등록 \n\n\n위와 같이 모듈을 사용해 봤어요.\n\nPayScreen에서 에스크로 흐름을 시작하고, EscrowScreen에선 에스크로 로직을 모두 끝낸 뒤 에스크로 흐름을 끝내면 돼요.\n\n모듈을 통해 히스토리 관리가 힘들었던 문제도 풀어냈어요. 훅에서 반환하는 end 함수만 호출하면 모바일 애플리케이션에서 내비게이션 스택을 없애는 것과 같은 효과를 얻었습니다.\n\n만약 Flow가 없다면 코드가 분산되어 유스케이스 읽듯이 자연스럽게 읽을 수 없어요.\n\n\n장점과 한계\nFlow를 사용하면 히스토리 관리를 편하게 할 수 있을 뿐 아니라 선언적으로 코드를 작성할 수 있다는 점이 정말 매력적이에요. 간단한 예를 들어볼게요.\n\n\n최근 토스페이먼츠 프론트엔드 챕터는 다음 이미지에 있는 것처럼 개발을 시작하기 전에 전체적인 시나리오(개발 명세)를 먼저 작성한 뒤 개발하기 위해 노력하고 있는데요. Flow를 이용하니 이렇게 작성한 시나리오 그대로 구현하기 편리했어요. \n\n\n\n위에서 살펴본 코드 예제 중 위 부분은 사실 다음 시나리오를 그대로 코드로 표현한 결과물이에요.\n\n\n또 흐름의 시작과 끝을 독립적으로 관리할 수 있다는 장점도 있어요. 앞서 고려했던 URL 쿼리 파라미터를 사용할 때처럼 이전 퍼널과 다음 퍼널에 대한 정보를 들고 있을 필요 없이 시작과 끝을 모두 독립적으로 처리할 수 있어요. Flow.end()만 호출하면 되니까요.\n\n물론 Flow도 완벽하진 않아요. Flow 를 여러 개 이어 붙이는 경우를 생각해 볼게요. 유저에겐 A → B → C → D 순서대로 흘러가는 것처럼 보이지만, Flow를 사용하면 실제 화면 이동 흐름은 A → B → A(잠깐) → C → A(잠깐) → D가 돼요. 그래서 이동할 때 잠깐씩 이전 화면인 A가 보여 깜빡이는 것 같은 문제가 생겼어요.\n\n또, 시작과 끝이 독립적인 대신 start를 부르는 곳과 end를 호출하는 곳이 멀어져서 코드를 읽기가 어려워지는 문제도 있어요.\n\n복잡하고 반복되는 퍼널 관리, 토스페이먼츠에서는 이렇게 해결하고 있어요. 다른 분들은 퍼널을 어떻게 관리하고 계신지 궁금해요. 참고로 토스 계열사 중 한 곳인 '토스모바일'에서는 useFunnel을 사용하고 있는데요. 토스페이먼츠에서는 히스토리 관리가 필요해서 useFunnel을 사용하는 대신 Flow 모듈을 새로 만들었어요. Flow 모듈이나 문제 해결 방법에 대한 피드백, 혹은 우리 팀에서 사용하고 있는 더 나은 방법이 있다면 자유롭게 댓글로 공유해주세요.\n\n\n👉 이런 문제 해결에 관심이 있다면 토스페이먼츠 프론트엔드 챕터에 지금 합류하세요!\n\n\nWriter 임재후, 최수민 Edit 한주연 Graphic 이은호, 이나눔","isDisplayingFeedback":true},{"id":22911,"updatedTime":"2023-10-12T20:30:27+09:00","createdTime":"2023-10-12T20:05:46+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"유연하고 안전하게 배포 Pipeline 운영하기","subtitle":"생산성, 안정성, 보안성을 모두 달성하기 위해선 ‘Pipeline’을 어떻게 설정해야 할까요?\n다양하고 복잡한 토스뱅크의 배포 ‘Pipeline’를 안전하게 운영하기 위한 노력을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_06_김동석.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_06_김동석.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-devops","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-10-12T20:30:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22911,"title":null,"description":"생산성, 안정성, 보안성을 모두 달성하기 위해선 ‘Pipeline’을 어떻게 설정해야 할까요?\n다양하고 복잡한 토스뱅크의 배포 ‘Pipeline’를 안전하게 운영하기 위한 노력을 소개합니다.","urlSlug":"slash23-devops","primaryKeyword":{"id":11972,"content":"SLASH23","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":3847,"content":"토스 개발자","wordType":"SEO_KEYWORD"},{"id":3934,"content":"토스 개발 컨퍼런스","wordType":"SEO_KEYWORD"},{"id":11953,"content":"devops","wordType":"SEO_KEYWORD"},{"id":13455,"content":"파이프라인","wordType":"SEO_KEYWORD"},{"id":13456,"content":"자동화","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"유연하고 안전하게 배포 Pipeline 운영하기","description":"생산성, 안정성, 보안성을 모두 달성하기 위해선 ‘Pipeline’을 어떻게 설정해야 할까요?\n다양하고 복잡한 토스뱅크의 배포 ‘Pipeline’를 안전하게 운영하기 위한 노력을 소개합니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_og_06_김동석.png","imageType":"직접입력"},"relatedPostConfig":{"id":3312,"relatedPosts":[{"id":22910,"updatedTime":"2023-10-12T19:52:42+09:00","createdTime":"2023-10-12T19:10:45+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"토스는 Gateway 이렇게 씁니다","subtitle":"더 안전하고 안정적인 서비스 운영을 위해서 ‘gateway’를 어떻게 사용해야 할까요? \n토스의 수많은 마이크로서비스 로직을 공통화하기 위한 gateway 운영 방법에 대해 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_05_최준우.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_05_최준우.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-server","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-10-12T19:52:00+09:00","commentBoard":null,"disclaimer":null},{"id":22896,"updatedTime":"2023-10-12T16:05:36+09:00","createdTime":"2023-10-11T18:25:48+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"대규모 로그 처리도 OK! Elasticsearch 클러스터 개선기","subtitle":"일평균 56억 건 이상 수집되는 토스증권의 로그, 어떻게 효율적으로 처리할까요?\n큰 폭으로 늘어나는 대규모 로그 처리를 위한 ‘Elasticsearch 클러스터 개선 경험’을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_04_%EC%9D%B4%EC%A4%80%ED%99%98.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_04_%EC%9D%B4%EC%A4%80%ED%99%98.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-data","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-10-12T16:03:00+09:00","commentBoard":null,"disclaimer":null},{"id":22565,"updatedTime":"2023-10-11T16:38:50+09:00","createdTime":"2023-09-01T12:10:36+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"금융사 최초의 Zero Trust 아키텍처 도입기","subtitle":"왜 보안이 강화될수록, 업무는 불편해지는 걸까요? \n금융에서 가장 중요한 가치인 ‘안전’과 혁신을 위한 ‘업무 편의성’, 두 마리 토끼를 모두 잡기 위한 여정을 소개합니다.  ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-security","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-09-01T11:59:00+09:00","commentBoard":null,"disclaimer":null},{"id":22563,"updatedTime":"2023-10-11T17:04:28+09:00","createdTime":"2023-08-31T23:16:00+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"은행 최초 코어뱅킹 MSA 전환기 (feat. 지금 이자 받기)","subtitle":"수십 년간 정체되어 있던 전통적인 은행 시스템의 모놀리식 소프트웨어 아키텍처를 MSA로 전환할 수 있을까요? \n토스뱅크의 ‘코어뱅킹 MSA 전환’ 사례를 통해 향후 은행 시스템이 나아가야 할 방향을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_02.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_02.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-corebanking","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-31T23:37:00+09:00","commentBoard":null,"disclaimer":null},{"id":22478,"updatedTime":"2023-10-11T17:03:23+09:00","createdTime":"2023-08-22T17:10:44+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"레고처럼 조립하는 토스 앱","subtitle":"수많은 서비스를 담고 있는 대규모 iOS 앱에 어울리는 아키텍처는 무엇일까요?\n프로젝트 간의 의존성과 모듈 간의 결합도를 낮춰, 더 효율적인 서비스 개발, 관리를 이뤄낸 과정을 소개합니다. ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-iOS","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-22T17:46:00+09:00","commentBoard":null,"disclaimer":null}],"title":"함께 읽어보면 좋을 콘텐츠"},"editor":{"id":1022,"name":"김동석","slug":"dongsuk-kim","shortDescription":"DevOps Engineer","description":"-","imageUrl":"https://static.toss.im/career-resource/dongsuk-kim.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스뱅크에는 400개가 넘는 배포 Pipeline 이 있습니다. Pipeline의 개수가 많아지고, 종류가 다양해지고, 동작이 복잡해지며 여러 어려움이 생기는데요. 토스뱅크에서 Pipeline을 유연하고 안전하게 운영하기 위해 노력한 이야기를 소개해 보려 합니다.\n\nPipeline이란?\n반복하는 일을 자동화하는 시스템을 말합니다. 서버 프로그램을 빌드하고 배포하는 Pipeline 이 가장 대표적인데요. 라이브러리를 업로드하거나 운영 작업을 자동화하는 데에도 많이 활용합니다. Micro Service Architecture를 적극적으로 활용하는 토스뱅크에서는 하루에도 수십~수백 번 서버를 배포하기 때문에, Pipeline 은 동료 개발자분들이 일상적으로 가장 많이 사용하는 시스템 중 하나입니다.\n\nPipeline에 필요한 것\n\n토스뱅크에서는 새로운 서비스가 자주 생기고 서비스의 동작이 자주 변하기 때문에 Pipeline을 빠르게 만들고 수정할 수 있어야 합니다. 서비스를 안정적으로 운영하려면 Pipeline들이 일관성 있게 동작해야 하고요. 그리고 모든 Pipeline에서 반드시 지켜야 하는 Compliance 요건이 있습니다. 토스뱅크와 같은 금융권 회사들을 전자금융감독규정이 적용됩니다. 서버를 배포할 때 동료끼리 검증을 하는 등의 절차를 Pipeline에서 준수해야 합니다. 저희는 이런 요건들을 잘 충족하기 위해서는 Pipeline 설정을 중앙화하는 것이 효율적이라고 판단하였고, 여러 스쿼드가 사용하는 Pipeline 설정을 한 곳에 모아두고 DevOps Engineer가 주도적으로 운영하고 있습니다.\n\nGoCD\n\nPipeline 도구로는 Jenkins, GitHub Actions 등 여러 가지가 있는데요. 토스뱅크에서는 GoCD를 주로 사용합니다. GoCD는 Pipeline을 정의에 따라 Server가 작업을 할당하고 Agent가 실행하는 구조입니다. 널리 사용되는 Jenkins 와 비슷합니다.\n\n첫 번째 어려움: 가시성\n\nGoCD에서 새로운 Pipeline을 만들 때에는 웹 UI에서 Pipeline Wizard를 사용합니다. Pipeline 개수가 많지 않을 때에는 이렇게 Pipeline 을 만들고 수정해도 큰 어려움이 없었지만, Pipeline 개수가 많아지면서 어려움을 겪었습니다.\n\n\n토스뱅크에는 서비스 빌드/배포 Pipeline이 281개, 작업 자동화 Pipeline이 76개, 이외 Pipeline이 47개, 도합 400개가 넘는 Pipeline이 있습니다. Pipeline이 많으면 웹 UI에서는 어떤 Pipeline이 있는지 확인하는 것부터 쉽지 않습니다. 한 화면에서 보이는 Pipeline 개수가 많지 않기 때문인데요. 자신이 찾는 Pipeline의 이름을 알고 있다면 검색해서 찾을 수 있지만, 그렇지 않다면 모든 Pipeline을 훑어봐야 합니다.\n\n\n그리고 Pipeline 하나의 설정을 보는 것도 어렵습니다. 일반적으로 Pipeline은 여러 단계를 갖는데요. 웹 UI에서는 한 단계씩 볼 수 있기 때문에 각 단계의 순서와 동작을 확인하려면 여러 페이지를 왔다 갔다 해야 합니다. 마찬가지로 서로 다른 Pipeline의 설정을 비교하기도 어렵고요.\n\n가장 큰 문제는 Pipeline 설정이 어떻게 변했는지 알기 어렵다는 것입니다. Pipeline의 동작은 계속 변합니다. 배포 방식이 달라지기도 하고 Compliance 요건이 변하기도 하지요. 하지만 웹 UI에서는 지금의 설정만 볼 수 있기 때문에, Pipeline 동작이 무언가 이상해서 확인해 볼 때에 언제 어떻게 설정이 변했는지 알기 어렵습니다.\n\nPipeline as Code\n이때에는 Pipeline as Code 가 도움이 되었습니다. Pipeline 을 웹 UI에서 정의하지 않고 코드로 표현하여 Git에 저장하는 것을 말하는데요. 저희는 Pipeline 설정을 YAML 파일로 작성하여 Git에 저장하고, GoCD 서버와 연동하는 gocd-yaml-config-plugin을 활용했습니다.\n\n\n모든 Pipeline 설정이 파일로 저장되어 있으니 어떤 Pipeline 이 있는지 Git 저장소에서 한 번에 볼 수 있습니다. 수백 개의 Pipeline 이 있더라도 한 폴더에서 모두 확인할 수 있지요.\n\n\n여러 단계로 이루어진 Pipeline 설정도 한 파일에서 모든 설정과 단계를 볼 수 있습니다.\n\n\n그리고 Pipeline 설정 파일이 Git 저장소에서 Version Control 되기 때문에 언제 어떻게 변경되었는지 확인할 수 있습니다.\n\n두 번째 어려움: 생산성\n\n토스뱅크의 Pipeline 개수를 약 6개월 간격으로 집계해 보면 1년에 2배 이상으로 많아지는 것을 볼 수 있습니다. 토스뱅크는 Micro Service Architecture를 적극적으로 활용하고 있어 새로운 서비스를 자주 만들기 때문에 Pipeline 을 빠르고 정확하게 만들 수 있어야 합니다. 한편, 새로운 서비스는 기존 서비스와 기술 스택과 구조가 비슷한 경우가 많기 때문에, 이미 있는 Pipeline 설정을 복사 붙여넣기해서 새로운 Pipeline을 만들 때가 많습니다. 이때 설정을 잘못 붙여넣기도 하고, 바꾸어야 할 부분을 빼먹는 등 실수를 하기 쉽습니다. 그리고 모든 Pipeline에 공통된 변경 사항이 있을 때에는 모든 파일을 수정해야 하는데, 이때에도 실수를 하기 쉽습니다. 잘못된 설정을 찾아내고 바로잡는 것은 Pipeline을 빠르게 만들고 수정하는 일에 걸림돌이 되었지요.\n\nGoCD Template\n\n이 문제에는 GoCD Template이 도움 되었습니다. Pipeline 동작을 추상화해서 Template으로 만들고 여러 Pipeline에서 공유하는 기능인데요. 앞서 살펴 본 gocd-yaml-config-plugin과도 함께 사용할 수 있습니다.\n\n\n공통 설정은 Template을 지정하는 한 줄로 대체되어 훨씬 간결해지고, 서로 달라야 하는 설정은 변수로 주입할 수 있습니다. 공통 변경 사항이 있을 때에는 Template에서 변경하면 모두에게 적용되고요. Pipeline을 만들고 수정할 때 실수를 할 여지가 상당히 줄어듭니다.\n\n세 번째 어려움: 확장성\n프로그래밍에서 변경에 유연하게 대처할 수 있는 코드를 확장성이 높다고 이야기하는데요. Pipeline 역시 설정을 변경할 때 유연하게 대처할 수 있어야 합니다. 하지만 지금까지 살펴 본 방식으로는 Pipeline 설정은 Git에서, Template 설정은 웹 UI 에서 봐야 하기 때문에 둘을 비교하면서 Template을 수정하는 것이 꽤나 불편했습니다. 그리고 Template을 수정하면 많은 Pipeline에 한 번에 적용되기 때문에 실수를 했을 때 영향이 굉장히 큽니다. 결과적으로 Pipeline 설정을 유연하게 변경하기 어려웠는데요.\n\nHelm Template\n\n저희는 Template Rendering 도구인 Helm Template으로 이 문제를 해결해 보기로 했습니다. Helm Template은 공통 부분을 Template으로 만들고 고유한 부분을 Values로 주입하여 Rendering 할 수 있으며, 조건문과 반복문, 변수를 활용하여 꽤나 복잡한 내용도 표현할 수 있습니다.\n\n\nHelm Template은 YAML 파일을 잘 지원하기 때문에 앞서 보았던 gocd-yaml-config-plugin과도 잘 어울립니다. YAML로 된 Pipeline 설정을 추상화하여 Helm Template으로 만들면 GoCD Template을 대체할 수 있을 뿐만 아니라, GoCD Template에서 지원되지 않는 부분도 Template으로 사용할 수 있습니다. 이렇게 만든 Helm Template은 파일로 저장되기 때문에, Pipeline 설정 파일과 동일한 Git 저장소에 두면 Pipeline 설정과 Template 설정을 한 곳에서 확인할 수 있습니다.\n\n\n그리고 Helm Template의 조건문을 활용하면 Template 변경을 일부 Pipeline에서만 테스트해 볼 수도 있습니다. 전체 Pipeline에 적용하기 전에 테스트용 Pipeline에서 충분히 동작을 검증할 수 있게 되었고, Template 변경 실수가 모든 Pipeline에 영향을 주는 일이 줄어들었습니다.\n\n\n한편, Helm Template을 활용하면 호환성에서도 이점이 있습니다. GoCD Template 등 Pipeline 도구 고유의 기능은 그 도구에서만 사용할 수 있지만, Helm Template의 Values 파일은 Pipeline 도구와 무관한 추상적인 설정을 담고 있습니다. GitHub Actions 등 다른 Pipeline 도구를 사용할 때에는 그에 맞도록 Template 파일만 새로 작성하면 Values 파일을 재사용할 수 있습니다.\n\n네 번째 어려움: 복잡성\n\nPipeline Template은 시간이 지나며 점점 복잡해집니다. 2023년 1월 기준으로 토스뱅크의 Pipeline은 5가지 Type과 72개의 설정값이 있고, Template 파일 길이를 모두 더하면 1,182 줄이 됩니다. Template이 복잡할수록 실수로 오타를 내거나 의도하지 않은 변경을 만들기 쉽습니다. Helm Template 문법은 일반 프로그래밍 언어만큼 직관적이지는 않기 때문에 더욱 그렇습니다. Pipeline Template을 잘못 수정해서 배포가 안되거나 잘못된 배포가 되는 일이 종종 있었는데요.\n\nCI\n저희는 CI를 도입해 보기로 했습니다. CI는 Continuous Integration의 약자로, 변경 사항에 대하여 자동으로 검증을 진행하고 성공했을 때에만 반영하는 것을 말합니다. Template 파일은 develop 브랜치에서만 수정하고, 검증을 통과했을 때에만 master 브랜치에 반영되도록 GitHub Actions로 CI를 구성했습니다.\n\n\n검증은 develop 브랜치에 변경 사항이 생기면 모든 Pipeline 설정 파일을 다시 Rendering 하는 것입니다. 의도한 변경은 이미 반영되어 있을 것입니다. 반면 다시 Rendering 할 때 바뀌는 파일 내용은 의도하지 않은 변경일 확률이 높습니다. CI를 수행하는 동안 Pipeline 설정 파일 내용이 바뀌었다면 한 번 확인해 봐야 합니다. 이때에는 검증이 실패하고, 사내 메신저로 알람을 보내 작업자가 다시 확인하도록 합니다.\n\nKubernetes Object CI\n\n한편, 토스뱅크의 채널계 서비스는 Kubernetes에서 운영하고 있으며, 서비스를 배포할 때에는 Helm Template을 사용해 Kubernetes Object를 배포합니다. 2023년 1월 기준으로 토스뱅크의 Kubernetes Object Template은 7가지 Object와 110개의 설정 값이 있고, Template 파일 길이를 모두 더하면 762줄이 됩니다. 앞서 살펴 본 Pipeline Template처럼 복잡한 Template을 사용하기 때문에, 마찬가지로 Template을 수정할 때 실수를 하기 쉬웠습니다.\n\n\n한편, Kubernetes Object는 Pipeline 설정과 다른 점이 있었는데요. Helm Template으로 Rendering 한 결과를 Kubernetes에 배포할 뿐, Git에 파일로 저장하지 않는다는 것입니다. CI로 검증을 수행할 때에 비교할 파일이 없는 것인데요. 그래서 검증용 Kubernetes Object 파일을 Git에 저장하기로 했습니다.\n\n\nCI를 수행할 때에는 모든 검증용 Kubernetes Object 파일을 다시 Rendering 합니다. 의도한 변경은 이미 검증용 Kubernetes Object 파일에 반영되어 있을 것이고, 다시 Rendering 할 때 바뀌는 파일 내용은 의도하지 않았을 확률이 높습니다. 이때에는 Pipeline CI와 마찬가지로 사내 메신저 알람을 보냅니다.\n\nCI를 수행하는 동안 Pipeline 설정 파일과 검증용 Kubernetes Object 파일 모두 내용이 바뀌지 않는다면, 의도하지 않은 변경 사항이 없는 것으로 간주하고 master 브랜치에 자동으로 반영합니다. 이후에 실행하는 Pipeline 과 이후에 배포되는 Kubernetes Object는 변경 사항이 반영된 Template을 사용합니다.\n\n마치며\n마무리하며 글의 내용을 요약해 보면 아래와 같습니다.\n\nPipeline이 너무 많아서 어떤 것들이 있고 어떻게 설정되어 있는지 확인하기 어렵다면 Pipeline as Code가 도움이 됩니다.\nPipeline을 빠르고 정확하게 만들기 위해서는 Template 기능이 도움이 됩니다.\nPipeline Template을 수정하기 어렵다면 Helm Template이 도움이 됩니다.\nPipeline 이 너무 복잡해서 수정할 때 실수가 많다면 CI를 도입하는 것이 도움이 됩니다.\nPipeline as Code는 일반적으로 Version-control이 되는 Pipeline을 뜻하는 경우가 많습니다. Pipeline 설정을 파일 형태로 저장하고 Git에서 확인하는 것까지를 말하지요. 여기에 Helm Template으로 Programmable 한 특성을, CI로 Testable 한 특성을 더하면 정말 Code처럼 유연하고 안전하게 Pipeline을 운영할 수 있다고 생각합니다. 비슷한 고민을 하셨던 분이 계시다면 조금이나마 도움이 되었으면 좋겠습니다.","isDisplayingFeedback":true},{"id":22910,"updatedTime":"2023-10-12T19:52:42+09:00","createdTime":"2023-10-12T19:10:45+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"토스는 Gateway 이렇게 씁니다","subtitle":"더 안전하고 안정적인 서비스 운영을 위해서 ‘gateway’를 어떻게 사용해야 할까요? \n토스의 수많은 마이크로서비스 로직을 공통화하기 위한 gateway 운영 방법에 대해 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_05_최준우.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_05_최준우.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-server","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-10-12T19:52:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22910,"title":null,"description":"더 안전하고 안정적인 서비스 운영을 위해서 ‘gateway’를 어떻게 사용해야 할까요? \n토스의 수많은 마이크로서비스 로직을 공통화하기 위한 gateway 운영 방법에 대해 소개합니다.","urlSlug":"slash23-server","primaryKeyword":{"id":11972,"content":"SLASH23","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":3744,"content":"토스 서버 개발자","wordType":"SEO_KEYWORD"},{"id":3847,"content":"토스 개발자","wordType":"SEO_KEYWORD"},{"id":4100,"content":"서버 개발자","wordType":"SEO_KEYWORD"},{"id":13452,"content":"Gateway","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"토스는 Gateway 이렇게 씁니다","description":"더 안전하고 안정적인 서비스 운영을 위해서 ‘gateway’를 어떻게 사용해야 할까요? \n토스의 수많은 마이크로서비스 로직을 공통화하기 위한 gateway 운영 방법에 대해 소개합니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_og_05_최준우.png","imageType":"직접입력"},"relatedPostConfig":{"id":3311,"relatedPosts":[{"id":22896,"updatedTime":"2023-10-12T16:05:36+09:00","createdTime":"2023-10-11T18:25:48+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"대규모 로그 처리도 OK! Elasticsearch 클러스터 개선기","subtitle":"일평균 56억 건 이상 수집되는 토스증권의 로그, 어떻게 효율적으로 처리할까요?\n큰 폭으로 늘어나는 대규모 로그 처리를 위한 ‘Elasticsearch 클러스터 개선 경험’을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_04_%EC%9D%B4%EC%A4%80%ED%99%98.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_04_%EC%9D%B4%EC%A4%80%ED%99%98.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-data","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-10-12T16:03:00+09:00","commentBoard":null,"disclaimer":null},{"id":22565,"updatedTime":"2023-10-11T16:38:50+09:00","createdTime":"2023-09-01T12:10:36+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"금융사 최초의 Zero Trust 아키텍처 도입기","subtitle":"왜 보안이 강화될수록, 업무는 불편해지는 걸까요? \n금융에서 가장 중요한 가치인 ‘안전’과 혁신을 위한 ‘업무 편의성’, 두 마리 토끼를 모두 잡기 위한 여정을 소개합니다.  ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-security","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-09-01T11:59:00+09:00","commentBoard":null,"disclaimer":null},{"id":22563,"updatedTime":"2023-10-11T17:04:28+09:00","createdTime":"2023-08-31T23:16:00+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"은행 최초 코어뱅킹 MSA 전환기 (feat. 지금 이자 받기)","subtitle":"수십 년간 정체되어 있던 전통적인 은행 시스템의 모놀리식 소프트웨어 아키텍처를 MSA로 전환할 수 있을까요? \n토스뱅크의 ‘코어뱅킹 MSA 전환’ 사례를 통해 향후 은행 시스템이 나아가야 할 방향을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_02.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_02.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-corebanking","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-31T23:37:00+09:00","commentBoard":null,"disclaimer":null},{"id":22478,"updatedTime":"2023-10-11T17:03:23+09:00","createdTime":"2023-08-22T17:10:44+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"레고처럼 조립하는 토스 앱","subtitle":"수많은 서비스를 담고 있는 대규모 iOS 앱에 어울리는 아키텍처는 무엇일까요?\n프로젝트 간의 의존성과 모듈 간의 결합도를 낮춰, 더 효율적인 서비스 개발, 관리를 이뤄낸 과정을 소개합니다. ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-iOS","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-22T17:46:00+09:00","commentBoard":null,"disclaimer":null}],"title":"함께 읽어보면 좋을 콘텐츠"},"editor":{"id":1189,"name":"최준우","slug":"junwoo-choi","shortDescription":"Server Developer","description":"-","imageUrl":"https://static.toss.im/career-resource/junwoo_choi.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"안녕하세요. 토스에서 Gateway를 개발하고 있는 서버플랫폼팀 최준우입니다. \n\n토스에서는 목적에 맞는 다양한 Gateway를 사용하고 있는데요. 저는 이번 글에서 이러한 Gateway 아키텍처를 통해 토스가 누리고 있는 장점들과 이를 위해 어떠한 노력을 하고 있는지에 대해 간단히 소개하려고 합니다.\n\nGateway 란?\n우선 Gateway에 대해 간단히 알아보겠습니다. Gateway는 라우팅 및 프로토콜 변환을 담당하며 마이크로 서비스의 중개자 역할을 하는 서버입니다. 이를 통해 서비스는 클라이언트와 독립적으로 확장할 수 있으며 보안, 모니터링을 위한 단일 제어 지점을 제공합니다. Netflix Zuul을 통해 잘 알려졌으며 현재는 Saas나 플랫폼으로도 사용할 수 있게 대중화되었습니다.\n\n그림을 통해 예를 들어 보겠습니다. 서비스가 적고 트래픽이 적다면 클라이언트에서 서비스를 직접 호출하고 각각의 서비스에서 모든 로직을 처리해도 큰 부담이 되지는 않습니다. 그러나 스케일이 커지면 공통의 로직을 모든 서버에 적용하고 배포하는 것도 큰일이 됩니다.\n\n\n서버가 무수히 많아지는 MSA 특성상 공통 로직을 서버마다 두기에는 어려움이 있다\n이러한 필요성을 위해 개발된 게 Gateway 패턴입니다. Gateway는 서버들에서 필요한 공통 로직을 통합하여 처리합니다. 모든 서비스에서 필요한 유저 정보, 보안 정책 등을 Gateway에서 처리하고 이를 업스트림 서버로 넘겨줍니다.\n\n\nGateway 에서 요청을 1차로 받아서 공통 로직을 처리하고 서비스로 요청을 넘긴다\nGateway는 요청이 오면 정의된 설정에 따라 요청을 라우팅하고 사전에 설정된 필터들을 작동시킵니다. 설정은 Route 단위로 구성이 되며 Route는 다시 Predicate와 Filter로 구성됩니다. Predicate는 요청을 구분할 때 사용하는 값인데, Path, Method, Host 등으로 요청을 매칭하고 Filter는 매칭된 요청에 대한 전처리나 서비스의 응답에 대한 후처리를 구현합니다.\n\n\n저희는 이러한 Gateway 들을 Spring Cloud Gateway를 사용하여 구성하고 개발하고 있습니다. Spring Cloud Gateway는 스프링 Webflux를 통해 구현되어 있으며 내부적으로 Reactor-Netty를 사용하여 비동기 처리를 지원하고 있습니다. 또한 필터 개발에 Kotlin Coroutine을 적극 활용하고 있으며 Istio의 Ingress / Egress Gateway 및 Envoy 필터와 함께 유기적으로 개발하고 있습니다.\n\n공통 로직 처리\n이제 앞에서 소개 드렸던 공통 로직들을 저희가 어떻게 개발하고 사용하고 있는지에 대해 간단히 소개해 드리겠습니다.\n\nGateway에서 공통 로직을 처리하는 부분은 크게\n\nRequest에 대한 전처리, 후처리\n유저 정보를 이용한 로직 수행\n보안 그리고 서비스 안정화를 위한 설정\n등이 있는데, 몇 가지 사례와 그림을 토대로 설명드리도록 하겠습니다.\n\nSanitize\n우선 Request 처리입니다. Gateway에서 우선적으로 처리해 줘야 하는 것은 Request를 Sanitize 하는 것입니다. Sanitize는 Client로부터 올바르지 않은 요청이 올 경우 이를 지우거나 올바른 값으로 바꿔주는 것을 의미합니다. 그림처럼 사용자가 악의적으로 값을 주고 요청하더라도 Gateway에서 이를 올바른 값으로 바꿔서 서비스에 넘겨줍니다.\n\n\n유저 Passport\n토스 내부 서비스들도 기존에는 모든 서비스에서 유저 정보가 필요할 때 유저 API를 호출하는 방식으로 유저 정보를 가져오고 있었는데요 이는 트랜잭션 내에 불필요한 중복 요청을 유발하고 서버 리소스의 낭비로 이어졌습니다. 이를 개선하기 위해 저희는 Netflix의 Passport 구조를 참고하였습니다. \n\nNetflix는 유저 인증 시에 Passport 라는 id 토큰을 트랜잭션 내로 전파하는 방법을 사용하고 있는데요. 저희는 Netflix의 Passport 구조를 저희 팀에 맞게 변경하여 토스 Passport를 구현했습니다.\n\nPassport는 사용자 기기 정보와 유저 정보를 담은 하나의 토큰인데요. 앱에서 유저 식별키와 함께 API를 요청하게 되면 Gateway에서 이 키를 토대로 인증 서버에 Passport를 요청합니다. Passport에는 디바이스 정보와 유저 정보가 담겨 있으며 Gateway는 이를 serialize 하여 서비스에 전파합니다. 유저 정보가 필요한 서비스는 유저 정보 호출 없이 Passport 정보를 통하여 유저에 대한 정보를 사용할 수 있습니다.\n\n\n트랜잭션 내에서 마치 여권처럼 사용자 정보를 들고 다니게 됩니다.\n보안과 안정성\n토스는 금융 앱인 만큼 높은 수준의 보안 요구사항이 존재합니다. 저희는 Gateway에서 이러한 요구사항을 만족하기 위하여 다양한 보안 로직을 수행하고 있는데요. 아래에서는 Gateway가 핵심적으로 수행하고 있는 부분을 몇 가지 소개해 드리겠습니다.\n\n종단간 암호화\n토스 앱에서 사용하고 있는 대부분의 API는 종단간 암호화를 통해 패킷 분석의 허들을 높여 안전하게 정보를 전달하고 있습니다. 앱에서 암호화 키를 사용하여 요청 바디를 암호화하고 Gateway에서 이를 복호화 하여 서비스에 전달합니다. 복호화 과정에서 인증 / 인가 로직이 처리되고 복호화 된 데이터와 유저 정보를 서비스로 넘겨주게 됩니다. Gateway에서 이 과정을 전부 처리하기 때문에 서비스에서는 편하고 안전하게 사용자의 요청을 처리할 수 있게 됩니다.\n\n\nDynamic Security\n토스는 위에서 말한 인증 / 인가를 넘어서 각 요청이 실제로 위변조 되지 않은 토스 앱에서 만들어진 요청인 지도 검증을 합니다. 토스 앱은 내부적으로 매 요청을 서명할 아주 짧은 유효기간을 가진 안전한 키 값과 변조되지 않은 토스 앱에서만 알 수 있는 정보를 활용하여 각 요청을 서명하고 이를 Gateway로 보내게 됩니다.\n\nGateway에서는 각 요청에 들어있는 서명 값을 통해서 토스 앱에서 만들어진 요청인지, 중복해서 사용되지 않았는지, 그리고 유효기간이 만료된 키로 만들어지진 않았는지 검증하여 앱 위변조, delayed request, replaying attack을 방지하고 의심스러운 요청이 발견되면 FDS(fraud detection system)를 통해 계정을 비활성화하여 사용자를 안전하게 보호하고 있습니다.\n\n\n인증서를 이용한 인증 / 인가\nGateway에서는 토스 앱 뿐만 아니라 외부 회사나 내부 개발자의 서비스 호출을 위해 클라이언트 인증서를 이용한 mTLS API 호출도 지원하고 있습니다. 기본적으로 Istio에서 제공하는 mTLS flow 위에 Gateway 애플리케이션을 두어 인증 / 인가 처리를 하고 있습니다. Istio 만 이용하여 인증/인가를 처리할 수도 있지만 코드 베이스의 애플리케이션이 Istio의 matching rule보다 자유도도 높고, Auditing 등의 로직을 처리할 수 있으며 카나리 배포의 이점을 누릴 수 있기 때문에 Gateway에서 인증 / 인가 처리를 담당하게 되었습니다.\n\n\nEdge에서 Istio는 Client 인증서의 CA 유효성을 확인한 후, 해당 인증서 정보를 헤더에 실어서 모든 트래픽을 Gateway에 전달해 줍니다. 이렇게 받은 인증서를 Decode 하여 X.509 extensions 중 Subject Alternative Name을 활용하여 인증서로부터 사용자 정보를 얻게 됩니다. 이렇게 얻은 사용자 정보와 도착지 호스트 및 요청 경로를 활용하여 각 요청에 대한 인증 / 인가 및 Auditing 처리를 하고 있습니다.\n\n\nCircuit breaker\n사용하는 마이크로 서비스 아키텍처 패턴은 많은 서비스들이 거미줄처럼 서로 상호작용을 하고 있습니다. 따라서 그중 하나의 서비스에서 응답 지연이 발생하면, 해당 서비스에 의존하는 수많은 서비스들에게 응답 지연이 전파됩니다. 이렇게 퍼져 나간 응답 지연이 시스템의 자원을 점유하여 모든 시스템이 먹통이 되는 상황이 발생합니다. 이를 방지하기 위해서는 응답 지연을 유발하는 서비스에게 요청을 더 이상 보내지 않고 빠르게 실패하게 하여 부하를 겪고 있는 서비스가 회복할 수 있게 돕고, 이러한 응답 지연이 전체 서비스로 확산되지 않게 하는 것이 중요합니다. 이를 서킷 브레이크 라고 부릅니다.\n\n\n또한 내부 서비스 간의 서킷 브레이킹도 중요하지만 근원적인 트래픽을 발생시키는 Client에게 백프레셔를 빠르게 주기 위해서는 Gateway에서 서킷 브레이킹을 거는 것이 중요합니다. 서킷 브레이크를 적용하는 방법에는 Istio를 활용한 인프라 레이어의 서킷 브레이킹 혹은 Resilience4J나 Hystrix와 같은 라이브러리를 이용한 애플리케이션 레이어의 서킷 브레이킹이 있습니다. \n\n각 방법에는 장단점이 존재하는데요, Istio를 활용한다면 호스트 단위로 쉽고 빠르게 전체 적용이 가능하며 애플리케이션의 개발 주기와 독립적으로 관리될 수 있다는 장점이 있지만 Istio는 호스트 단위로만 서킷 브레이킹 설정이 가능하며, 설정할 수 있는 룰에도 한계가 있습니다.\n\n따라서 토스에서는 보이는 것 같이 각 애플리케이션이나 Gateway에 서킷 브레이킹을 적용함으로써 호스트나 Route 단위 혹은 기능단위로 정교하게 서킷 브레이킹을 걸고 있습니다.\n\n모니터링\nGateway는 토스의 모든 서비스가 거치는 컴포넌트인 만큼 보다 꼼꼼한 모니터링이 필요합니다. 모니터링에 중요한 요소로는 로깅, 메트릭, 트레이싱이 있는데요, 저희 팀에서 각각 어떻게 기록하고 모니터링하는지 소개하겠습니다.\n\n로깅\n저희는 Gateway를 지나는 모든 요청, 응답의 Route id와 method, URI, 상태 코드 등을 Elasticsearch에 남기고 있습니다.\n\n덕분에 요청이 어떤 Route로 들어왔는지, 업스트림으로 어떤 URI를 호출했는지에 대한 정보를 바로 확인할 수 있습니다.\n\n\n메트릭\n다음은 메트릭입니다. 메트릭에는 크게 시스템에서 수집하는 메트릭과 애플리케이션에서 수집하는 메트릭이 있습니다. 두 메트릭 모두 Prometheus가 수집하는데요, Node Exporter를 통해 수집된 시스템 메트릭과 Spring의 actuator를 통해 수집된 애플리케이션 메트릭을 Grafana를 이용해 시각화하고 슬랙으로 알림을 보내고 있습니다.\n\n\n시스템 메트릭에는 CPU, memory, 네트워크 RX, TX 트래픽 등이 포함되어 애플리케이션 수정 사항이 시스템에 주는 영향을 1차로 파악할 수 있고, 문제가 생기는 경우 현상과 원인 파악에 활용할 수 있습니다.\n\n\n애플리케이션 메트릭에서는 JVM thread block 상황이나 세대별 메모리 할당을 파악하고 full GC 발생 여부 등을 확인하고 있습니다.\n\n\nSpring Cloud Gateway에서는 Route 별 메트릭도 제공하는데요, 저희는 여기에 Path 값을 더해 API Path 별 Route 메트릭을 확인하기도 합니다.\n\n마무리\n토스팀에서 Gateway를 사용하여 해결하고 있는 몇 가지 사례에 대해 소개해 드렸습니다. 사례들처럼, Gateway는 외부에 노출되는 엔드포인트에 대해 중앙 집중식으로 관리할 수 있도록 도와줍니다. 이를 통해 트래픽을 모니터링하고 속도를 제한하거나 요청 및 응답을 요구사항에 맞게 수정하는 등 거대한 마이크로 서비스 아키텍처 클러스터를 보다 쉽게 확장, 관리 및 모니터링 할 수 있도록 합니다.\n\n위 글을 통해 Gateway 사용에 많은 인사이트를 얻으셨길 바라면서 소개 드린 사례들 외에도 더 많은 사례들을 보고 싶으시다면 SLASH23 영상도 같이 보시는 것도 좋을 것 같습니다.\n\n감사합니다!","isDisplayingFeedback":true},{"id":22896,"updatedTime":"2023-10-12T16:05:36+09:00","createdTime":"2023-10-11T18:25:48+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"대규모 로그 처리도 OK! Elasticsearch 클러스터 개선기","subtitle":"일평균 56억 건 이상 수집되는 토스증권의 로그, 어떻게 효율적으로 처리할까요?\n큰 폭으로 늘어나는 대규모 로그 처리를 위한 ‘Elasticsearch 클러스터 개선 경험’을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_04_%EC%9D%B4%EC%A4%80%ED%99%98.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_04_%EC%9D%B4%EC%A4%80%ED%99%98.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-data","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-10-12T16:03:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22896,"title":null,"description":"일평균 56억 건 이상 수집되는 토스증권의 로그, 어떻게 효율적으로 처리할까요?\n큰 폭으로 늘어나는 대규모 로그 처리를 위한 ‘Elasticsearch 클러스터 개선 경험’을 소개합니다.","urlSlug":"slash23-data","primaryKeyword":{"id":11972,"content":"SLASH23","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":3847,"content":"토스 개발자","wordType":"SEO_KEYWORD"},{"id":3934,"content":"토스 개발 컨퍼런스","wordType":"SEO_KEYWORD"},{"id":4116,"content":"데이터","wordType":"SEO_KEYWORD"},{"id":13448,"content":"Elasticsearch","wordType":"SEO_KEYWORD"},{"id":13450,"content":"온프레미스","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"대규모 로그 처리도 OK! Elasticsearch 클러스터 개선기","description":"일평균 56억 건 이상 수집되는 토스증권의 로그, 어떻게 효율적으로 처리할까요?\n큰 폭으로 늘어나는 대규모 로그 처리를 위한 ‘Elasticsearch 클러스터 개선 경험’을 소개합니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_og_04_이준환.png","imageType":"직접입력"},"relatedPostConfig":{"id":3310,"relatedPosts":[{"id":22565,"updatedTime":"2023-10-11T16:38:50+09:00","createdTime":"2023-09-01T12:10:36+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"금융사 최초의 Zero Trust 아키텍처 도입기","subtitle":"왜 보안이 강화될수록, 업무는 불편해지는 걸까요? \n금융에서 가장 중요한 가치인 ‘안전’과 혁신을 위한 ‘업무 편의성’, 두 마리 토끼를 모두 잡기 위한 여정을 소개합니다.  ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-security","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-09-01T11:59:00+09:00","commentBoard":null,"disclaimer":null},{"id":22563,"updatedTime":"2023-10-11T17:04:28+09:00","createdTime":"2023-08-31T23:16:00+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"은행 최초 코어뱅킹 MSA 전환기 (feat. 지금 이자 받기)","subtitle":"수십 년간 정체되어 있던 전통적인 은행 시스템의 모놀리식 소프트웨어 아키텍처를 MSA로 전환할 수 있을까요? \n토스뱅크의 ‘코어뱅킹 MSA 전환’ 사례를 통해 향후 은행 시스템이 나아가야 할 방향을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_02.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_02.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-corebanking","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-31T23:37:00+09:00","commentBoard":null,"disclaimer":null},{"id":22478,"updatedTime":"2023-10-11T17:03:23+09:00","createdTime":"2023-08-22T17:10:44+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"레고처럼 조립하는 토스 앱","subtitle":"수많은 서비스를 담고 있는 대규모 iOS 앱에 어울리는 아키텍처는 무엇일까요?\n프로젝트 간의 의존성과 모듈 간의 결합도를 낮춰, 더 효율적인 서비스 개발, 관리를 이뤄낸 과정을 소개합니다. ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-iOS","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-22T17:46:00+09:00","commentBoard":null,"disclaimer":null}],"title":"함께 읽어보면 좋을 콘텐츠"},"editor":{"id":1187,"name":"이준환","slug":"junhwan-lee","shortDescription":"Data Engineer","description":"-","imageUrl":"https://static.toss.im/career-resource/junhwan_lee.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"로그 수집 현황\n토스증권이 운영하는 서비스와 인프라에서는 매일 수많은 로그들이 생성되고 있고, 이를 Elasticsearch 클러스터로 수집하여 로그를 검색하고 분석하고 있습니다. 이러한 로그들은 약 100여 개의 로그 파이프라인을 통해 하루 기준으로 22테라 바이트, 약 170억 건의 로그를 인덱싱하고 있는데요, 서비스가 커질수록 수집되는 로그는 더욱 늘어나기 때문에 수평적으로 확장하고 안정적으로 운영하기 위해 지속적으로 클러스터의 개선이 필요합니다.\n\n실제로 SLASH23 발표를 준비하던 시기에는 피크 시간에 초당 60만의 인덱싱과 하루 56억 건 정도의 로그를 처리하였지만 수 개월이 지난 지금은 로그가 3배 이상 늘어나서 피크 시간에 초당 200만 이상의 인덱싱, 하루 기준으로 약 170억 건의 로그를 처리하고 있습니다.\n\n\n\n토스증권 Elasticsearch 클러스터는 온프레미스로 운영하고 있어 클러스터가 커질수록 상면 공간과 관리 부담이 있기 때문에 가능한 효율적으로 구성을 하는 것이 필요한데요, 거의 대부분의 로그 검색과 분석은 최근 보름 이내의 로그를 대상으로 하기에 Hot-warm 아키텍처를 도입하면 보다 효율적으로 운영할 수 있다고 판단하였고 Hot 노드보다 더 큰 디스크를 가진 Warm 노드를 구성한 후 생성된 지 오래된 인덱스는 Warm 노드로 이동하고, 일정 기간이 지나면 삭제하도록 하는 ILM (Index Lifecycle Management)을 구성하였습니다.\n\n이러한 구조를 채택하여 만약 최근 로그를 더 오래 보관하고 싶다면 Hot 노드 증설을 하고, 전체 로그를 더 오래 보관하고 싶다면 Warm 노드만 증설하는 등 목적에 따라 확장할 수 있도록 구성하였습니다.\n\n\nElasticsearch 클러스터 안정화\n그런데 이처럼 수백 테라바이트 단위로 로그 수집 규모가 매우 커지면서 Elasticsearch 클러스터의 장애가 종종 발생하였는데요, 클러스터가 매우 느려져서 로그 인덱싱이 크게 지연되기도 하고 키바나에서 로그 검색을 할 때에도 검색 지연이 크게 발생했고 때로 데이터 노드가 내려가는 장애가 있었습니다.\n\n클러스터가 크게 느려졌을 때 노드들의 상태는 공통적인 패턴을 보였는데요, 매우 많은 fielddata 메모리를 사용하고 있었고 매우 긴 가비지 컬렉션이 빈번하게 발생하여 가비지 컬렉션이 끝날 때까지 클러스터가 일시적으로 멈추는 패턴이었습니다.\n\n\n매우 많은 fielddata 메모리 사용\n잘못 사용한 fielddata 옵션\n저희가 장애를 겪은 경우는 인덱스 매핑에서 일부 필드 설정에 fielddata 옵션을 잘못 사용한 경우였습니다.\n\n\nElasticsearch 및 Lucene에 Doc value 스토리지가 도입되기 전에는 필드에 대해 aggregation과 정렬을 하기 위해서 필드의 값들을 fielddata라는 메모리 영역으로 올려서 fielddata에서 aggregation을 수행하고 정렬을 하였었는데요, 매우 큰 인덱스의 필드들을 메모리로 올려서 사용하다 보니 Elasticsearch의 JVM 메모리가 항상 부족해지고 매우 긴 가비지 컬렉션이 발생하여 이로 인해 클러스터가 일시적으로 멈추는 현상이 빈번했습니다. 그래서 Elasticsearch는 파일 시스템을 사용하고 컬럼 기반인 Doc value storage를 도입하여 aggregation과 정렬을 수행할 때 힙 메모리를 덜 사용하고 운영체제 레벨 캐시를 적극적으로 사용하는 방향으로 발전되어왔습니다.\n\n따라서 Doc value 스토리지를 지원하는 지금은 특별한 경우가 아니면 fielddata를 사용할 일이 없습니다. 인덱스의 크기가 작다면 문제가 되지 않겠지만 인덱스의 크기가 커지면 이는 금방 장애로 이어질 수 있습니다. 저희의 장애 당시 설정에서는 단지 7개의 필드에서 fielddata 옵션이 설정되어 있었는데 유입되는 로그의 양이 매우 많다 보니 이로 인해 데이터 노드의 힙 메모리가 금방 가득 차게 되고 가비지 컬렉션이 빈번하게 발생하였습니다. \n\nDoc value 스토리지를 지원하지 않는 text 타입을 aggregation 하려는 목적에서 fielddata를 사용할 수는 있지만 가급적 사용하지 말고 다른 방법으로 문제를 푸는 것이 좋습니다.\n\n인덱스 매핑\n또 하나의 Elasticsearch 클러스터의 안정성을 위협하는 것은 mapping explosion입니다. \n\n유입되는 로그가 많아지고 규모가 커질수록 인덱스 매핑이 정말 중요해지는데요, Elasticsearch 클러스터가 느려지고 불안정한 경우 원인 분석을 하면 대부분 인덱스 매핑이 비효율적으로 정의되어 있는 경우가 많습니다.\n\n만약 관리하는 Elasticsearch 클러스터가 느려지고 불안정하다면 맨 먼저 인덱스 매핑을 살펴보는 것이 좋은데요, 인덱스에 너무 많은 필드들이 매핑되어 있는지와 fielddata 옵션을 사용하는 필드가 있는지, default dynamic mapping을 사용하고 있는지 점검해 보면 좋습니다.\n\nElasticsearch는 명시적인 설정을 하지 않는다면 들어온 json의 형태 그대로 인덱싱을 하고 동적으로 인덱스 매핑을 업데이트하는데요,\n\n이런 특성으로 인해 입력으로 들어오는 json에 key가 매우 많다면 mapping explosion이 일어나고 마스터 노드가 클러스터 상태를 업데이트하고 관리하는 데 리소스를 매우 많이 사용하여 클러스터가 불안정하게 됩니다. 따라서 인덱싱할 데이터가 너무 많은 키를 가지지 않도록 해야 하지만 어쩔 수 없이 임의의 구조를 가진 데이터를 인덱싱해야 한다면 flattened type를 사용하거나 dynamic field를 false로 하는 것이 필요합니다. dynamic field 옵션을 false로 설정하면 명시적으로 매핑한 필드만 인덱싱되고 그 이외의 필드는 인덱싱되지 않기 때문입니다.\n\n\n\n명시적인 매핑, flattened type, dynamic field를 끄는 것들은 결국 인덱스에 의도하지 않게 너무 많은 필드가 생성되지 않도록 하는 것이 목적입니다. 안정적인 Elasticsearch 클러스터를 운영하기 위해서 가장 중요한 점은 인덱스 필드를 제어할 수 있어야 합니다.\n\n\n적절한 샤드 개수\n그 외의 인덱스 설정에서 고려해야 하는 것은 인덱스의 샤드 개수입니다. 샤드 수를 결정하는 데에 정답은 없지만 토스증권에서는 헤비 인덱스의 경우 프라이머리 샤드의 개수는 Hot 노드의 수와 동일하게 하고 있습니다. \n\n데이터 노드의 CPU 사용량이 여유가 있다면 프라이머리 샤드 개수를 더 늘려서 초당 인덱싱 처리량을 개선할 수 있어요. 다만 프라이머리 샤드를 더 늘린다면 샤드가 특정 노드에 쏠려서 핫스팟 노드가 될 수 있기 때문에 샤드의 수를 Hot 노드의 배수로 설정하는 것이 좋습니다.\n\nindex refresh time은 60초로 설정해서 세그먼트 생성과 머지가 적게 발생하도록 하였고, flush_threshold_size는 기본값인 512MB의 두 배인 1GB로 설정하여 트랜스로그 플러시를 실행하는 빈도를 낮추도록 하였습니다. \n\n마지막으로 슬로우 쿼리 로깅을 활성화하여 클러스터에 부하를 줄 수 있는 비용이 비싼 쿼리가 실행되는 것을 모니터링하고 있습니다.\n\n\nVector 로그 파이프라인 전환\n그 이후에 진행한 것은 로그 파이프라인 전환이었습니다. \n\nElasticsearch로 로그를 인덱싱하는 로그 파이프라인은 현재까지 약 100여 개를 운영하고 있습니다. 로그 파이프라인은 Logstash를 사용하여 운영하였는데 Logstash는 범용적으로 사용할 수 있게 다양한 설정을 제공하지만 JVM 기반으로 만들어져있어 시스템 자원을 많이 사용하는 단점을 가지고 있습니다.\n\nLogstash 기반 파이프라인이 점점 늘어나서 쿠버네티스 클러스터에서 260GB 이상의 메모리를 사용하는 상황이 발생하였고 앞으로 로그 파이프라인은 더욱 늘어날 예정이기 때문에 Logstash를 대체할 수 있는 경량 로그 파이프라인으로 전환이 필요하였습니다.\n\n로그 파이프라인 전환을 위하여 여러 경량 로그 파이프라인 오픈 소스들을 검토하였고 그중 로그 가공과 정제를 코드로 유연하게 작성할 수 있는 vector를 선택하였습니다.\n\n\nVector는 Datadog에서 공개한 Rust 기반 경량 log shipper이고 고성능과 메모리 효율을 목표로 하여 높은 워크 로드 환경에서 리소스 효율적으로 로그 파이프라인을 운영할 수 있습니다. 또한 다양한 source들과 sink들을 제공하고 있어서 목적에 맞게 로그 파이프라인을 구성하고 확장할 수 있는 장점이 있습니다.\n\n그리고 Logstash에서 아쉬웠던 부분이 로그 파이프라인 모니터링이었는데 Vector로 전환한 후 prometheus exporter로 로그 파이프라인 모니터링을 쉽게 구현할 수 있었고, 로그 파이프라인 모니터링을 통해 파이프라인에 문제가 생겼을 때 이를 빨리 파악하고 개선이 필요한 부분을 쉽게 알 수 있게 되었습니다.\n\n\nVector로 로그 파이프라인을 전환한 후 시스템 자원을 많이 절약할 수 있었는데요, Logstash는 범용적으로 사용하기 좋은 장점이 있지만 JVM 기반으로 되어 있어 시스템 리소스를 제법 많이 사용하는 문제가 있었고 운영의 편의성을 위해 로그 파이프라인들을 각각 별도의 프로세스로 띄우고 있었기 때문에 Logstash 인스턴스가 많아지면 메모리 사용량이 많을 수밖에 없었는데 이 부분을 해소할 수 있었습니다. 기존에 약 260GB 정도 사용하고 있던 메모리 사용량이 10GB 수준으로 크게 줄었습니다. 약 96% 이상 메모리를 절약하는 성과가 있었습니다.\n\n\nVector 전환 이후 시간이 흘러 로그 파이프라인이 더 늘어나고 유입되는 로그도 3배 이상 증가한 현재는 Vector 파이프라인들의 메모리 사용량은 약 23GB 정도로 측정되었습니다. 기존 Logstash 기반의 로그 파이프라인을 그대로 유지하고 있었다면 쿠버네티스 클러스터에서 수백 GB의 메모리를 사용하게 되었을 상황을 예방할 수 있었습니다.\n\n여러 데이터센터 간 클러스터링\n로그 파이프라인을 vector로 전환한 후 다음으로 진행한 것은 데이터센터 확장이었습니다. 데이터센터 이중화를 위하여 새로운 데이터 센터가 추가되어 새로운 데이터 센터에서 생성되는 로그를 수집하는 Elasticsearch 클러스터가 필요해졌는데요, 이렇게 커진 Elasticsearch 클러스터를 한 세트 더 구축하고 운영할 수도 있지만 더 나은 방법이 없을까 고민을 하였고 데이터센터 간에 하나의 Elasticsearch 클러스터를 구축할 수 있을지 검토하였습니다.\n\n\n사실 서로 다른 데이터센터의 Elasticsearch 노드들을 하나의 클러스터로 묶는 방법은 elastic에서는 권장하지 않는 방법입니다. 이는 노드들이 빈번하게 통신하는데 데이터센터 간의 네트워크 레이턴시가 높으면 클러스터의 전체적인 성능 저하가 발생하기 때문입니다.\n\n\n하지만 데이터센터 간의 거리가 짧고 네트워크 레이턴시가 작다면 리전 내의 가용성 존(AZ, Availability Zones)로 볼 수 있지 않을까 생각했습니다. AWS가 서울 리전에서 4개의 Zone으로 구성되어 있는 것처럼요. 그리고 수백 테라바이트의 로그 수집과 분석이 목적이기 때문에 조금의 지연보다 비용 절감으로 얻을 수 있는 장점이 더 크다고 생각했습니다.\n\n대신 Elasticsearch가 샤드를 복제하거나 복구할 때 많은 네트워크 트래픽을 점유하기 때문에 클러스터 안정성을 위해서 Elasticsearch 클러스터를 위한 전용 회선을 별도로 구축하였고 하나의 IDC가 장애가 났을 경우를 대비하여 replica shard는 서로 다른 IDC에 저장하도록 구성하였습니다.\n\nIDC 간에 하나의 Elasticsearch 클러스터를 구축하기 위해서는 투표 전용 마스터 노드가 필요합니다. 각각의 IDC에는 마스터 노드 1개를 배치하고, AWS에 투표 전용 마스터 노드를 배치하여 총 3대의 마스터 노드를 배치하는 구조입니다. 마스터 선출을 위한 투표만 수행하는 노드를 제3의 장소인 AWS에 배치하여 IDC1의 마스터 노드와 IDC2의 마스터 노드를 타이브레이커로 묶게 됩니다. 이를 통해 DCI 단절 시 발생할 수 있는 split brain 문제를 방지할 수 있습니다.\n\n\n또한 하나의 데이터센터가 장애가 발생하였을 때 데이터 유실을 방지하기 위하여 Shard awareness를 설정하여 primary shard와 replica shard가 서로 다른 IDC에 배치되도록 하였습니다. 그리고 일시적인 DCI(Data Center Interconnect) 장애 시 샤드 복제가 과도하게 일어나는 것을 방지하기 위해 force awareness를 설정하여 IDC1과, IDC2의 데이터 노드들이 클러스터에 합류하였을 때만 샤드 배치가 일어나도록 설정하였습니다. 마지막으로 전송 계층에서 인덱싱 데이터에 대해 압축 설정을 하면 전송 시 발생하는 네트워크 대역폭을 많이 줄일 수 있습니다.\n\n\n\n\n\n다음은 IDC1과 IDC2의 Elasticsearch 노드들을 하나의 클러스터로 묶은 전체 아키텍처 그림입니다. \n\nDCI 간 네트워크 단절이 발생한다면 IDC1 혹은 IDC2의 마스터 노드가 투표 전용 마스터 노드의 투표를 통해 마스터 노드로 선출되고 같은 구역에 있는 노드들만 클러스터에 남게 됩니다.\n\n\n이후 DCI 장애가 해소되면 반대편 IDC에 있는 노드들이 다시 클러스터에 합류하게 됩니다. 이런 구조를 통해 하나의 데이터센터 장애에도 견딜 수 있는 Elasticsearch 클러스터를 운영할 수 있게 되었습니다.","isDisplayingFeedback":true},{"id":22885,"updatedTime":"2023-10-11T12:08:04+09:00","createdTime":"2023-10-11T11:15:45+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"프론트엔드 다이빙클럽에서 만나는 아고라: 다른 회사에선 테스트 코드 어떻게 짜요?","subtitle":"‘프론트엔드 테스팅’을 주제로 진행된 프론트엔드 다이빙 클럽의 네번째 모임을 공유합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/ml-illust/img-people-check-outfut.jpg","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/ml-illust/img-people-check-outfut.jpg","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"frontend-diving-club-agora","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-10-11T11:39:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22885,"title":null,"description":"‘프론트엔드 테스팅’을 주제로 진행된 프론트엔드 다이빙 클럽의 네번째 모임을 공유합니다.","urlSlug":"frontend-diving-club-agora","primaryKeyword":{"id":11756,"content":"토스프론트엔드","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":3882,"content":"프론트엔드","wordType":"SEO_KEYWORD"},{"id":3928,"content":"개발자 컨퍼런스","wordType":"SEO_KEYWORD"},{"id":12165,"content":"프론트엔드개발자","wordType":"SEO_KEYWORD"},{"id":13392,"content":"프론트엔드 테스팅","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"프론트엔드 다이빙클럽에서 만나는 아고라: 다른 회사에선 테스트 코드 어떻게 짜요?","description":"‘프론트엔드 테스팅’을 주제로 진행된 프론트엔드 다이빙 클럽의 네번째 모임을 공유합니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/ml-illust/img-people-check-outfut.jpg","imageType":"썸네일 이미지"},"relatedPostConfig":{"id":3300,"relatedPosts":[{"id":22217,"updatedTime":"2023-08-22T19:07:30+09:00","createdTime":"2023-07-19T22:56:27+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"놀러오세요! 프론트엔드 다이빙 클럽","subtitle":"프론트엔드에 관한 깊은 이야기를 나눌 수 있는 오프라인 커뮤니티, 프론트엔드 다이빙 클럽을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/frontend-diving-club.jpg","videoUrl":null,"backgroundColor":null,"isFill":true,"imageAlt":"대화하는 사람들 일러스트레이션"},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/frontend-diving-club.jpg","backgroundColor":null,"isFill":true,"imageAlt":"대화하는 사람들 일러스트레이션"},"key":"frontend-diving-club","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-07-21T13:47:00+09:00","commentBoard":null,"disclaimer":null}],"title":"함께 읽어보면 좋을 콘텐츠"},"editor":{"id":1184,"name":"서현석","slug":"hyunseok-seo","shortDescription":"Frontend Developer","description":"-","imageUrl":"https://static.toss.im/career-resource/image%20(48).png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"안녕하세요. 토스증권 프론트엔드 개발자 서현석입니다.\n\n여러분은 ‘아고라(agora)’라는 단어를 들으면 어떤 뜻이 가장 먼저 떠오르시나요? 어원으로 거슬러 올라가면 그리스 도시국가(폴리스)에서 시민들이 자유롭게 토론을 벌이던 장소이자 고대 그리스어로는 ἀγορά, 즉 열린 공간, 광장을 뜻합니다. 아고라에서는 그리스의 정치, 경제, 사회 같은 주요 분야들에 대한 의제를 논의하고 결정할 뿐만 아니라, 사회적·문화적인 만남의 장소가 되어 인문학, 철학 그리고 예술에 대한 토론이 이루어졌다고 하죠.\n\n저는 프론트엔드 다이빙 클럽(이하 ‘프다클’)이 프론트엔드 커뮤니티의 아고라가 되어가길 기대합니다. 우리는 많은 개발 커뮤니티들을 접할 수 있지만, 일반적인 컨퍼런스나 세미나는 발표자가 중심이 되는 단방향의 정보 전달이 주를 이룹니다. 프다클에서도 발표자와 주제는 있지만, 참석자 분들 한 분 한 분이 작은 발표자가 되어 아고라의 자유 시민처럼 토론하기를 기대합니다.\n\n혹시 프론트엔드 다이빙 클럽에 대해 잘 모르신다면, 이 글을 확인해 주세요.\n\n\n프다클의 컨시어지가 되어 보았습니다.\n첫 모임 때에 비해 이번 회차에는 60명 정도의 참여자로 가장 많은 분들이 함께해 주셔서 인기를 실감할 수 있었습니다. 특히 이번 모집 신청은 약 30초 만에 빠르게 매진되기도 했는데요. 공개적으로 홍보하지 않고, 지인 기반 입소문으로 퍼져나가며 성장하는 커뮤니티다 보니 더 의미 있었던 것 같습니다.\n\n이번이 4번째를 맞이하게 된 프다클에서는 ‘프론트엔드 테스팅’을 주제로 진행되었습니다.\n\n지원해주신 발표자 분들 덕분에 준비된 2개의 세션은 아래와 같습니다.\n\n접근성이 주도하는 프론트엔드 자동화\n오늘도 테스트를 쓰기로 마음 먹는다. 그러나,\n어떤가요? 제목만 봐도 흥미 넘치는 주제일 것 같지 않나요? 저 같은 경우에도 평소에 테스트 코드 작성에 대한 기준이 모호하다 보니 같은 프론트엔드 챕터 내에서도, 어느 정도까지의 테스트 코드를 짜야 하는 지에 대한 토론을 한 경험이 있었습니다.\n\n접근성 주도의 테스팅을 짜는 방법은 발표자 분의 노하우 전수이기도 하면서, 직접 만든 라이브러리를 소개해주셔서 새로웠습니다. “프론트엔드에서 테스트 짠다고 하면 나를 비건처럼 바라본다”고 하셨던 말이 공감이 가서 웃음까지 놓치지 않았던 세션이었습니다.\n\n두번째 세션은 주입을 이용한 테스팅으로 의존성과 테스팅의 관계에 대해 생각할 수 있었습니다. 더 생산성 있는 테스트 코드 작성 방법의 대한 발표자 분의 고찰 기반으로 다양한 이야기의 섬토크가 오고 갔던 게 인상 깊었습니다.\n\n*섬토크란? 각 세션마다 해당 주제로 프다클에서 짜여진 각 조별로 토론할 수 있는 시간\n\n\n\n아무래도 프다클이 열리는 모임 시간이 출출한 저녁 시간이다 보니, 발표에 집중하지 못하지 않을까 걱정하는 저 같은 사람들이 있을 텐데요. 프다클에 참여하시면 양질의 핑거푸드가 마련되어있어 세션 시작 전과 종료 후 네트워킹 시간에 자유롭게 드실 수 있게 제공하고 있습니다.\n\n발표자에게만 마이크가 가는 것이 아니라 많은 분들이 서로 얼굴을 익히고 토론하는 시간이 있기 때문에, 기운 넘치게 이야기에 집중할 수 있었습니다. 많은 분들이 참여해주시는 만큼 취향에 따라 여러 종류로 드실 수 있게 비건 메뉴까지 준비해 두었으니 메뉴를 걱정하실 필요는 없습니다.\n\n\n올해 벌써 4번째를 맞이한 프다클이지만, 남은 기간 동안에도 많은 분들이 함께 할 수 있도록 준비하고 있습니다.\n\n처음과 지금을 비교해보면, 참여해주시는 분들의 피드백을 통해 매 회차 마다 성장해 가는 게 눈에 띄게 볼 수 있었는데요. 조금씩 삐걱거리던 부분들도 개선되고, 좋은 것들은 더 좋게 만들고자 하는 시도들이 있었습니다. 특별히 참여하신 분들에 한해 제공해 드리는 유니크한 굿즈들도 빼놓을 수 없을 것 같습니다. 매 회차 마다 조금씩 구성이 달라지기는 하지만 개인적으로 저는 커피사일로의 원두팩을 가장 좋아합니다.\n\n이외에도 매 회차 마다 제공되는 배지와 발표자에게 제공되는 스페셜 굿즈까지 준비되어 있으니 풍성한 프다클 커뮤니티가 될 수 밖에 없지 않을까요 ?\n\n만약 이 글을 읽고 관심이 생기셨다면 프다클에 함께 해주세요!\n\n\n프다클의 마스코트 수달이\n프다클 커뮤니티는 초대 기반으로 발전해오고 있습니다. 매 모임마다 슬랙에 가입된 기존 멤버 대상으로 티켓을 제공합니다. 기존에는 20장씩 제공해(선착순 10명, 추첨 10명), 이 분들이 지인을 동행하여 총 40명의 사람들이 모였지만, 더 많은 분들이 함께하실 수 있도록 30장으로 늘릴 계획도 가지고 있습니다.\n\n발표자 신청도 프다클에 참여할 수 있는 또 다른 방법입니다. 발표자 신청 폼은 토스 프론트엔드 트위터에 올라갈 예정이니, 참여 원하시는 분들은 구독해주세요.\n\n처음엔 초대 기반 커뮤니티가 잘 동작할지에 대한 확신이 없었지만, 거의 오픈과 동시에 마감되는 선착순 티켓팅을 보며 특정 주제에 대해 딥한 기술 네트워킹을 하고자 하는 분들이 정말 많이 계시다는 사실을 깨달을 수 있었습니다.\n\n프다클 합류를 희망하신다면, 구글폼을 통해 간단한 경력 정보와 함께 자기소개를 남겨주세요.\n남겨주신 정보를 토대로, 매 회차 모임의 방향성에 따라 함께할 분을 선별하여 초대권을 보내드릴게요.\n\n올 해의 마지막 프다클은 12월 중에 열릴 예정입니다. 많은 기대 부탁드려요!","isDisplayingFeedback":true},{"id":22443,"updatedTime":"2023-09-05T10:23:03+09:00","createdTime":"2023-08-18T01:05:58+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"환경 고민없이 개발하기","subtitle":"서버 사이드 렌더링 작동 방식과 Isomorphic에 대해 소개드려요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/illusts-common/230823_techblog_thumb_nail.png","videoUrl":null,"backgroundColor":null,"isFill":true,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/illusts-content/img-how-to-read.jpg","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"isomorphic-javascript","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-09-01T12:10:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22443,"title":null,"description":"토스 프론트엔드 챕터는 유저가 경험하는 로딩 시간을 줄이기 위해 지속적으로 노력하고 있습니다. 특히 Slash 22를 통해 서버 사이드 렌더링(SSR)를 이용한 개선 사례를 소개드린 적이 있는데요. 이번 아티클에서는 Next.js 도입 과정에서 마주한 문제와 해결 방법에 대해 설명드리겠...","urlSlug":"isomorphic-javascript","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"환경 고민없이 개발하기","description":"토스 프론트엔드 챕터는 유저가 경험하는 로딩 시간을 줄이기 위해 지속적으로 노력하고 있습니다. 특히 Slash 22를 통해 서버 사이드 렌더링(SSR)를 이용한 개선 사례를 소개드린 적이 있는데요. 이번 아티클에서는 Next.js 도입 과정에서 마주한 문제와 해결 방법에 대해 설명드리겠...","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/illusts-common/isomorphic-tech-blog-thumb-nail.png","imageType":"직접입력"},"relatedPostConfig":null,"editor":{"id":1023,"name":"김동현","slug":"donghyeon-kim","shortDescription":"Frontend Developer","description":"토스 프론트엔드 개발자","imageUrl":"https://static.toss.im/assets/toss-tech/donghyeon.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"서론\n토스 프론트엔드 챕서론\n토스 프론트엔드 챕터는 유저가 경험하는 로딩 시간을 줄이기 위해 지속적으로 노력하고 있습니다. 특히 Slash 22를 통해 서버 사이드 렌더링(SSR)를 이용한 개선 사례를 소개드린 적이 있는데요. 이번 아티클에서는 Next.js 도입 과정에서 마주한 문제와 해결 방법에 대해 설명드리겠습니다.\n\n서버 사이드 렌더링 \n서버 사이드 렌더링(SSR)은 렌더링 작업 일부를 서버에 위임하는 방식으로, 브라우저에게 완성된 HTML을 전달합니다. 이를 통해 사용자는 빠르게 서비스를 이용할 수 있고, 해당 서비스는 검색 엔진 최적화(SEO)를 통해 더 많은 노출 기회를 얻을 수 있습니다.\n\n하지만 서버 사이드 렌더링(SSR)을 위해서는 별도의 서버 운영이 필요합니다.  프레임워크를 사용하는 경우, 서버 구축 및 운영 등의 문제에는 벗어날 수 있지만 렌더링 과정에 서버가 개입되면서 window is not defined 와 같은 생소한 에러를 경험하게 됩니다.\n\n단순하게 생각해보면 서버에서 제공한 HTML을 이용한 것뿐인데, 왜 이런 에러를 경험하게 되는걸까요? 서버 사이드 렌더링(SSR)환경에서 흔히 발생하는 에러와 그 해결법을 사례를 통해 살펴보겠습니다.\n\nNext.js 렌더링 과정\n예시로 살펴볼 애플리케이션은 쿼리 파라미터로 전달받은 유저의 이름을 화면에 출력합니다.\n\n\n코드를 살펴보면 문제없이 동작할 것 같지만 서버 사이드 렌더링(SSR) 환경에서 에러가 발생합니다. 어떤 부분이 에러를 일으키는걸까요? 에러 메시지를 보며, 원인을 찾아보겠습니다.\n\n\n1. 서버가 HTML을 생성한다.\n\n메세지를 살펴보면, 에러가 발생한 환경은 다음과 같은 특징을 가지고 있습니다.\n\n브라우저 객체인 location 이 존재하지 않는다. (location is not defined )\n\n페이지(HTML) 생성이 가능하다. ( This error happened while generating the page. )\n즉  1) 브라우저가 아니면서 동시에 2) 페이지(HTML) 생성이 가능하다는 사실을 통해 서버에서 발생한 에러임을 추측 해볼 수 있습니다.\n\n서버는 클라이언트에서 제공한 컴포넌트를 기반으로 HTML을 생성합니다. 이 때 만약 클라이언트 환경에만 존재하는 코드가 있다면 어떤 일이 일어날까요? 서버는 해당 코드의 작동 방식 을 이해할 수 없고, 이로 인해 에러가 발생하게 됩니다.\n\n처음 작성한 코드를 다시 돌아가보면 location 은 클라이언트 환경에만 존재하는 브라우저 객체입니다. 따라서, 해당 에러를 해결하기 위해서는 서버 환경에서 location 에 접근할 수 없도록 수정해야 합니다.\n\n\n\n2. Hydration Mismatch\n서버 환경에서 브라우저 객체에 접근할 수 없도록 수정한 후, 새로운 에러가 발생하였습니다.\n\n\n위 에러를 해결하기 위해서는 Hydration 에 대한 이해가 필요합니다.\n\n서버에서 생성한 HTML은 단순 마크업이므로 사용자 인터랙션이 불가능합니다. 따라서 React는 이벤트 리스너, 상태 관리와 같은 클라이언트 로직을 전달받은 HTML과 통합하여 애플리케이션으로 작동할 수 있도록 합니다. 이 과정을 Hydration 이라 합니다.\n\n여기서 주의깊게 봐야할 점은 로직 연결 과정입니다. React는 요소(Element)와 로직 정보가 담긴 가상 DOM을 생성한 뒤, 이를 전달받은 HTML과 비교합니다. 따라서, 서버와 클라이언트의 렌더링 결과가 같은 경우에만 Hydration 을 수행할 수 있습니다.\n\n첫 번째 수정사항으로 서버에서 바라보는 name 변수의 값은 항상  null  입니다. 따라서 쿼리 파라미터가 존재하는 경우, 서버와 클라이언트는 각각 다른 결과물을 렌더링 하게 되면서 Hydration 을 수행할 수 없는 상태가 됩니다.\n\n\n하나의 코드, 동일한 결과 Isomorphic \n그렇다면 어떻게 문제를 해결할 수 있을까요? \n\nHydration Mismatch 를 해결하기 위해서는, 서버와 클라이언트의 렌더링 결과물이 같아야합니다. 이를 위해 서버 환경에서 쿼리 파라미터에 접근할 수 있는 별도의 로직 작성이 필요합니다. \n\n\n다행히도 Next.js는 개발자가 겪을 불편함을 줄여주고자 useRouter() 을 제공하고 있습니다.\n\n\nuseRouter() 를 사용하면 별도의 예외처리 없이도 서버, 클라이언트 어떤 환경에서든 동일한 결과 값을 보장 받을 수 있습니다.\n\n\n이처럼 서버와 클라이언트 양측에 동일한 결과를 보장하는 코드를 isomorphic 하다고 표현합니다. \n\n요구사항을 다시 살펴보면, 쿼리파라미터 값을 화면에 출력하는 매우 간단한 작업입니다. 그러나 서버 사이드 렌더링 환경에 대한 이해가 없었다면, 에러를 해결하는데 많은 시간을 소비했을 것입니다. 만약 처음부터 useRouter() 를 사용했다면 어땠을까요? \n\nisomorphic 한 코드는 나와 동료의 시간을 절약해줍니다. 일관된 결과를 서버와 클라이언트 양측에 보장하기 위해서는 관련 작업이 반드시 필요합니다. 따라서, 이러한 작업들을 추상화 해둔다면 불필요한 코드들을 감춰지고, 구현에만 집중할 수 있게 됩니다.\n\n\n토스의 isomorphic\n그렇다면 실제 서비스에 적용해볼 수 있는 실용적인 사례는 없을까요? 토스 프론트엔드 챕터에서 사용하고 있는 isomorphic 사례를 소개드리고 마무리 하겠습니다.\n\n\nSSRSuspense\n<Suspense /> 는 비동기 요청을 선언적으로 처리할 수 있도록 돕는 컴포넌트입니다.\n\nPromise가 대기 상태일 때(Pending) : <Loading />\nPromise가 완료됐을 때(Resolved): <APIRequestComponent />\n\n그러나 React 18 버전 미만에서는 <Suspense/>가 오직 클라이언트 환경에서만 정상 작동한다는 한계점이 있습니다. SSR 환경에서 안정적으로 작동할 수 있도록 <Suspense/>는 컴포넌트가 마운트  되기 전에는 fallback 컴포넌트를 렌더링합니다.","isDisplayingFeedback":true},{"id":22565,"updatedTime":"2023-10-11T16:38:50+09:00","createdTime":"2023-09-01T12:10:36+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"금융사 최초의 Zero Trust 아키텍처 도입기","subtitle":"왜 보안이 강화될수록, 업무는 불편해지는 걸까요? \n금융에서 가장 중요한 가치인 ‘안전’과 혁신을 위한 ‘업무 편의성’, 두 마리 토끼를 모두 잡기 위한 여정을 소개합니다.  ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-security","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-09-01T11:59:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22565,"title":null,"description":"왜 보안이 강화될수록, 업무는 불편해지는 걸까요? \n금융에서 가장 중요한 가치인 ‘안전’과 혁신을 위한 ‘업무 편의성’, 두 마리 토끼를 모두 잡기 위한 여정을 소개합니다.","urlSlug":"slash23-security","primaryKeyword":{"id":13396,"content":"slash23","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":3709,"content":"보안 엔지니어","wordType":"SEO_KEYWORD"},{"id":3724,"content":"토스 보안","wordType":"SEO_KEYWORD"},{"id":4005,"content":"보안","wordType":"SEO_KEYWORD"},{"id":12243,"content":"토스 보안팀","wordType":"SEO_KEYWORD"},{"id":13398,"content":"제로트러스트","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"금융사 최초의 Zero Trust 아키텍처 도입기","description":"왜 보안이 강화될수록, 업무는 불편해지는 걸까요? \n금융에서 가장 중요한 가치인 ‘안전’과 혁신을 위한 ‘업무 편의성’, 두 마리 토끼를 모두 잡기 위한 여정을 소개합니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_og_03%20(1).png","imageType":"직접입력"},"relatedPostConfig":{"id":3302,"relatedPosts":[{"id":22563,"updatedTime":"2023-10-11T17:04:28+09:00","createdTime":"2023-08-31T23:16:00+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"은행 최초 코어뱅킹 MSA 전환기 (feat. 지금 이자 받기)","subtitle":"수십 년간 정체되어 있던 전통적인 은행 시스템의 모놀리식 소프트웨어 아키텍처를 MSA로 전환할 수 있을까요? \n토스뱅크의 ‘코어뱅킹 MSA 전환’ 사례를 통해 향후 은행 시스템이 나아가야 할 방향을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_02.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_02.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-corebanking","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-31T23:37:00+09:00","commentBoard":null,"disclaimer":null},{"id":22478,"updatedTime":"2023-10-11T17:03:23+09:00","createdTime":"2023-08-22T17:10:44+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"레고처럼 조립하는 토스 앱","subtitle":"수많은 서비스를 담고 있는 대규모 iOS 앱에 어울리는 아키텍처는 무엇일까요?\n프로젝트 간의 의존성과 모듈 간의 결합도를 낮춰, 더 효율적인 서비스 개발, 관리를 이뤄낸 과정을 소개합니다. ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-iOS","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-22T17:46:00+09:00","commentBoard":null,"disclaimer":null}],"title":"함께 읽어보면 좋을 콘텐츠"},"editor":{"id":1047,"name":"정연우","slug":"yeonwoo","shortDescription":"Security Engineer","description":".","imageUrl":"https://static.toss.im/career-resource/yeonwoo.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"전통적인 환경의 보안 아키텍처는 방화벽과 같은 경계를 기준으로 신뢰와 비신뢰를 나누어서 운영이 되고 있었는데요. 신뢰 구간에서의 추가적인 보안 통제가 없으면서 신뢰의 크기가 커진다면 그만큼 보안의 Risk들도 증가하게 된다는 한계점들이 있었고, 다원화 된 Identity 관리, 보안 솔루션 관리, 재택근무 환경과 오피스 환경의 이원화된 환경을 관리함으로써 보안 가시성 확보 및 관리의 어려움, 팀원들의 업무의 불편함들을 해결하기 위해 토스에서는 제로트러스트 보안 아키텍처를 도입하게 되었는데요. 어떤 과정으로 도입하였고, 어떻게 운영 중인지 살펴보려고 합니다. \n\nZero Trust란?\n고정된 네트워크 경계를 방어하는 것에서 사용자, 자산, 자원 중심의 방어로 변경하는 발전적인 사이버 보안 패러다임입니다.\n\n제로 트러스트는 물리적 위치, 네트워크 위치, 자산 소유권을 기준으로 자산 또는 사용자 계정에 부여된 암묵적인 신뢰는 없다고 가정합니다.\n\n\nZero Trust를 도입하기 위한 고민\nZero Trust 보안 아키텍처를 도입하기 위해서는 현재 우리가 가지고 있는 리스크들을 정리하고, 대체 혹은 보완하는 것에 대한 고민들이 필요한데요. 저희는 아래와 같은 고민을 하였습니다. \n\nIdentity: 다원화된 인증 시스템 사용으로 인하여 계정, 권한 관리의 어려움으로 인해 보안 가시성이 낮아지는 부분을 통합으로 관리하여 보안 가시성을 확보\nDevice: Active Directory, PMS(Patch Management System) MacOS의 OS 보안 패치, SW 관리, PC 보안 정책 확보의 어려움으로 인한 대체 수단 마련\nNetwork: 재택근무 시 네트워크 보안 통제의 어려움, SSL Inspection을 통한 네트워크 분석의 어려움들을 해결하는 대체 수단 마련을 통한 보안 가시성 확보 및 사내 네트워크 접근 시 추가적인 보안 검증을 통한 위협 예방 \n각 영역에서 통제를 다른 영역과 연계하는 통제 수단 마련 \n예시 1) Application 혹은 사내 네트워크 접근 시 Endpoint 정보를 식별하여, 접근 유무 결정\n예시 2) 사내 네트워크에 대한 접근 통제 시 Identity 정보를 통한 접근 통제 \n각 영역의 이벤트들을 통합 분석하여 보안 위협 식별 및 대응 \n\nZero Trust 아키텍처 주요 컴포넌트\nIdentity, Device, Network, Data, Application 각 영역에서의 보안성, 가시성을 확보하고, 각 영역 간 연계를 통한 추가적인 접근 통제 및 통합 보안 이벤트 분석을 통한 위협 식별 및 대응\n\n\n주요 기능\nIAM (Identity Access Management) \nSingle Sign On : Application 로그인 통합(SAML, OIDC)\nRBAC(Role Based Access Control) : 인사 DB와 연계하여 직군, 팀 단위의 접근 제어\nABAC(Attribute Based Access Control) : Role(권한)이 할당 되어있더라도, 회사에서 정의한, Network, 자산, 보안을 검증을 통한 접근제어\nPolicy : Application에 접근할 때의 Factor(ID/PW, MFA 등) 정의, RBAC, ABAC 기반의 접근제어\nSecurity : Threat Intelligence 분석 / SIEM(Security Information Event Management) 연동을 통한 계정 탈취와 같은 보안 위협 예방 및 방지\nSASE(Secure Access Service Edge)\nPolicy : SSL Inspection을 통한 암호환 된 Traffic 복호화 및 HTTPS Packet 분석\nURL Filter, Application Control을 통한 유해사이트, 비인가사이트 차단\nData Protection :\nDLP(Data Loss Protection)을 통한 회사의 중요 데이터(내부자료, 개인정보) 유출 모니터링, 방지\nFile Type Control: File 확장자 기반의 Upload / Download Contents 식별 및 차단\nCASB(Cloud Access Security Broker)를 통한 Cloud에 보관된 중요 데이터 유출 방지\nThreat Management : \nMalware: 악성코드, 랜섬웨어, 스파이웨어 등을 식별 및 차단\nATP(Advanced Threat Protection): 네트워크 트래픽 검사를 통한 악성코드, 스팽, 피싱과 같은 위협 식별 및 차단\nSandbox: 파일, URL, IP 등의 데이터를 분석하여 위협 식별과 악성코드 분석 및 격리\nZTNA(Zero Trust Network Access)\nRole : IAM 연동을 통한 회사 인사 DB를 활용한 내부 네트워크에 접근할 수 있는 사용자, 그룹 정의\nSegments : 내부 네트워크에 있는 자산을 Application 단위로 정의(Domain, IP, Port 등\nPolicy : Role, Segments를 사용한 접근제어, Role이 있는 사용자라도 EPP(Endpoint Protection Platform)와 연계하여 접근할 때마다 Device 보안성 검증UEM(Unified Endpoint Management)\nUEM(Unified Endpoint Management) \nDevice Management : Device 보안, 데이터 보호, SW 등 식별 및 관리\nAsset Management : 하드웨어, 네트워크, 사용자 정보 수집, Device 분실 시 잠금 및 초기화\nApplication Management : OS, 필수 S/W(브라우저, 메신저, 보안 프로그램, 인증서 등)을 자동 설치 및 패치 관리\nPolicy : Device 보안 정책 준수(화면보호기, Disk 암호화 등)\nEPP(Endpoint Protection Platform)\nAnti-Malware : 악성코드, 랜섬웨어, 스파이웨어 등의 위협으로부터 보호\nEDR(Endpoint Detection & Response) : 실시간 악성코드,공격 탐지 및 대응\nDevice 행동(File System, Registry 변경, Process 실행 등) 분석을 통한 보안 위협 탐지 및 대응 탐지된 보안 위협 정보 분석을 통한 유사한 위협 예방 및 대응\nDevice Compliance : Device에 대한 OS 보안 설정과 EPP의 보안 상태 평가, 분석, 취약점 및 위협 식별\nIAM, SASE & ZTNA와 연계를 통한 접근제어\n\n전환 절차 \nIAM 온보딩\n관리자가 사전에 팀원들에 정보를 받아서 IAM 계정을 생성을 하고,\n팀원들은 Password 설정 & MFA (Multi Factor Authentication)를 설정합니다.\n\nActive Directory 제거 & UEM Join\n더 이상 Active Directory와 PMS를 통해 Device의 보안 설정과 SW 패치 관리를 하지 않을거라 Device에 스크립트를 실행시켜서 AD Join을 풀고, UEM에 IAM을 통해 로그인을 합니다.\n로그인을 완료 하면, 자동으로 미리 설정해둔 Device의 보안 설정(예시: 화면보호기 설정, 디스크 암호화 등)을 적용하고, 더이상 사용하지 않는 Application 들은 삭제하고, 앞으로 사용해야하는 Application(웹브라우저, 메신저, EPP, SASE, ZTNA)는 자동으로 설치 됩니다. \n\nSASE & ZTNA Login \n마지막으로 SASE & ZTNA Agent에 IAM 계정을 통해 로그인을 하면, Zero Trust 환경으로 전환 과정은 완료 됩니다. \n\nSASE와 ZTNA는 기존에 사용하던 방화벽 정책을 기반으로 Migration은 하지만, IP 기반 접근제어가 아닌, \nRBAC(Role Based Access Control) 기반 즉, 토스의 조직 정보를 기반으로 정책을 Migration 하였습니다. \n\n\n\n도입 후\nLogin\n저희가 사용중인 Application들을 IAM과 SSO 연동을 통해서 Application에 로그인 할 때에는 IAM 통에 인증을 완료 후 접근합니다. \n\nIAM 연동을 하기 전에는 ID/Password + OTP를 통해서만 검증을 했었다면, 이제는 신뢰된 Network 인지, 회사 자산인지, Device의 보안 수준은 준수되는지를 검증을 추가로 하여 접근을 합니다. 이 과정은 생체 인증으로 인증을 하는 과정에서 검증이 됩니다. 단, 검증하는 과정이 생겨도 로그인 속도가 지연되지 않습니다.\n\n\n\nNetwork\nSaaS Application이나 인터넷을 접근할 때에는 SASE가, On-Premise나 Public Cloud와 같은 Private 네트워크에 접근할 때에는 ZTNA가 동작을 하게 되는데요. \n\n회사에서 근무를 할 때와 재택근무를 할 때 위치에 큰 제약 없이 회사에 있을 때와 동일한 보안 환경으로 업무용 시스템 어디든 접속이 가능합니다. \n단, 업무용 시스템에 접속 할 때 접속하는 Device가 보안을 준수하고 있는지 빠르게 검증하고, 인터넷을 할 때는 피싱 사이트와 같은 곳으로부터 안전하게 회사의 자산과 데이터를 보호합니다.\n\n\n\nRBAC & ABAC \n인사DB와 IAM을 연동하고, IAM과 Application, Network 등을 연동하여 팀원의 직무(Role)을 기반의 접근제어를 통한 접근제어 정책을 구성하여 보안정책의 가시성을 확보하고, 팀원의 퇴직 시에는 자동으로 할당된 권한이 회수되고, 직무의 변경이 있을 때 자동으로 권한이 회수되고, 변경된 직무에 맞는 권한으로 재 할당이 됩니다.\n\n\n\n마치며\n토스에서 Zero Trust 아키텍처 도입을 통해 보안 가시성 확보, 보안 관리의 효율화를 하면서도 팀원들의 업무 편의성도 향상되었습니다. \n\n글을 마무리하면서, 글의 내용을 요약하자면 아래와 같습니다. \n\nZero Trust란 고정된 네트워크 경계를 방어하는 것에서 사용자, 자산, 자원 중심의 방어로 변경하는 발전적인 사이버 보안 패러다임입니다. \nIAM, ZTNA, UEM, EPP, SIEM등을 연계하여 상호 보완적으로 Zero Trust 아키텍처를 구축하였습니다.\nZero Trust 아키텍처를 도입 후 각 영역에서 보안 가시성 확보, 보안 관리의 효율화를 진행하면서도 팀원들의 업무 편의성도 향상되었습니다.\n\nDLP(Data Loss Protection)을 통한 회사의 중요 데이터(내부자료, 개인정보) 유출 모니터링, 방지\nFile Type Control: File 확장자 기반의 Upload / Download Contents 식별 및 차단\nCASB(Cloud Access Security Broker)를 통한 Cloud에 보관된 중요 데이터 유출 방지","isDisplayingFeedback":true},{"id":22563,"updatedTime":"2023-10-11T17:04:28+09:00","createdTime":"2023-08-31T23:16:00+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"은행 최초 코어뱅킹 MSA 전환기 (feat. 지금 이자 받기)","subtitle":"수십 년간 정체되어 있던 전통적인 은행 시스템의 모놀리식 소프트웨어 아키텍처를 MSA로 전환할 수 있을까요? \n토스뱅크의 ‘코어뱅킹 MSA 전환’ 사례를 통해 향후 은행 시스템이 나아가야 할 방향을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_02.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_02.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-corebanking","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-31T23:37:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22563,"title":null,"description":"수십 년간 정체되어 있던 전통적인 은행 시스템의 모놀리식 소프트웨어 아키텍처를 MSA로 전환할 수 있을까요? \n토스뱅크의 ‘코어뱅킹 MSA 전환’ 사례를 통해 향후 은행 시스템이 나아가야 할 방향을 소개합니다.","urlSlug":"slash23-corebanking","primaryKeyword":{"id":11972,"content":"SLASH23","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":3847,"content":"토스 개발자","wordType":"SEO_KEYWORD"},{"id":12517,"content":"은행","wordType":"SEO_KEYWORD"},{"id":13400,"content":"아키텍처","wordType":"SEO_KEYWORD"},{"id":13403,"content":"코어뱅킹","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"은행 최초 코어뱅킹 MSA 전환기 (feat. 지금 이자 받기","description":"수십 년간 정체되어 있던 전통적인 은행 시스템의 모놀리식 소프트웨어 아키텍처를 MSA로 전환할 수 있을까요? \n토스뱅크의 ‘코어뱅킹 MSA 전환’ 사례를 통해 향후 은행 시스템이 나아가야 할 방향을 소개합니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_og_02.png","imageType":"직접입력"},"relatedPostConfig":{"id":3150,"relatedPosts":[{"id":22478,"updatedTime":"2023-10-11T17:03:23+09:00","createdTime":"2023-08-22T17:10:44+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"레고처럼 조립하는 토스 앱","subtitle":"수많은 서비스를 담고 있는 대규모 iOS 앱에 어울리는 아키텍처는 무엇일까요?\n프로젝트 간의 의존성과 모듈 간의 결합도를 낮춰, 더 효율적인 서비스 개발, 관리를 이뤄낸 과정을 소개합니다. ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-iOS","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-22T17:46:00+09:00","commentBoard":null,"disclaimer":null},{"id":22565,"updatedTime":"2023-10-11T16:38:50+09:00","createdTime":"2023-09-01T12:10:36+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"금융사 최초의 Zero Trust 아키텍처 도입기","subtitle":"왜 보안이 강화될수록, 업무는 불편해지는 걸까요? \n금융에서 가장 중요한 가치인 ‘안전’과 혁신을 위한 ‘업무 편의성’, 두 마리 토끼를 모두 잡기 위한 여정을 소개합니다.  ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-security","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-09-01T11:59:00+09:00","commentBoard":null,"disclaimer":null}],"title":"함께 읽어보면 좋을 콘텐츠"},"editor":{"id":1046,"name":"장세경/조서희","slug":"sekyung-seohee","shortDescription":"Core Banking Developer","description":".","imageUrl":"https://static.toss.im/career-resource/sekyung-seohee.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스뱅크는 기존의 공급자 중심의 뱅킹 서비스를 고객 중심으로 변화시키기 위해 많은 노력을 기울이고 있어요.\n\n그러나 기존의 전통적인 뱅킹 시스템을 구현하는 방식으로는 안정적인 고객 중심 뱅킹 서비스 제공에 여러 기술적 한계가 있었죠. \n\n이번 아티클에서는 토스뱅크가 어떤 방식으로 기술적 한계를 극복했고, 어떤 기술로 고객 중심의 뱅킹 서비스를 제공해 드리고 있는지에 대해 소개해 드릴게요.\n\n\n현재 은행 시스템에 대한 소개\n채널계와 코어뱅킹(계정계)\n\n먼저, 일반적인 은행 시스템의 아키텍처에 대해 알아볼게요. \n\n은행에는 크게 고객의 요청을 코어뱅킹 서버로 전달하는 채널계와 금원과 관련된 메인 비즈니스 로직을 처리하는 코어뱅킹(계정계)라고 하는 두 개의 서버를 중심으로 하는 아키텍처로 구성되어 있어요. \n\n여기에 코어뱅킹 서버는 대부분의 은행에서 거대한 모놀리식 아키텍처로 구성되어 있죠.\n\n\n코어뱅킹 시스템 아키텍처 히스토리\n\n코어뱅킹 시스템이 모놀리식 아키텍처를 유지해온 이유는 은행 시스템의 변천사를 알면 그 힌트를 얻을 수 있는데요. \n\n1970년대부터 은행의 계좌 데이터를 적절하게 가공하고 처리해야 하는 니즈가 생기면서, 1세대와 2세대 코어뱅킹 아키텍처가 생겨났고, 2000년대에 디지털 붐이 일면서 모바일 뱅킹, 웹 뱅킹, 텔레뱅킹 등 다양한 거래 요청을 한 곳에서 적절하게 처리해줄 수 있도록 현재의 모놀리식 코어뱅킹 아키텍처가 생겨나게 되었어요. \n\n지난 20여 년간 코어뱅킹 아키텍처는 운영체제와 개발언어의 크고 작은 변화는 있었지만, 현재의 모바일 트렌드와는 맞지 않는 20년 전의 모놀리식 아키텍처를 대부분의 은행에서 사용하며, 현재의 거대한 모놀리식 형태로 몸집을 불려가고 있었죠.\n\n\n현재 토스뱅크의 채널계는 기존 토스의 DNA를 이어받아 모두 MSA 환경으로 구성되어 있어요. 반면에, 기존의 코어뱅킹 시스템은 Redis, Kafka 등의 모던한 기술을 사용하고는 있었지만, 여타 은행과 다름없이 채널계와의 통신을 위한 MCI, 대외연계를 위한 FEP, 대내 단위 시스템과의 연계를 위한 EAI가 코어뱅킹 서버에 강결합되어 있는 구조로 여타 은행과 다른 없는 거대한 모놀리식 시스템으로 구성되어 있었죠.\n\n그렇다면, 모놀리식 코어뱅킹 아키텍처가 어떤 한계가 있었기에 MSA로 전환했어야 했을까요? 모놀리식 코어뱅킹 시스템의 장점과 단점을 곱씹어보며, 그 이유를 살펴볼게요.\n\n\n물론 모놀리식 코어뱅킹 시스템도 장점이 있습니다. \n\n모놀리식 코어뱅킹 시스템의 장점\n트랜잭션 관리의 용이성 : 로컬 DB 트랜잭션으로 여러 하위 도메인의 데이터를 ACID하게 변경할 수 있음.\n개발의 단순성 : 모든 코드가 단일 코드 베이스에 있으므로 개발하기가 단순함.\n보편성 : 대부분의 코어뱅킹 시스템이 모놀리식으로 구성되어 있으므로, 인력 수급과 개발이 용이함.\n\n그렇지만, 모놀리식으로 구성된 시스템은 트래픽이 갑자기 몰렸을 때, 특정 코어뱅킹 서비스만 스케일 아웃을 하는 전략을 가져갈 수 없어요.\n\n\n또한, 1개의 서버이기 때문에 장애가 발생한 서비스 외에 다른 서비스들의 영향도를 제한할 수 없어, 안정성이 부족하다는 단점도 있죠. 즉, 한 개의 컴포넌트에서 장애가 발생하면, 전 업무가 마비되는 구조로 이어질 수 있다는 건데요.\n\n예컨대, 토스뱅크가 카드 결제 시 결제 금액의 30%를 환급해주는 파격적인 이벤트를 모놀리식 시스템 구조에서 진행한다고 해볼게요.\n\n카드 서비스는 평소보다 훨씬 많은 트래픽이 들어올 것이고, 이 트래픽이 수용할 수 있는 임계점을 넘어서면, 이벤트를 진행하는 카드 서비스 뿐만 아니라 전혀 상관 없는 계좌 개설이나, 대출 약정 서비스들까지도 마비 될 거에요.\n\n미리 이벤트를 알고 있다고 하더라도, 카드 서비스만 스케일 아웃을 할 수 없기 때문에 전체 시스템의 가용성을 확보해두어야 하는 비효율도 발생할 것이고요.\n\n모놀리식 아키텍처의 서비스 영향도 제한이 어려운 이유에 대해 조금은 이해가 되셨나요?\n\n토스뱅크는 고객분들에게 가치를 제공해드리기 위해 하루에도 수차례씩 혁신적인 실험과 기능 추가를 위한 배포를 하고 있어요. 그러면서 Market Fit에 맞는 제품과 서비스들을 빠른 속도로 찾아가고 있고, 그만큼 토스뱅크를 애용해주시는 고객분들도 많이 늘어나고 있죠.\n\n하지만 토스뱅크의 서비스가 고객분들의 사랑을 받아 나날이 성장하는 만큼 기존의 모놀리식 아키텍처를 유지하면서 토스뱅크의 혁신적인 서비스들을 안정적으로 제공해드리기는 점점 어려워졌어요. \n\n\n그래서 저희는 현재의 차세대 코어뱅킹 아키텍처를 대량 트래픽에 특화되어 있고, 각 업무별 서비스 영향도를 분리할 수 있는 MSA로 전환하기로 결정했습니다.\n\n그중에서도 저희는 토스뱅크 서비스 중에서 가장 트래픽이 많으면서, 토스뱅크의 대표 서비스 중 하나인 지금 이자 받기 서비스를 모놀리식 코어뱅킹 시스템에서 분리하여 MSA로 전환하기로 했답니다. \n\n\n개발 방법\n기술 스택 선정\n\n먼저 기술 스택은 현재 토스뱅크 채널 서버에서 사용하고 있는 기술들을 대부분 채택했어요. Kubernetes위에 Spring boot, Kotlin, Jpa 등을 기반으로 개발했고, 비동기 메시지 처리와 캐싱은 Kafka, Redis를 사용하기로 결정했어요.\n\n그런데 개발하자마자 첫 번째 고민에 봉착했는데요. 현재 모놀리식으로 강결합되어있는 업무별 비즈니스 의존성을 어느 정도까지 느슨하게 가져갈 것이냐였어요.\n\n지금 이자 받기를 위해 필요한 도메인은 고객 정보 조회를 위한 고객, 금리조회를 위한 상품 그리고 이자의 회계 처리를 위한 회계 정보가 필요했어요. 이 모든 것을 하나의 마이크로 서버에서 처리하는 것은 MSA의 장점을 활용하지 못할 것이라 판단하여, 도메인 단위로 서비스를 나누기로 결정했어요.\n\n\n고객의 지금 이자 받기 요청은 고객 정보 조회를 거쳐, 금리 조회와 이자계산, 이자 송금, 회계처리를 한개의 트랜잭션으로 처리하고 있었는데요.\n\n\n새로운 코어뱅킹 아키텍처에서는 트랜잭션으로 엮이지 않아도 되는 도메인은 별도의 마이크로 서버로 구성했고, 각 서버의 API 호출을 통해 비즈니스 의존성을 느슨하게 가져가도록 구성했어요.\n\n그러면 이제 실제 이자지급 서버를 어떻게 개발했는지 알아볼게요. \n\n\n동시성 제어\n먼저 은행 시스템의 안정성과 직결되는 부분인 동시성 제어입니다. \n\n\n일단 적절하게 동시성 제어가 안되었을 때, 어떤 문제가 있을지 살펴볼까요? \n\n0.01초 사이에 Transaction1을 통해 이자를 받았고, Transaction2를 통해 입금을 받았다고 가정해보면, Transaction1에서는 현재 잔액 기준인 100원에 지금 이자 받기를 한 100원을 더해 200원으로 갱신을 할 거예요.\n\n그리고 Transaction2에서는 Transaction1의 요청이 있었는지를 알 수 있는 방법이 없으므로, 처음에 조회한 100원의 잔액에 타행으로부터 입금받은 300원의 잔액을 더해 400원이라는 엉뚱한 금액으로 잔액을 갱신할 거예요. \n\n이렇게 되면, 어떤 고객도 토스뱅크의 시스템을 신뢰하지 않겠죠.\n\n\n이렇듯 은행에서 고객 잔액의 갱신은 앱을 통한 거래는 물론이고, 타행을 통한 입금, ATM을 통한 이체, 자동이체 등으로 잔액를 갱신하는 트랜잭션의 채널이 매우 많아요. \n\n그렇기 때문에 일반적으로 사용되는 Redis Global Lock 만으로는 은행 시스템 환경에서 동시성 제어 이슈는 해결하기가 어렵죠. \n\n그래서 동시성 이슈를 해결하는 것이 코어뱅킹 개발에 있어서 필수 조건이라고 할 수 있습니다.\n\n\n저희는 이 문제를 Redis Global Lock과 더불어 DB Layer에서 동시성을 제어하기 위한 JPA의 @Lock 어노테이션을 통해 해결했어요.\n\n\n앞에 예시로 다시 돌아가 볼게요. \n\nTransaction2는 DB Layer에서 Lock으로 동시성을 제어하고 있기 때문에 Transaciton1이 끝날 때까지 대기합니다. \n\n그리고, Transaction1의 commit이 끝난 이후의 변경된 잔액을 참조하겠죠. 그러면 잔액은 최초에 예상했던 500원으로 commit이 되고 트랜잭션의 동시성은 안전하게 보장됩니다.\n\n그런데 이 때, DB Lock을 사용할 때는 주의해야 하는 점이 있어요. \n\nLock을 잡아야 하는 데이터를 명확히 식별하고, 갱신하는 데이터에 대해서만 Lock을 획득해야 데드락과 시스템 성능 저하를 예방할 수 있다는 점인데요.\n\n지금 이자 받기API의 경우 잔액을 갱신하는 이벤트가 메인 비즈니스 로직이기 때문에, 계좌 단위 현재 잔액 데이터에 대해서만 고유하게 Row Locking이 걸리도록 개발하여, 동시성을 보장하도록 구현했어요.\n\n또한, Transaction2의 동시성이 발생하였을 때, Transaction1을 끝날 때까지 기다릴 수 있도록 재시도할 수 있는 로직과 적절한 타임아웃을 적용해주어서 고객 관점에서 Lock이 걸렸는지도 모르게 안정적으로 이자를 받을 수 있게 구현했죠.\n\n\n성능 개선을 위한 비동기 처리\n두번째는 카프카를 활용한 비동기 트랜잭션 구현입니다. 기존 코어뱅킹 시스템에서는 1번의 이자를 지급받기 위해 20개의 테이블에 80번의 UPDATE, INSERT가 이루어지는 복잡한 구조였어요.\n\n그렇기 때문에 지금 이자 받기 서비스의 속도도 평균 300ms로 전체 코어뱅킹 서비스 중에서 느린 편에 속했죠. 이 정도면 정규화가 잘 되어 있는 데이터 모델과 정교하게 잘 설계된 인덱스 구조로도 빠른 응답 속도를 기대하기는 어려운 구조였어요. 그래서 기존 지금 이자 받기 트랜잭션에서 분리가 가능한 테이블은 카프카를 이용해 트랜잭션에서 분리했어요.\n\n트랜잭션 분리에 대한 기준은 고객의 잔액과 통장 데이터 관점에서 DB 쓰기 지연이 발생하였을 때, 실시간으로 문제가 발생하느냐? 로 접근하였고, 반드시 트랜잭션이 보장되어야 하는 데이터 모델과 즉시성을 요하지 않는 즉, 세금 처리와 같이 지금 이자 받기 트랜잭션과 묶이지 않아도 되는 데이터 모델의 DML은 트랜잭션을 분리했죠.\n\n\n구체적으로 살펴보면, 지금 이자 받기 서버에서 지금 이자 받기의 트랜잭션 종료와 동시에 세금 카프카 토픽에 메시지를 Produce하고, 비동기 처리 서버가 Consume해서 세금 DB에 저장하도록 구현했어요. 정상적인 상황이라면, 이자 DB와 세금 DB에도 준실시간으로 업데이트가 되었을 것이기 때문에 지금 이자 받기의 거래는 정상적으로 종료될 거에요.\n\n그렇지만, 카프카 메시지가 정상적으로 처리되지 않는 경우도 있기 때문에, dead letter queue를 이용해서 세금DB에 대한 트랜잭션을 안정적으로 보장할 수 있도록 했어요. 또, 재처리시 중복으로 세금이 업데이트 안되도록 API도 멱등하게 설계했죠.\n\n그 결과 세금 DML을 지금 이자 받기 트랜잭션에서 분리함으로써, 기존 80회의 DML이 이루어지던 지금 이자 받기 트랜잭션을 50회의 DML로 줄이는 개선 효과를 얻을 수 있었습니다.\n\n\nRedis를 활용한 캐싱 전략\n마지막으로는 Redis를 활용한 캐싱 전략입니다. \n\n\n기존 코어뱅킹 시스템에서의 이자 계산은 RDB 기반의 일자별 거래내역DB를 조회해서 연산하는 방식으로 구현되어 있었어요.\n\n고객이 지금 이자 받기를 할 때마다, 계좌의 매일 매일 거래내역을 참조해서 이자 계산과 세금을 계산하는 구조이므로 성능적으로 오래 걸릴 수 밖에 없는 구조였죠. 그러나 고객은 하루에 1번 밖에 이자를 못받기 때문에 Redis를 활용하면, 하루에 1번만 DBIO를 발생시킬 수 있을 것이라 판단해서 Redis를 이용해 캐시를 활용하기로 했어요.\n\n\n기존의 이자금액은 고객이 계좌 상세탭에 접근할 때마다, 이자계산을 위한 DB I/O가 발생하고 있었는데요. 이를 고객이 하루 중 처음으로 계좌 상세탭에 접근할 때에만 DB에 접근하도록 구현했고, 이자예상조회의 결과를 Redis에 캐싱해 두도록 구현했어요. \n\n\n그래서 고객이 하루에 2번 이상 계좌 상세탭에 접근할 경우에는 Redis에 미리 저장되어 있던 이자계산 결과를 리턴하도록 했죠. 그래서 불필요하게 DB 리소스가 낭비되는 것을 예방했습니다. \n\n또한, Redis에 캐싱 된 이자 데이터의 만료일자도 하루로 두어서, 이자금액이 잘못 계산 되는 케이스도 원천적으로 방지했어요. 그래서 매일 자정 이후 고객이 계좌 상세탭에 처음 접근할 때만, 이자예상조회의 결과를 캐싱해서 이자 데이터의 정합성도 안정적으로 보장할 수 있었죠.\n\n\n기존 시스템을 안정적으로 전환하는 방법\n이자 지급 마이크로 서버에 이자 조회 거래, 지금 이자 받기 거래를 개발 완료했어요. 이제 기존 코어뱅킹(계정계)를 참조하던 서비스를 이자 지급 마이크로 서버를 바라보도록 전환해야 하죠. \n\n시스템을 전환하기에 앞서, 이자 지급 마이크로 서버 API에 대한 검증이 필요했는데요. 어떤 검증 방식을 활용할 수 있을까요? \n\n첫 번째 방법: 실시간 검증을 통한 건별 검증 방식\n첫 번째 방법인 온라인 검증 방식을 도식화한 그림입니다. \n\n\n먼저, 앱에서 고객이 이자 조회 거래를 일으키면 채널계에서 MCI를 통한 기존 코어뱅킹 서버에 이자 조회 서비스를 호출하고, 동시에 이자 지급 마이크로 서버의 API를 호출했어요.\n\n\n코어뱅킹 서버에서 리턴된 이자 값과 이자 지급 마이크로 서버에서 리턴된 이자 값을 각각 리턴 받아, 두 이자 값이 불일치할 경우 토스뱅크 내부 모니터링 채널에 해당 내용을 알림으로 받도록 했어요. 채널에 알림이 오면 대상 및 로그를 확인하고 원인을 확인하여 이자 계산 로직을 수정해주는 과정을 거쳤어요. \n\n두 번째 방법: 배치를 활용한 대량 검증 방식\n다음은 배치를 활용한 대량 검증 방식입니다. \n\n\nStaging 환경이란? 실제 운영환경과 동일하게 구성된 내부 API 테스트용 환경. \n\nStaging 환경에서 채널계 배치를 활용해 매일 대량의 검증 대상 목록을 추출했고, 온라인 검증 방식과 동일하게 코어뱅킹 서버와 이자 지급 마이크로 서버를 각각 호출해주었어요. 대상 목록에 대한 검증이 모두 끝나면, 이자 리턴 값이 불일치했던 건들에 대한 내용을 담아 내부 모니터링 채널에 알림으로 받았고, 로직 수정을 반복해주었습니다. \n\n이렇게 저희는 두 가지 방식을 활용해서 이자 조회 거래에 대한 검증을 완료했습니다. \n\n그런데 실제 이자를 지급받는 지금 이자 받기 거래의 경우 코어뱅킹 DB 원장에 잔액을 갱신하고 거래내역을 쌓고, 회계 처리를 해주는 등의 작업이 필요했기 때문에, 거래가 발생했을 때 실제 데이터가 정확하게 쌓이고 갱신되었는지 추가로 검증해야 했어요. \n\n그래서 지금 이자 받기 거래의 데이터 정합성 검증을 위해, 상세한 도메인 기반의 테스트 시나리오를 작성했어요. \n\n\n테스트 시나리오 작성을 통한 E2E 통합 테스트 수행하기\n토스뱅크 통장은 잔액을 구간별로 나누어 이자를 차등 지급하고 있는데요. 잔액 구간별로 나누어 차등 계산되어 이자가 지급되었는지 검증이 필요했어요.\n\n\n그리고 명의도용, 해킹 피해, 사망 등 토스뱅크 고객의 상태에 따른 검증이 필요했고, 계좌의 상태 및 출금/입금 정지 상태에 따른 검증이 필요했죠.\n\n해당 검증 케이스들을 고려해서 테스트 시나리오를 수립했고, 케이스 별로 테스트를 진행하여 이자 계산 및 실제 DB에 데이터가 정확하게 갱신되었는지를 확인하며 로직을 수정해주는 과정을 거쳤습니다. 이 과정을 통해, 이자 받기 거래에 대한 정합성 검증을 완료할 수 있었어요.\n\n\n순차 배포를 통한 안정적인 마이그레이션하기 \n이제 API에 대한 검증은 완료되었으니, 코어뱅킹을 바라보던 서비스를 fade out 시키고 이자 지급 마이크로 서버 API만을 바라보도록 전환해줘야 했어요. \n\nAPI를 전환할 때 대상 모수를 점차 늘려가며, 순차적으로 오픈했는데요. 먼저 토스뱅크 수신개발팀에 오픈하여 직접 이자 받기 거래를 일으키며 데이터 결과값을 검증했어요. 특이사항이 없는 것을 확인하여 토스뱅크 내부 팀원에게 오픈하였고, 모니터링을 진행했어요.\n\n\n다음으로는 일부 고객을 대상으로 오픈하고 점차 모수를 늘려가며 순차 오픈하여 전체 고객을 대상으로 전환을 완료하는 방식을 선택했습니다. \n\n\n순차 배포 과정을 살펴보면, 코어뱅킹 서버를 바라보던 API 호출량과 이자 지급 마이크로 서버를 바라보던 API 호출량을 조절하여 이자 지급 마이크로 서버의 트래픽을 점차 늘려가는 형태로 진행했습니다.\n\n그렇게 저희는 순차 배포 방식을 채택 함으로써 기존에 운영하고 있던 시스템을 중단하지 않고도 안정적으로 시스템을 전환 할 수 있었어요.\n\n마지막으로 코어뱅킹 MSA 전환의 성과에 대해 공유 드리며, 이번 아티클을 마무리 해볼게요.","isDisplayingFeedback":true},{"id":22478,"updatedTime":"2023-10-11T17:03:23+09:00","createdTime":"2023-08-22T17:10:44+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"레고처럼 조립하는 토스 앱","subtitle":"수많은 서비스를 담고 있는 대규모 iOS 앱에 어울리는 아키텍처는 무엇일까요?\n프로젝트 간의 의존성과 모듈 간의 결합도를 낮춰, 더 효율적인 서비스 개발, 관리를 이뤄낸 과정을 소개합니다. ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-iOS","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-22T17:46:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22478,"title":null,"description":"수많은 서비스를 담고 있는 대규모 iOS 앱에 어울리는 아키텍처는 무엇일까요?\n프로젝트 간의 의존성과 모듈 간의 결합도를 낮춰, 더 효율적인 서비스 개발, 관리를 이뤄낸 과정을 소개합니다.","urlSlug":"slash23-iOS","primaryKeyword":{"id":11972,"content":"SLASH23","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":3847,"content":"토스 개발자","wordType":"SEO_KEYWORD"},{"id":12633,"content":"iOS","wordType":"SEO_KEYWORD"},{"id":13400,"content":"아키텍처","wordType":"SEO_KEYWORD"},{"id":13402,"content":"Microfeatures","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"레고처럼 조립하는 토스앱","description":"수많은 서비스를 담고 있는 대규모 iOS 앱에 어울리는 아키텍처는 무엇일까요?\n프로젝트 간의 의존성과 모듈 간의 결합도를 낮춰, 더 효율적인 서비스 개발, 관리를 이뤄낸 과정을 소개합니다.","backgroundColor":"#424242","imageAlt":"","imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_og.png","imageType":"직접입력"},"relatedPostConfig":{"id":3303,"relatedPosts":[{"id":22565,"updatedTime":"2023-10-11T16:38:50+09:00","createdTime":"2023-09-01T12:10:36+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"금융사 최초의 Zero Trust 아키텍처 도입기","subtitle":"왜 보안이 강화될수록, 업무는 불편해지는 걸까요? \n금융에서 가장 중요한 가치인 ‘안전’과 혁신을 위한 ‘업무 편의성’, 두 마리 토끼를 모두 잡기 위한 여정을 소개합니다.  ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-security","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-09-01T11:59:00+09:00","commentBoard":null,"disclaimer":null},{"id":22563,"updatedTime":"2023-10-11T17:04:28+09:00","createdTime":"2023-08-31T23:16:00+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"은행 최초 코어뱅킹 MSA 전환기 (feat. 지금 이자 받기)","subtitle":"수십 년간 정체되어 있던 전통적인 은행 시스템의 모놀리식 소프트웨어 아키텍처를 MSA로 전환할 수 있을까요? \n토스뱅크의 ‘코어뱅킹 MSA 전환’ 사례를 통해 향후 은행 시스템이 나아가야 할 방향을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_02.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/techblog_slash23_thumb_02.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"slash23-corebanking","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-31T23:37:00+09:00","commentBoard":null,"disclaimer":null}],"title":"함께 읽어보면 좋을 콘텐츠"},"editor":{"id":1042,"name":"이준석/송범근","slug":"juneseok-beomgeun","shortDescription":"iOS Developer","description":"-","imageUrl":"https://static.toss.im/assets/toss-tech/slash_juneseokbeomgeun.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"\n100만 줄.\n이게 뭐냐고요?\n\n바로, 토스 iOS 앱의 코드량입니다.\n\n\n토스팀은 사용자에게 가치를 전달하기 위해 끊임없이 서비스를 개발해왔어요. 지금 토스 앱 안에는 수백 개의 서비스가 들어있습니다. 그렇게 성장해오는 동안, 토스 iOS 앱도 Swift 100만 줄이 넘는 거대한 프로젝트로 자라났습니다.\n\n\n이 글을 읽고 계신 iOS 개발자분들에게 질문을 드려볼게요. \n\n이렇게 프로젝트가 크고 복잡해지면 뭘 해야 할까요?\n\n\n바로 모듈 분리입니다!\n\n앱을 하나의 큰 Xcode 프로젝트로 관리하는 대신, 여러 개의 작은 모듈로 나눕니다. 그리고 모듈 간의 적절한 구조를 설계하는 거죠.\n\n코드 베이스가 커지면, 모듈 분리도 점점 더 중요해지죠. 그래서 토스 iOS 챕터도 모듈화에 대한 많은 고민을 했는데요. \n\n이 글에서는, 저희가 어떻게 슈퍼 앱 토스의 모듈을 관리하고 있는지 살펴볼게요.\n\n먼저 기존 토스 앱의 구조를 알아봐야겠죠? \n\n\n기존 토스 앱은 가장 일반적인 계층 구조로 이루어져 있었어요. 책임과 역할에 따라 계층을 나눠 해당 계층에는 그에 맞는 모듈들이 위치하고, 하위 계층에 있는 모듈은 상위 계층에 있는 모듈을 의존할 수 없는 형태죠.\n\n공통적으로 쓰이는 유틸리티 모듈들이 모여있는 Foundation 계층.\n\n수백 개의 서비스 모듈이 위치한 Feature 계층.\n\n최종적으로 사용자에게 제공될 앱이 위치한 App 계층.\n\n이렇게 계층적으로만 모듈을 관리하고 있었어요.\n\n일반적인 계층 구조도 꽤 오랜 시간 잘 작동했습니다. 계층 안에서의 모듈 분리도 되어있었고요. 하위 계층의 모듈이라면 필요에 따라 가져다 활용할 수 있었죠.\n\n하지만 수년간 토스에는 정말 많은 서비스가 생겼습니다. 다시 말해 Feature 계층에 모듈들이 엄청나게 늘어났죠.\n\n\n그러다 보니 문제가 발생했습니다.\n\n단순히 모듈 수가 많아서는 아니었어요. 많은 서비스가 생겨나면서, 모듈 간의 의존성이 폭발적으로 늘어나는 게 문제였죠.\n\n하나의 서비스가 Feature 레이어의 여러 모듈을 활용하는 경우가 많이 생겼습니다. 결과적으로 같은 계층 내에 의존 관계가 복잡해졌고요.\n\n그러자 순환 참조와 같은 문제가 발생하기도 했어요. 전반적인 모듈 구조도 이해하기에 너무 어려워졌습니다. \n\n처음에는 계층 구조를 유지하면서 대응을 해봤어요. 공통 기능을 다시 묶어서 하위 계층의 모듈로 분리하거나, 새로운 계층을 추가하여 공통 모듈을 추가로 분리하는 방식도 시도했고요.\n\n그런데 이렇게 하다 보니 지나치게 많은 계층이 생겨났어요. 적절한 계층 및 모듈 분리의 기준을 세우기도 애매해지더라고요.\n\n이대로는 안 되겠다. 다른 방법이 필요하다. \niOS 개발자 모두가 느끼기 시작했습니다.\n\nMicrofeatures 아키텍처는 Tuist가 소개한 모듈 구조예요. (Tuist는 iOS 프로젝트 관리 툴입니다.)\n\n크게 보면, Microfeatures 아키텍처는 아래와 같이 5개의 요소로 구성되어 있어요.\n\n\nFeature(Source)\n\nFeature의 실제 기능이 구현된 코드가 위치한 모듈이에요.\n\nInterface\n\nFeature에서 제공하는 기능에 대한 외부 인터페이스와 모델을 제공하는 모듈이에요.\n\nTesting\n\n단위 테스트나 Example 앱에서 사용될 코드와 Mock 데이터 등을 제공하는 모듈이에요.\n\nTests\n\n단위 테스트, UI 테스트 등이 위치한 모듈이에요.\n\nExample\n\nFeature의 기능을 간단히 체험해 볼 수 있는 작은 앱이에요.\n\n\n그래서 이 요소들을 가지고 하나의 서비스를 담당하던 모듈을 쪼개는 거예요.\n\n\n홈 서비스를 예로 들어볼까요?\n\n기존에 하나였던 Home 모듈을 이렇게 5개의 모듈로 나누게 되는 거예요.\n\nHome (Feature)\nHomeInterface (Interface)\nHomeTesting (Testing)\nHomeTests (Tests)\nHomeExample (Example)\n\n이것을 여러 서비스로 확장해 보면 이렇게 돼요.\n\nInterface 모듈에 있는 인터페이스를, Feature, Testing 모듈이 구현합니다. \n\nTests 모듈에 테스트를 작성하고요.\n\nExample 앱을 구성할 때는 Feature 혹은 Testing 모듈 중 필요한 것을 골라서 사용해요.\n\n\n이때 자체적으로 개발한 DI(Dependency Injection) Container를 사용해요. Interface 모듈에 대한 Feature 모듈의 구현을 주입하는 역할을 맡고 있죠.\n\nMicrofeatures 아키텍처 구조로 바뀌고 난 이후에는 뭐가 달라졌을까요?\n\n다른 서비스에서 Home 서비스의 코드를 필요로 할 때 Home 모듈을 직접 사용하지 않아요. 대신 HomeInterface 모듈을 사용하죠. HomeInterface에는 외부에 제공되는 인터페이스가 있어요. 이 Home의 기능을 사용할 때는 이 인터페이스를 씁니다.\n\n이렇게 하면 한 서비스가 다른 서비스의 코드를 사용하더라도, 같은 계층 (Feature ↔ Feature, Interface ↔ Interface) 내의 의존 관계가 생기지 않게 돼요.\n\n같은 계층 내에 의존 관계가 복잡해지는 문제를 해결했습니다.\n\n쉽고 멋있게 해결한 척했지만… 사실 Microfeatures 아키텍처를 도입하는 것은 꽤나 험난한 길이었어요.\n\n일단 작업량이 만만치 않았죠. 기존에 하나였던 모듈을 5개의 모듈로 분리해야 하는 작업인데, 기존의 모듈도 이미 수백 개였거든요.\n\n수많은 컨플릭이 발목을 잡았어요. 공통 모듈을 자주 건드릴 수밖에 없었고. 현재 작업 중인 모듈이 있고, 그 모듈이 의존하는 다른 모듈 분리 작업이 동시에 진행되었어요. 컨플릭이 자주 발생할 수밖에 없는 상황이었죠.\n\n현실적인 리소스의 문제도 있었고요. 토스에선 빠른 실험을 위해 ‘매주’ 앱 배포를 진행하는데요. 이런 환경에서 사일로 업무도 하고, 구조 개선을 위한 모듈 분리도 하는 건 쉽지 않은 일이었죠.\n\n\niOS 챕터에서는 작업량을 줄이기 위해서, Tuist에서 제공하는 Stencil 템플릿과 Tuist Scaffold 기능을 최대한 활용했어요. 토스 앱의 모듈 구조에 알맞게 Tuist extension 을 적절히 구현했습니다. 다양한 Template 을 만들어서 단 1줄의 코드로 새로운 모듈을 생성할 수 있도록 했죠.\n\n하지만 무엇보다도 iOS 챕터 전체가 모두 적극적으로 참여했던 게 도입을 해낼 수 있었던 가장 큰 이유예요. 기존 구조의 문제를 겪고 있던 분들이 도입의 필요성에 많이 공감해 주셨고요. 너 나 할 것 없이 담당하고 있던 기능들에 Microfeatures 아키텍처를 적용해 나갔어요. 담당자가 퇴사를 했다든지, 공통적으로 쓰는 모듈이라든지 그런 애-매한 모듈들도 있었는데요. 다들 본인 것처럼 적극적으로 나서주셨죠.\n\nMicrofeature 아키텍처의 장점은 이게 끝이 아닙니다.\n\n\nExample 앱이 있기 때문이죠!\n\nExample 앱은 필요한 기능만을 담은 별도의 미니 앱이라고 보시면 돼요. \n\n\nMicrofeature 아키텍처가 도입된 후로, 개발할 때 Example 앱을 적극 활용하고 있어요. 실제로 송금 Example 앱, 자동이체 Example 앱, 본인확인 Example 앱 등등 다양한 Example 앱이 있습니다.\n\nMicrofeature 아키텍처가 있다면 Example 앱을 만드는 건 어렵지 않아요. 구현을 확인해 보고 싶은 기능의 Feature 모듈을 사용하고요. 나머지 기능의 경우 Testing 모듈에 있는 Mock을 연결하면 되죠.\n\n아래 그림은 송금 Example 앱인데요. 실제 송금 결과 케이스들을 바로바로 볼 수 있도록 만들어놓았어요.\n\n\n특히 UI 개발을 할 때 무척 편리합니다. \n아까 말씀드린 것처럼, 토스 앱은 어마어마하게 큰 앱이거든요. Swift만 100만 줄이 넘고요. 모듈은 약 700개나 있고요. 그니까 빌드 시간이 엄청 길 수밖에 없어요.\n\n만약 토스 앱 전체를 빌드하고 나서, 수정한 화면이 어떻게 보이는지 확인해야 된다면? UI 수정 확인 한번 하려고 한참을 기다려야 합니다. \n\n빌드 할 때마다 수십 초씩 걸린다는 건 상당히 불편한 일이잖아요. 해보신 분들은 이게 얼마나 생산성을 떨어뜨리는지 아실 거예요.\n\nExample 앱은 이럴 때 빛을 발합니다. Example 앱은 토스 전체 앱 빌드보다 훨씬 빠르거든요. (무려 5배) 전체 앱이 아닌 일부분만을 빌드하기 때문이죠.\n\n\nExample을 하다 보면, 협업을 하는데도 굉장히 편리해요.\n\n토스 디자인 시스템(TDS)을 만드는 디자인 플랫폼 팀의 예시를 들어드릴게요.\n\nTDS에는 AnimateTop라는 컴포넌트가 있습니다. 말 그대로 애니메이션 효과가 들어있는 제목이에요. 그런데 이걸 코드로만 보면, 실제 느낌은 알기 어렵잖아요.\n\n그럴 때 ShowCaseExample 앱을 사용해요. AnimateTop이 다양한 속성을 적용했을 때 어떻게 보이는지 실제로 확인해 볼 수 있죠.\n\n\n개발을 하고 나면, Example 앱을 사내에서 배포할 수 있어요.\n\n복잡한 화면이나 애니메이션을 개발하다 보면 디자이너 분과 빌드 된 앱을 같이 확인하는 경우가 꽤 많아요. 중간중간 실제 화면을 확인해보기 위해 다른 팀원에게 앱을 빌드하여 보여주는 경우도 흔히 있고요.\n\n그럴 때 Example 앱을 사용하면, “00님, 이거 와서 봐주세요, 어때요?” 매번 여쭤볼 필요가 없어요. Example 앱 배포했습니다! 알려드리면 직접 받아서 확인하면 되거든요. 직접 사용하시는 PO나 디자이너 분들도 정말 편하다고 하시더라고요.\n\n\n디자인 플랫폼 팀에서는 새로운 인터랙션, 컴포넌트 등을 만드는 일이 많은데요. 이 Example 앱을 적극 활용해서 개발부터 QA까지 하고 있습니다.\n\n\n🔔 요약 정리\n앱의 코드 베이스가 커지고 복잡해질수록, 모듈 분리와 관리가 중요해진다.\n기존 토스 iOS 앱은 일반적인 계층 구조로 나눠서 모듈을 관리했다.\n하지만 앱 내 서비스가 계속 많아지면서, 같은 계층 내의 의존 관계가 너무 복잡해졌다.\n토스 iOS 챕터는 이 문제를 해결하기 위해 Microfeature 아키텍처를 도입했다.\nMicrofeature 아키텍처 도입은 작업량, 컨플릭, 리소스의 문제로 쉽지 않은 과제였지만, iOS 챕터 모두가 합심하여 결국 성공!\nMicrofeature 아키텍처를 도입하면서 Example 앱도 적극적으로 쓰게 되었다.\nExample 앱은 전체 앱보다 빌드가 5배 빨라서 개발 생산성이 올라가고, 사내 배포가 가능해서 협업에도 도움이 된다.","isDisplayingFeedback":true},{"id":22217,"updatedTime":"2023-08-22T19:07:30+09:00","createdTime":"2023-07-19T22:56:27+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"놀러오세요! 프론트엔드 다이빙 클럽","subtitle":"프론트엔드에 관한 깊은 이야기를 나눌 수 있는 오프라인 커뮤니티, 프론트엔드 다이빙 클럽을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/frontend-diving-club.jpg","videoUrl":null,"backgroundColor":null,"isFill":true,"imageAlt":"대화하는 사람들 일러스트레이션"},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/frontend-diving-club.jpg","backgroundColor":null,"isFill":true,"imageAlt":"대화하는 사람들 일러스트레이션"},"key":"frontend-diving-club","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-07-21T13:47:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22217,"title":null,"description":"‘프론트엔드 다이빙 클럽’(이하 프다클)은 프론트엔드에 관한 깊은 이야기를 나눌 수 있는 커뮤니티입니다.\n격달로 소규모 오프라인 모임을 개최하며, 한 번 이상 참석한 사람들은 프라이빗 슬랙에 가입하여 온라인으로도 소통을 이어갈 수 있습니다.","urlSlug":"frontend-diving-club","primaryKeyword":{"id":12550,"content":"커뮤니티","wordType":"SEO_KEYWORD"},"relatedKeywords":[],"tags":[]},"openGraph":{"title":"놀러오세요! 프론트엔드 다이빙 클럽","description":"안녕하세요, 토스 프론트엔드 개발자 진유림입니다. 저는 개발을 처음 배울 때부터 커뮤니티 안에서 성장해왔는데요. 9XD, GDG, Facebook Developer Circle등 다양한 온/오프라인 커뮤니티에서 각양각색의 개발자를 만나며 IT업계에 대한 애정을 키우고, 지식은 나눌수록 ...","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/toss-tech/frontend-diving-club.jpg","imageType":"썸네일 이미지"},"relatedPostConfig":null,"editor":{"id":752,"name":"진유림","slug":"yurim-jin","shortDescription":null,"description":"토스에서 알뜰폰 서비스를 개발하고 있습니다. 4대 통신사가 되는 그 날을 위해 허슬!","imageUrl":"https://static.toss.im/assets/toss-tech/yurim-jin.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"안녕하세요, 토스 프론트엔드 개발자 진유림입니다. \n\n저는 개발을 처음 배울 때부터 커뮤니티 안에서 성장해왔는데요. 9XD, GDG, Facebook Developer Circle등 다양한 온/오프라인 커뮤니티에서 각양각색의 개발자를 만나며 IT업계에 대한 애정을 키우고, 지식은 나눌수록 커진다는 것을 깨달았어요.\n\n그러나 코로나 이후로는 오프라인 모임이 중단되었고, 개발 이야기를 나눌 수 있는 사람들이 회사 내로 한정되어 버린 것이 아쉬웠어요. 그래서 시작했습니다, 다양한 회사와 다양한 연차의 개발자들이 모여 노하우를 나누는 프론트엔드 커뮤니티, ‘프론트엔드 다이빙 클럽’을요.\n\n\n프론트엔드 다이빙 클럽?\n커뮤니티 이름으로부터 유추할 수 있듯이, ‘프론트엔드 다이빙 클럽’(이하 프다클)은 프론트엔드에 관한 깊은 이야기를 나눌 수 있는 공간입니다.\n\n격월로 소규모 오프라인 모임을 개최하며, 한 번 이상 참석한 사람들은 프라이빗 슬랙에 가입하여 온라인으로도 소통을 이어갈 수 있습니다.\n\n\n\n\n각 모임마다 주제가 바뀌고, 해당 주제에 관심이 많은 분들이 참가하여 다양하고 깊은 의견을 들을 수 있는 게 특징입니다.\n\n지난 세 번의 모임은 다음과 같은 주제로 진행되었습니다:\n\n웹뷰 위에서 서비스 개발하기\n프론트엔드 자동화\n프론트엔드 일하는 방식/문화 공유\n지금까지 네이버, 유니크굿, 무신사, 아임포트, 오늘의집, 뱅크샐러드, 29cm, 카카오페이, 당근마켓, 우아한형제들, 두나무 등 30개 이상의 회사로부터 1년차부터 20년차까지 다양한 연차의 프론트엔드 개발자 분들이 참석하여 의견을 공유하였습니다. \n\n\n앞으로의 모임에서는 다음과 같은 주제를 기획하고 있습니다:\n\n프론트엔드 테스팅\n좋은 면접이란\n프론트엔드 커리어 패스\n이 주제들은 타 회사의 시각을 듣고 인사이트를 얼마나 많이 얻을 수 있는지를 기준으로 선택되고 있습니다.\n\n주제별 발표는 2세션 씩 진행하며, 다양한 회사의 관점을 짧지만 뾰족하게 접할 수 있는 시간으로 준비하고 있습니다. 발표자 신청은 모두가 할 수 있으니 관심 있는 분들의 신청 부탁 드려요(토스 프론트엔드 트위터https://twitter.com/TossFrontend에 공지).\n\n\n모임은 어떻게 진행되나요?\n\n금요일 7시, 역삼역 토스 오피스에서 진행되는 오프라인 모임은 다음과 같은 타임라인으로 진행됩니다.\n\n7:00 인트로\n설문조사로 응답해주신 관심 주제(e.g. 코드리뷰, 기술부채 관리 등)를 기반으로 미리 배치된 조(6명 규모)에 착석\n하와이 풍 음식 먹으며 조별 아이스 브레이킹\n7:30 첫 번째 발표\n세션 듣기 및 질의응답\n조별 토의 및 발표\n8:10 두 번째 발표\n세션 듣기 및 질의응답\n조별 토의 및 발표\n8:50 마무리 및 조 섞기 + 네트워킹\n\n발표를 듣고 그냥 돌아가는 것이 아니라 주제에 대해 활발히 토론하고 살아있는 인사이트를 얻을 수 있도록, 조별로 토론하는 시간을 많이 배치했습니다.\n\n주제에 대한 관심이 많은 분들이 참석하셔서 그런지, 아니면 네트워킹을 통해 친밀도가 높아져서 그런지 모든 발표에서 질문이 10~15개씩 나오는 것이 인상적이었습니다.\n\n\n참여자 후기\n발표자의 한 마디\n\nQ. 발표를 하며 얻어간 것이 있나요?\n\nA. 비슷한 고민을 회사 밖에서도 함께하는 동료 개발자들과 이야기하는 경험은 정말 귀하다고 느꼈어요. 무언가 만들거나 해결했지만 '이게 정말 좋은 방법일까'라는 고민이 남을 때가 있는데요. 프다클은 '이렇게 풀 수도 있구나', '이런 고민도 있구나'를 공유하면서 생각을 넓힐 수 있는 자리였습니다.\n\n\n참여자의 한 마디\n\nQ. 프다클에 매번 참여하는 이유는?\n\nA. 좋은 스피커분들의 발표를 다양한 분들과 같이 들으며 식견을 넓혀갈 수 있는 점, 다양한 회사의 프론트 개발자분들과 네트워킹을 할 수 있는 기회, 바빠서 자주 보지 못하는 지인과, 겸사겸사 좋은 자리에 함께 하는 것, 그리고 여러 멋진 분들을 보면서 더 자극받는 시간이 되기도!\n\n\n준비 위원회의 한 마디\n\nQ. 어떤 분들이 프다클에 참여하시면 좋을까요?\n\nA. 다이빙 클럽은 컨퍼런스 보다는 토론의 장에 가깝습니다. 지식과 경험을 공유하는 것에서 의미와 가치를 느끼시는 분들을 환영해요. 발표를 듣고 자신의 현업에서 적용하는 것 뿐 아니라, 관련해서 본인의 경험들을 적극적으로 나눠주시고 다른 분들의 경험을 경청해주시는 분들께서 참여해 주시기를 기대하고 있어요. \n\n어떻게 참가할 수 있나요?\n프다클 커뮤니티는 초대 기반으로 발전해오고 있습니다. 매 모임마다 슬랙에 가입된 기존 멤버 대상으로 티켓을 20장씩 제공하고(선착순 10명, 추첨 10명), 이 분들이 지인을 동행하여 총 40명의 사람들이 모이게 됩니다.\n\n발표자 신청도 프다클에 참여할 수 있는 또 다른 방법입니다. 발표자 신청 폼은 토스 프론트엔드 트위터(https://twitter.com/TossFrontend) 에 올라갈 예정이니, 참여 원하시는 분들은 구독해주세요. \n\n초대 기반인지라 커뮤니티 확장이 느리다는 아쉬움이 있긴 하지만, 그래도 해당 주제에 진정으로 관심이 있는 분들이 모이게 되어서 오프라인에서도, 온라인에서도 깊은 토론을 할 수 있다는 장점이 있습니다.\n\n프다클 합류를 희망하신다면, 구글폼을 통해 간단한 경력 정보와 함께 자기소개를 남겨주세요. 남겨주신 정보를 토대로, 매 회차 모임의 방향성에 따라 함께할 분을 선별하여 초대권을 보내드릴게요.\n\n올 해 안에는 더 큰 규모의 공개 모임을 진행할 계획도 있습니다. 기대해주세요!","isDisplayingFeedback":true},{"id":21527,"updatedTime":"2023-05-14T19:58:31+09:00","createdTime":"2023-05-02T15:02:08+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"Node.js url.parse() 취약점 컨트리뷰션","subtitle":"토스 보안기술팀은 안전한 금융 서비스를 제공하기 위한 연구를 수행하고 있어요.\n많은 서비스에서 사용되고 있는 Node.js의 취약점을 분석하고 안전하게 패치될 수 있도록 기여했던 과정을 소개드려요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/node%20js-security.png","videoUrl":null,"backgroundColor":null,"isFill":true,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/node%20js-security.png","backgroundColor":null,"isFill":true,"imageAlt":null},"key":"nodejs-security-contribution","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-05-12T17:00:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21527,"title":null,"description":"Node.js Built-in API 중 하나인 url.parse()의 취약점을 발견하고 안전한 코드로 패치될 수 있도록 컨트리뷰션 했던 과정을 소개드립니다.","urlSlug":"nodejs-security-contribution","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"Node.js url.parse() 취약점 컨트리뷰션","description":"Node.js Built-in API 중 하나인 url.parse()의 취약점을 발견하고 안전한 코드로 패치될 수 있도록 컨트리뷰션 했던 과정을 소개드립니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/toss-tech/node%20js-security.png","imageType":"커버 이미지"},"relatedPostConfig":null,"editor":{"id":595,"name":"표상영","slug":null,"shortDescription":"Security Researcher","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/pyozzi.jpeg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스 보안기술팀(Security Tech)에서는 개발 서비스 외에도 서비스에서 사용하고 있는 프레임워크나 Third-party에 대한 취약점 연구도 수행하고 있습니다.\n\n이번 아티클은 Node.js의 Built-in API 중 하나인 url.parse() 의 Hostname Spoofing 취약점을 발견하고 안전한 코드로 패치될 수 있도록 컨트리뷰션 했던 과정을 다뤄보려 합니다.\n\n\nhttps://github.com/nodejs/node/pull/45011\nurl.parse() 취약점 발생 원인\nNode.js의 url.parse()는 WHATWG URL API 가 아닌 자체적인 스펙으로 개발된 함수입니다.\n\nWHATWG URL API\nWHATWG는 Web Hypertext Application Technology Working Group의 약어로 국제 웹 표준화 그룹을 뜻하고, WHATWG URL API 는 국제 표준 스펙으로 URL(Uniform Resource Locator)을 다룰 수 있도록 제공되는 API를 말합니다.  \nWHATWG URL API 가 등장하기 전, URL 파싱 기능을 제공하기 위해 자체적으로 개발된 함수로 보이는데요. 표준 스펙이 아닌 자체적으로 해석하다보니 다른 파서(parser)들과 해석 결과가 달라지게 되고, 이 때문에 의도치 않은 코드흐름이 발생하게 됩니다.\n\nurl.parse()에서는 hostname을 잘못된 방식으로 파싱하여 취약점이 발생하게 되었는데요. Node.js의 url라이브러리는 여기에서 확인할 수 있고, 취약점이 발생했던 부분은 아래의 getHostname() 함수입니다.\n\n\ngetHostname() 함수의 로직은 단순합니다. 반복문을 통해 전달된 값의 문자를 하나씩 가져온 뒤, 조건에 맞는 값을 구하는 로직인데요. \n\n여기서 isValid 라는 특정 조건을 정의해두고, 현재 문자가 조건에 충족되지 않으면 해당 문자의 앞 인덱스까지 slice하여 그 문자열을 hostname으로 설정합니다. 그리고 그 뒤 문자들은 앞에 /를 붙여 경로(path)로 사용합니다.\n\n\nisValid 의 조건을 정규식으로 표현해보면 /[a-zA-Z0-9.-+_]/u 와 같은데요. *ECMAScript기준 \n“hostname으로는 저 범위의 문자들만 올 수 있어!” 라고 설정해둔 것이죠.\n\n\n디버깅 코드\ngetHostname() 함수에 디버깅 코드를 추가하고 확인해보면, 실제로 isValid 범위 밖 문자일 경우 hostname 파싱을 중단하고, 나머지 문자열은 앞에 / 를 붙여 경로(path)로 사용하는 것을 볼 수 있습니다.\n\n때문에, http://EVIL_DOMAIN*.toss.im 의 hostname이 EVIL_DOMAIN 이 되어버리고, Hostname Spoofing 취약점이 발생하게 됩니다.\n\nHostname Spoofing\nHostname Spoofing은 시스템을 대상으로 Hostname을 속이는 해킹 기법을 말합니다.\nSpoofing은 ‘속이다’라는 사전적 의미를 갖고 있으며, 시스템을 대상으로 어떠한 정보를 속이는 해킹 기법을 Spoofing이라고 합니다.\n\nWHATWG URL API ↔ url.parse() 비교\n\nWHATWG URL API 의 hostname 파싱 결과를 보면 evil_domain*.toss.im 으로 Node.js와 다른 것을 확인할 수 있습니다.\n\nReserved Characters\nNode.js에서 이렇게 파싱하는 이유는 RFC(Request For Comments) 문서를 보면 알 수 있습니다. RFC 3986는 Standard URI Syntax 를 정의해둔 문서인데요.\n\n문서의 여러 항목 중 아래 2.2 Reserved Characters를 보면 그 이유를 찾을 수 있습니다.\n\n\nhttps://www.rfc-editor.org/rfc/rfc3986#section-2.2\nReserved Characters 는 URI를 구성할 수 있는 문자 중 특수 목적을 갖고 사용할 문자들을 미리 예약해둔 것인데요. 예를 들면 port 구분자로 사용되는 :(colon) , path 구분자로 사용되는 /(slash) 가 예약된 문자인 것이죠. \n\n따라서, *, !, $, :, # 와 같은 문자들은 hostname으로 사용할 수 없습니다.\n\n그 아래를 보면 사용해도 되는 Unreserved Characters 도 정의되어 있습니다.\n\n\nhttps://www.rfc-editor.org/rfc/rfc3986#section-2.3\n정의된 문자들을 보면 위에서 확인한 url.parse()의 isValid 조건과 비슷한 것을 알 수 있죠.\n\n\n취약점 악용 시나리오\n이러한 WHATWG URL API ↔ url.parse() 간 파싱 결과 차이는 서비스의 도메인 검증로직을 우회하는데 악용할 수 있습니다.\n\n\n위 코드는 사용자에게 파라미터로 url을 입력받고, 입력된 url 검증 후 fetch하는 간단한 웹서버입니다.\n\nnew URL(url).hostname 으로 hostname을 가져온 뒤, hostname이 toss.im 과 일치하거나 .toss.im 으로 끝나는지 확인합니다. 일반적으로 도메인을 검증할 때 사용하는 방식이죠.\n\n\n파라미터로 입력한 url과 node-fetch에서 실제로 요청한 url 콘솔 출력\n이 경우, 위 그림처럼 url파라미터 값을 https://google.com!.toss.im 로 입력하면 검증 로직이 우회되고 서버는 https://google.com/!.toss.im/ 으로 요청하게 되는데요. 그 이유는 node-fetch 라이브러리 코드를 보면 알 수 있습니다.\n\n\n위 코드는 node-fetch 라이브러리에서 url을 파싱하는 코드 부분입니다. 중요한 부분은 주석으로 번호 표시를 해두었는데요.\n\n[1]: Node.js의 url 라이브러리를 가져옵니다.\n[2]: Node.js의 url.parse()함수를 parse_url 변수에 저장합니다.\n[3]: 파싱할 url이 정규식 조건과 일치하면 WHATWG URL API 로 파싱합니다.\n[4]: 그 외에 경우는 Node.js의 url.parse()함수로 파싱합니다.\nurl 파라미터로 입력한 https://google.com!.toss.im 은 [3] 정규식 조건에 충족되지 않으니, [4] url.parse()로 hostname이 파싱되었고 Node.js의 잘못된 파싱 방식으로 인해 https://google.com/*.toss.im 으로 요청하게 된 것입니다.\n\n이처럼 서비스 서버의 검증 로직을 우회하고 공격자가 원하는 임의의 도메인으로 요청하도록 하는 공격기법을 SSRF(Server Side Request Forgery) 라고 하는데요. 공격자는 SSRF 공격을 통해 외부에 공개되어 있지 않은 서비스 내부 망에 접근하여 민감한 정보들을 탈취하거나, 관리자 기능들을 악용할 수 있습니다.\n\n\n취약점 패치 컨트리뷰션\n화이트해커 문화에는 취약점을 제보하고 그에 따른 보상을 지급하는 버그바운티(Bug Bounty) 라는 프로그램이 존재합니다. 보안에 중요한 가치를 두고 있는 기업들이 독립적으로 운영하기도 하고, 국가기관에서 운영하기도 하는데요.\n\n\n토스 버그바운티 챌린지\n토스에서도 작년에 자체적으로 토스 버그바운티 챌린지 (https://bugbounty.toss.im)를 진행한 바 있고, 국가 기관에서는 한국인터넷진흥원(KISA)이 국내 소프트웨어에 대한 취약점을 제보받고 있습니다.\n\n\nNode.js url.parse() 취약점 제보\n저 또한 버그바운티 프로그램을 통해 Node.js 측에 취약점을 제보하였고, 취약점을 알맞게 패치할 수 있는 방안들에 대해 논의하면서 컨트리뷰션을 진행하였는데요.\n\n\n기존에 Unreserved Characters 를 화이트리스트로 처리하는 방식 대신 Reserved Characters 를 블랙리스트로 처리하는 방식으로 변경하여 isValid 조건을 좀 더 엄격하게 가져가도록 패치하였습니다.\n\n\nhttps://github.com/nodejs/node/pull/45011 에서 패치된 코드를 확인해 볼 수 있고, 해당 Pull Request는 v19.1.0, v18.13.0 에서 적용되었습니다.\n\n\nhttps://nodejs.org/api/url.html#urlparseurlstring-parsequerystring-slashesdenotehost\n추가로 기존에 Legacy 상태였던 url.parse()함수를 Deprecated 로 변경하였는데요. --pending-deprecation 옵션을 사용하는 경우, 런타임에서 Deprecated 함수임을 경고하도록 패치되었습니다.\n\n이 글을 읽으신 분들도 Node.js를 사용하고 계시다면, 취약점이 존재하는 버전을 사용 중인지 확인해보시는 것을 권장드립니다. *취약점은 v19.1.0, v18.13.0 에서 패치되었습니다.\n\n그리고 저희 보안기술팀(Security Tech)에서 이와 같은 보안 연구를 같이 해나갈 동료분들을 찾고 있습니다. 관심이 있으시다면 언제든지 문을 두드려 주세요!","isDisplayingFeedback":true},{"id":21001,"updatedTime":"2023-04-17T14:07:24+09:00","createdTime":"2023-04-12T16:00:36+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"Spring Boot Actuator의 헬스체크 살펴보기","subtitle":"서버의 상태를 알려주는 헬스 체크에 대해 알고 계시나요? 단순히 200 OK만 내려주겠거니 하고 별로 신경을 안 쓰고 계셨나요? 해당 포스트에서는 Spring Boot Actuaor가 제공해주는 헬스 체크는 어떤 식으로 서버의 상태를 점검하는지, 어떤 부분을 주의하며 사용해야하는지 알아봅니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/illusts-content/img-tech-cover.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/illusts-content/img-tech-cover.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"how-to-work-health-check-in-spring-boot-actuator","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-04-01T15:38:57+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21001,"title":null,"description":"뭐든 알고 쓰는 게 참 중요한 것 같습니다. 단순히 “지금은 잘 돌아가니까 문제 없다”는 접근은 문제가 발생하기 전까지는 문제를 방치하기 마련입니다.사용하는 ...","urlSlug":"how-to-work-health-check-in-spring-boot-actuator","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"Spring Boot Actuator의 헬스체크 살펴보기","description":"서버의 상태를 알려주는 헬스 체크에 대해 알고 계시나요? 단순히 200 OK만 내려주겠거니 하고 별로 신경을 안 쓰고 계셨나요? 해당 포스트에서는 Spring Boot Actuaor가 제공해주는 헬스 체크는 어떤 식으로 서버의 상태를 점검하는지, 어떤 부분을 주의하며 사용해야하는지 알아봅니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/illusts-content/img-tech-cover.png","imageType":"직접입력"},"relatedPostConfig":{"id":2355,"relatedPosts":[{"id":21003,"updatedTime":"2023-04-18T15:33:20+09:00","createdTime":"2023-04-12T16:00:46+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"Kotlin으로 DSL 만들기: 반복적이고 지루한 REST Docs 벗어나기","subtitle":"토스페이먼츠에서는 API docs를 REST Docs를 사용해서 작성할 수 있도록 권장하고 있습니다. 이 글에서는 DSL을 통해서 반복적인 REST Docs 테스트 코드 작성을 줄일 수 있는 방법을 알아봅니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/04/techblog-08-rest-docs.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"Kotlin으로 DSL 만들기: 반복적이고 지루한 REST Docs 벗어나기"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/04/techblog-08-rest-docs.png","backgroundColor":null,"isFill":false,"imageAlt":"Kotlin으로 DSL 만들기: 반복적이고 지루한 REST Docs 벗어나기"},"key":"kotlin-dsl-restdocs","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-04-11T05:24:00+09:00","commentBoard":null,"disclaimer":null},{"id":21010,"updatedTime":"2023-04-12T17:25:54+09:00","createdTime":"2023-04-12T16:01:32+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"에러 핸들링을 다른 클래스에게 위임하기 (Kotlin 100% 활용)","subtitle":"Kotlin의 Result로 MSA에서 에러가 전파되지 않는 안전한 환경을 만드는 방법을 알아봅니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/05/techblog-09-error-handling.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"에러 핸들링을 다른 클래스에게 위임하기 (Kotlin 100% 활용)"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/05/techblog-09-error-handling.png","backgroundColor":null,"isFill":false,"imageAlt":"에러 핸들링을 다른 클래스에게 위임하기 (Kotlin 100% 활용)"},"key":"kotlin-result","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-05-14T23:38:16+09:00","commentBoard":null,"disclaimer":null},{"id":21011,"updatedTime":"2023-04-12T17:25:58+09:00","createdTime":"2023-04-12T16:01:38+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"tosspayments-restdocs: 선언형 문서 작성 라이브러리","subtitle":"REST Docs 를 최소한의 코드로 작성하면서 변화에도 더 유연하게 대처할 수 있는 tosspayments-restdocs 라이브러리와, 라이브러리에 녹인 기술들을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/00017-3291509353.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/00017-3291509353.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"tosspayments-restdocs","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-22T14:29:51+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":558,"name":"양권성","slug":"gwonsung-yang","shortDescription":"Server Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/gwonsung-yang.jpeg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":2,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"뭐든 알고 쓰는 게 참 중요한 것 같습니다. 단순히 “지금은 잘 돌아가니까 문제 없다”는 접근은 문제가 발생하기 전까지는 문제를 방치하기 마련입니다.\n\n사용하는 기술이나 구조에 대해 끊임없이 질문을 던지고 탐구하는 과정은 토스팀 코어밸류 3.0 중 하나인 Question Every Assumption, 모든 기본 가정에 근원적 물음을 제기한다에도 부합하는 사례인것 같습니다. 이번 포스트에서는 제가 개발 과정에서 헬스 체크를 별다른 생각 없이 Spring Boot Actuator가 제공하는 기능을 사용하면서 겪은 이슈를 간략하게 설명해보겠습니다.\n\n들어가기에 앞서\n이 포스트는 작성 시점 기준에서 최신 Spring Boot GA(General Availability) 버전인 3.0.5 버전을 기준으로 설명합니다. 해당 버전의 하위/상위 버전에서는 기능이 미묘하게 다르게 동작할 수 있습니다. 2.x 버전에서도 큰 맥락에서는 동일한 동작을 보장하리라 추측되지만 본인이 사용하는 버전에 해당하는 자세한 내용을 찾아보시길 권장합니다.\n\n헬스 체크란?\n서비스의 고가용성(HA, High Availability), 고성능을 위한 부하 분산 등의 이유로 우리는 서버의 이중화(혹은 그 이상)를 하고, 앞에서 어떤 서버로 요청을 보낼지 라우팅 역할을 하는 로드 밸런서를 둡니다.\n\n로드 밸런서가 적절히 부하를 분산하여 A/B 서버 중 한 대에게 클라이언트의 요청을 보냅니다.\n\n\n하지만 아래와 같이 서버 한 대가 서비스 불가 상태라면 어떻게 해야할까요? 해당 서버에 요청이 들어가야할까요?\n\n\n혹은 대량의 트래픽이 들어올 것을 대비하는 등등의 이유로 서버를 증설해야 하는데 해당 서버가 관련된 소스코드를 로딩하고 있다면 어떻게 해야할까요? 이 때도 마찬가지로 해당 서버에 요청이 들어가야할까요?\n\n\n두 케이스 모두 해당 서버로 요청을 보내면 안 됩니다. 정상적인 서비스가 불가능해서 클라이언트의 요청을 수행할 수 없습니다. 장애를 유발하거나 해당 서버의 부하를 크게 증가시켜 오히려 장애를 더 심각하게 만들 수도 있습니다.\n\n따라서 로드 밸런서에서는 각 서버의 헬스 체크 API를 호출해서 해당 서버가 현재 서비스 가능한 상태인지 아닌지 주기적으로 점검합니다.\n\n헬스 체크 API 경로는 커스텀하게 설정 가능합니다.\n\n\n헬스 체크에서 서버에 문제가 발견되면 로드 밸런서는 해당 서버로 요청을 보내지 않게 됩니다.\n\n\n\n헬스 체크는 정상적으로 서비스가 가능한 서버에만 트래픽을 보내서 서비스의 고가용성을 확보하는 데 도움됩니다.\n\nSpring Boot Actuator의 헬스 체크\nSpring Boot Acutator를 의존성으로 추가하면 기본적으로 헬스 체크 엔드포인트가 활성화됩니다.\n\n\nSpring Boot 3.x 기준으로 헬스 체크 엔드포인트는 /actuator/health이고, 설정을 바꾸지 않아도 해당 엔드포인트로 접속하면 HTTP 200 상태 코드와 해당 서버의 상태가 Response Body로 응답됩니다.\n\n크롬 개발자 도구로 확인해본 Spring Boot Actuator의 헬스 체크 결과\n\n\nSpring Boot Actuator는 어떠 기준으로 서버의 헬스 체크를 할까요? 확인하려면 Health Information 문서를 살펴보면 됩니다. 해당 정보는 보안에 민감한 요소가 들어있을 수 있어서 퍼블릭하게 접근이 가능해서는 안 됩니다. 저는 로컬에서 간단하게 확인만 해보는 목적으로 application.yml(application.properties) 파일에 management.endpoint.health.show-details: always로 설정한 후에 다시 헬스 체크 결과를 확인했습니다.\n\n\nAuto-configured HealthIndicators(WebMVC 전용)와 Auto-configured ReactiveHealthIndicators(Webflux 전용)에 나열된 HealthIndicator(혹은 ReactiveHealthIndicator)는 Spring Boot Auto Configuration에 의해 자동으로 활성화되는데 관련된 의존성이 존재할 때만 활성화 되는 것들도 있습니다. 예를 들어, DataSourceHealthIndicator는 DataSourceHealthContributorAutoConfiguration에 의해 설정되는데 Spring Data JPA 같이 DataSource를 사용하는 의존성을 추가했을 때 활성화됩니다.\n\n그럼 코드레벨에서 각 (Reactive)HealthIndicator들이 어떻게 사용되는지 보겠습니다.\n\n\n먼저 /actuator/health에 접속한 뒤에 브레이크 포인트를 걸고 디버그 모드로 살펴보면 HealthEndpointSupport 클래스의 getAggregateContribution 메서드에서 각 HealthContributor(혹은 ReactiveHealthContributor)를 순회하면서 헬스 체크하는 코드를 보실 수 있습니다. (헬스 체크하는 코드에 있는 HealthIndicator 인터페이스는 HealthContributor 인터페이스를 상속받았습니다.)\n\n\nHealthEndpointSupport 클래스의 getCompositeHealth 메서드에서는 각 HealthIndicator로부터 수집한 상태를 바탕으로 현재 서버의 상태를 진단합니다.\n\n\n\nSimpleStatusAggregator의 getAggregateStatus 메서드에서는 각 상태를 수집해서 하나의 Status로 반환하고 있는데 이 때 StatusComparator가 사용됩니다.\n\n\n이 때 가장 중요한 것은 Status의 순서인데 SimpleStatusAggragtor의 static 생성자 블럭을 보게되면 위와 같은 순서로 추가하고 있고,\n\n\n별도의 순서를 주지 않은 기본 생성자는 defaultOrder에 추가한 순서를 사용하는 것을 볼 수 있습니다.\n\n\ngetAggregateStatus는 Status 중에 가장 순서가 빠른(오름차순) 것 하나를 반환하게 되어있기 때문에 만약에 Down을 반환한 HealthIndicator가 하나라도 존재하면 서비스의 상태를 Down으로 생각해서 503을 반환하게 됩니다.\n\n헬스 체크에서 조심해야 하는 점\nSpring Boot Actuator 헬스 체크의 동작원리를 잘 모르고 사용하면 일어날 수 있는 문제를 설명하겠습니다.\n\n1. 의도치 않은 장애 발생\n\n각 서버에서는 서비스를 제공하는 서비스 DB와 데이터를 분석하는 로그 DB가 있다고 가정하겠습니다. 그리고 로그 DB에 적재하는 작업은 비동기로 별도의 스레드에서 처리하도록 작업을 해놨다고 가정하겠습니다. 로그 데이터 저장이 불가능하더라도 실시간 서비스에는 문제가 없도록 하기 위해서죠.\n\n이 때 만약 로그 DB에 작업을 해야해서 순단이 발생하거나 접속에 문제가 생긴다면 어떻게 될까요? 아래 정답을 확인하기 전에 1분 동안 한 번 생각해보시길 바랍니다.\n\n\n위에 Spring Boot Actuator의 헬스 체크는 여러 HealthIndicator가 수집한 상태를 토대로 서비스의 상태를 판단한다고 말씀드렸습니다. 그 순서를 차근차근 설명해보겠습니다.\n\nRoutingDataSourceHealthContributor에 의해 여러 DataSource의 헬스를 체크합니다.\nDataSourceHealthIndicator에 의해 서비스 DB의 상태를 체크했을 때는 UP이 반환됩니다.\nDataSourceHealthIndicator에 의해 로그 DB의 상태를 체크했을 때는 DOWN이 반환됩니다.\n수집한 상태들은 SimpleStatusAggregator에 의해 서비스 상태를 판단하게 되는데 아무런 순서 설정을 하지 않았으면 DOWN인 게 하나라도 있다면 DOWN이 반환됩니다.\n서비스의 상태가 DOWN(503)으로 판단됐기 때문에 로드 밸런서에서는 서버로 트래픽을 보내지 않게 됩니다.\n서비스 DB에 문제가 없음에도 불구하고 클라이언트의 요청은 처리되지 않고 장애가 발생합니다.\n우리는 분명 최대한 높은 가용성을 보장하기 위해 로그 DB의 장애가 전파되지 않도록 격리했음에도 불구하고 장애가 발생할 수 있습니다. 이를 해결하기 위해서는 아래와 같은 방법 등등이 있습니다.\n\nSpring Boot Actuator의 헬스 체크가 아닌 직접 헬스 체크 API를 구현할 수도 있습니다.\nHealthIndicator 중에 헬스 체크에 영향을 끼치지 않길 희망하는 것들은 비활성화 시키는 방법도 있습니다. (RDB를 예로 들자면 management.health.db.enabled: false(기본값 true)로 설정한다거나)\n문제가 되는 HealthIndicator 빈을 직접 생성해서 Auto Configuration의 동작을 오버라이딩 하는 방법 등등이 있습니다.\n다만 헬스 체크에 이런 저런 로직들이 들어간다는 것은 일반적으로 예측 가능하지 못할 수 있으므로 팀 내에 꼭 공유가 잘 되어야할 것입니다.\n\n2. 트러블 슈팅의 지연\n비슷한 상황으로, 예전에 API 서버에서 외부 의존성 중에 ES만 죽었는데, API 서버가 죽었다고 판단돼서 DOWN이 된적이 있었어요. 헬스 체크에서 detail 옵션을 키면, 상세하게 쭉 나오더라고요. 당시에 LB 통해서 접근이 안 됐는데, WAS는 개별로 접근했을 때는 문제가 없어 보여서 트러블 슈팅이 늦어졌었습니다.\n이는 실제 사내에서 비슷한 상황이 발생했을 때 트러블 슈팅이 지연된 사례입니다. Spring Boot Actuator 헬스체크의 동작원리를 정확히 이해했다면 ES(Elasticsearch) 서버가 죽었을 때 해당 서버의 헬스체크도 같이 죽게 된다는 걸 예측할 수 있습니다. (ElasticsearchRestClientHealthIndicator 혹은 ElasticsearchReactiveHealthIndicator가 ES 서버의 헬스체크를 해서 헬스체크 API 응답에 전체적으로 영향을 끼치기 때문에)\n\n하지만 헬스체크의 동작원리를 잘 모르면 우리가 장애를 격리했다고 생각한 시스템(위의 상황에서는 ES)에만 문제가 있는데 왜 장애가 발생하는지, 왜 도메인을 통해서 접근하면 접근이 안 되는지 상황 파악이 안 될 수 있습니다. 서버는 정상적으로 살아있고 부하도 없는 상황이라면 헬스 체크 API를 호출할 생각도 못 하고, 로드 밸런서의 버그인지부터 의심을 할 수도 있습니다. 이렇게 엉뚱한 포인트를 의심하게 되면 장애 상황은 계속 되고, 서버를 재시작해도 근본적인 문제를 해결(위 상황에서는 ES 서버의 복구)하기 전까지는 여전히 헬스 체크에 실패할테니 장시간 장애가 지속될 수도 있습니다.\n\n결국 각 서버 인스턴스마다 직접 헬스 체크 API를 호출해서 정상 응답을 받는지 확인해봐야하는데 여기까지 사고의 흐름이 다다르는데 너무 많은 시간 소요와 불필요한 리소스 낭비들을 초래하게 됩니다.\n\n마치며\n평상시에는 헬스 체크하면 그냥 200 OK만 응답하는 정말 심플한 API 수준으로만 생각하고 큰 신경도 쓰지 않았습니다. 근데 사소한 것에 한 번 데인 뒤로부터는 개발자가 왜 호기심이 많아야하는지 한 번 더 깨닫게 되었습니다. 그냥 단순히 돌아만가는 코드가 아닌 이 코드가 왜 그렇게 돌아가는지, 우리가 왜 이 기술을 선택하게 된 것인지, 끊임없이 고민하고 탐구하기 위해서는 강력한 호기심이 동기부여가 되기 때문입니다. 이러한 고민을 미리했다면 장애 상황을 미연에 방지할 수 있고, 장애 발생 이후에라도 이슈 분석을 통해 트러블 슈팅 능력도 크게 향상된다는 것을 다시 한번 깨닫게 되는 소중한 경험이었습니다.\n\n참고 링크\nSpring Boot Actuator Docs\nNHN Forward spring-boot-actuator documentation","isDisplayingFeedback":true},{"id":21006,"updatedTime":"2023-04-12T17:25:58+09:00","createdTime":"2023-04-12T16:01:07+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"ESLint와 AST로 코드 퀄리티 높이기","subtitle":"ESLint와 AST로 토스에서 코드 퀄리티를 높인 방법에 대해 소개드려요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/center.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/center.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"improving-code-quality-via-eslint-and-ast","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-31T15:47:53+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21006,"title":null,"description":"일관적인 코딩 컨벤션을 가지면 코드를 읽기 쉬워지고, 안티패턴을 방지할 수 있습니다. 결과로 버그도 줄고, 코드를 쉽게 유지보수할 수 있죠.하지만 이것을 사람이 직접 적용하는 것은 한계가 있기 때문에, 여러 가지 정적 분석 도구를 활용하게 됩니다. JavaScript/TypeScript...","urlSlug":"improving-code-quality-via-eslint-and-ast","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"ESLint와 AST로 코드 퀄리티 높이기","description":"ESLint와 AST로 토스에서 코드 퀄리티를 높인 방법에 대해 소개드려요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://og.toss.tech?title=ESLint%EC%99%80%20AST%EB%A1%9C%0D%0A%EC%BD%94%EB%93%9C%20%ED%80%84%EB%A6%AC%ED%8B%B0%20%EB%86%92%EC%9D%B4%EA%B8%B0&imageUrl=https%3A%2F%2Fstatic.toss.im%2Fassets%2Ftoss-tech%2Fright.png&v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2354,"relatedPosts":[{"id":21014,"updatedTime":"2023-04-12T17:25:54+09:00","createdTime":"2023-04-12T16:02:11+09:00","categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"JSCodeShift로 기술 부채 청산하기","subtitle":"기술 부채는 개발할수록 쌓여만 갑니다. 프론트엔드 챕터가 JSCodeShift를 이용하여 순식간에 100개 서비스의 기술 부채를 해결한 경험을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/05/techblog-03-jscodeshift.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"JSCodeShift로 기술 부채 청산하기"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/05/techblog-03-jscodeshift.png","backgroundColor":null,"isFill":false,"imageAlt":"JSCodeShift로 기술 부채 청산하기"},"key":"jscodeshift","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2021-05-04T17:16:00+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":579,"name":"전성","slug":"sung-jeon","shortDescription":"Frontend Platform Engineer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/sung-jeon.jpeg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"코딩 컨벤션을 일관적으로 유지하기\n일관적인 코딩 컨벤션을 가지면 코드를 읽기 쉬워지고, 안티패턴을 방지할 수 있습니다. 결과로 버그도 줄고, 코드를 쉽게 유지보수할 수 있죠.\n\n하지만 이것을 사람이 직접 적용하는 것은 한계가 있기 때문에, 여러 가지 정적 분석 도구를 활용하게 됩니다. JavaScript/TypeScript 코드베이스에서는 주로 ESLint를 통해 컨벤션과 맞지 않는 코드를 사전에 감지하게 되는데요. 이러한 정적 분석 도구를 이용하게 되면 코드 리뷰 등 사람이 직접 읽지 않아도 컨벤션과 다른 부분을 기계적으로 잡아낼 수 있습니다.\n\n이미 만들어진 규칙에서 오는 한계\nESLint에서는 생태계 내 다양한 플러그인 등을 통해 많은 수의 자주 사용되는 코딩 컨벤션을 커버할 수 있습니다. 하지만 우리 회사의 컨벤션에 맞는 규칙이 없다면 어떨까요? 조직이 커지고 요구 사항이 변화하게 되면서 커뮤니티에서 만들어진 규칙만으로는 조직 내 사용례에 정확히 부합하지 않는 경우가 생깁니다. 사내 라이브러리 내 사용 방식에 대한 컨벤션을 정의하거나, 조직 내 컨벤션과 커뮤니티에서 통용되는 컨벤션이 다소 다를 수도 있죠.\n\n예를 들어 토스에서는 SSR을 통해 서버 사이드에서 React 렌더링을 한 뒤 애플리케이션에 제공해서 로딩 속도를 높이고 있는데요, 이로 인해 브라우저 환경에서 작동하는 코드가 서버 사이드에서 실행되면서 의도치 않은 버그를 유발하는 케이스가 있습니다. 이러한 경우 미리 브라우저에서 호환되지 않는 코드를 감지하여 사전에 오류를 예방할 수 있다면 큰 도움이 되겠죠.\n\n린터는 어떻게 규칙을 적용할까?\n이러한 제약 사항을 해결하기 위해서는 우리만의 ESLint 규칙을 정의할 수 있어야 합니다. 그런데 ESLint는 어떻게 코드에 대한 규칙을 만들고 적용하고 있을까요?\n\n예를 들어서, Production 환경에서 로그가 함부로 찍히지 않도록 console.log 사용을 제한하는 규칙을 만드는 상황을 생각합시다.\n\n간단하게 정규식으로 구현해보면 이런 형식이 될 것입니다.\n\n\n하지만 이 방법은 생각했던 만큼 잘 작동하지 않습니다.\n\n\n예를 들어서, 이 코드에서 console.log가 문자열 안에 있는지도 알 수 없습니다.\n\n\n\n주석 안에 있는지도 알 수 없죠.\n\n\n이러한 작은 케이스들을 하나하나 대응할 수도 있지만, ESLint는 좀 더 강력한 방법을 사용합니다.\n\n\nAST에서 원하는 정보 찾아내기\nESLint는 Abstract Syntax Tree(AST)를 이용해서 규칙을 정의하고 적용합니다.\n\nAST는 소스 코드를 읽어낸 뒤 각 코드에서 구문 정보를 정리하여 나타낸 트리 형태의 자료 구조입니다. 예를 들어서, console.log 함수 호출과, 문자열이나 주석 속의 console.log 를 구별할 수 있게 해 줍니다.\n\nAST의 상세한 구조는 파서마다 약간의 차이가 있지만, AST Explorer라는 도구를 사용하면 소스 코드를 넣었을 때 어떤 AST가 나오는 지를 쉽게 확인할 수 있습니다. 일례로 console.log() 을 acorn이라고 하는 파서에서 파싱을 시도하면 이런 AST를 얻을 수 있습니다.\n\n\n\n이와 다르게, 문자열에 포함되어 있는 console.log() 의 파싱을 시도하면 이런 AST를 얻을 수 있습니다.\n\n\n함수를 호출하는 경우, CallExpression과 MemberExpression이 사용되고, 문자열 안에 있는 경우 Literal이 사용되는 것을 볼 수 있네요.\n\n\n여기서 얻은 정보를 바탕으로 acorn을 이용해 console.log를 감지하는 스크립트를 작성해볼 수 있습니다.\n\n\n이렇게 acorn-walk 를 사용하면 CallExpression에 해당하는 console.log만 감지할 수 있습니다. 주석이나 문자열, 화이트스페이스에 관계없이 안전하게 소스코드를 분석할 수 있는 것이죠.\n\nESLint에서 사용할 규칙 직접 정의하기\nESLint는 espree라고 하는 파서를 통해 소스 코드를 파싱하고, 이 결과를 각 플러그인에서 순회하며 규칙을 실행합니다. 우리가 원하는 규칙을 직접 플러그인을 통해 정의하고, 실행할 수 있어요.\n\nEspree AST만 읽을 수 있다면 ESLint 규칙도 쉽게 만들 수 있습니다.\n\n\n토스에서는 소스 코드 내에서 HTTP 링크를 찾아 HTTPS 링크로 바꿔야 한다고 알려주는 ban-http 와 같은 규칙을 정의하고 있습니다. 이런 규칙을 어떻게 직접 정의할 수 있는지 알아볼까요?\n\n먼저 소스 코드 내 문자열이 Espree AST에서 어떻게 표현되는 지를 알아봐야 합니다. AST Explorer에서 상단의 파서 설정을 Espree로 변경해주면 이를 쉽게 알 수 있습니다.\n\nLiteral 타입의 노드에서 value를 읽으면 문자열 내용을 알 수 있네요.\n\n\n\n이를 기반으로 아래와 같이 ESLint 규칙을 새로 정의할 수 있습니다.\n\n\n위 코드는 Literal을 만났을 때, 그 Literal의 값이 “http://” 로 시작하는 문자열이면 에러를 리포트하는 코드입니다. 생각보다 복잡하지는 않죠?\n\n\n이렇게 작성된 규칙을 ESLint에 추가하면 개발자들이 개발 중 규칙에 맞지 않는 코드를 작성했을 때 이렇게 알려줄 수 있어요.\n\n\n\n토스에서 사용하는 여러가지 규칙들\n이를 바탕으로 토스에서는 여러 가지 ESLint 규칙을 만들어서 플러그인으로 배포하고, 이를 서비스에서 사용하여 코딩 컨벤션을 유지하고 있습니다. 몇 가지 사용하는 규칙들은 아래와 같은 규칙들이 있어요.\n\n토스 프론트엔드 챕터 내 맥락이 강한 규칙들\n사내 라이브러리 사용 시 deprecated된 API 사용 금지\n이전 토스 도메인 사용 금지\n외부 라이브러리 사용에 관련한 규칙들\n사용하지 않기로 한 패키지 사용 제한 (ban-axios, ban-lodash)\n훅 이름에서 한글 허용 (rules-of-hooks)\nSSR에서 사용 시 오류를 내는 라이브러리 사용 제한 (ban-ssr-unsafe-method)\n또한 ESLint 외에도 자체 제작한 도구를 통해 사용해 deperecated 된 API의 사용이나 중복된 코드를 감지하기도 해요.\n\n더 알아보기\nESLint 플러그인을 만드는 방법과 ESLint API 자체에 대한 글은 ESLint 공식 문서에서 더 자세히 알 수 있어요.\n\nCreate Plugins – ESLint – Pluggable JavaScript Linter","isDisplayingFeedback":true},{"id":21011,"updatedTime":"2023-04-12T17:25:58+09:00","createdTime":"2023-04-12T16:01:38+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"tosspayments-restdocs: 선언형 문서 작성 라이브러리","subtitle":"REST Docs 를 최소한의 코드로 작성하면서 변화에도 더 유연하게 대처할 수 있는 tosspayments-restdocs 라이브러리와, 라이브러리에 녹인 기술들을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/00017-3291509353.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/00017-3291509353.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"tosspayments-restdocs","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-22T14:29:51+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21011,"title":null,"description":"최소한의 코드로 문서 작성하기토스페이먼츠에서는 두 가지 장점 때문에 Spring REST Docs를 권장하고 있는데요. 첫 번째는 문서 작성 단계부터 API를 통합 테스트할 수 있다는 점, 두 번째는 인터페이스의 의도치 않은 변경을 감지할 수 있다는 점 때문입니다.하지만 Spring R...","urlSlug":"tosspayments-restdocs","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"tosspayments-restdocs: 선언형 문서 작성 라이브러리","description":"REST Docs 를 최소한의 코드로 작성하면서 변화에도 더 유연하게 대처할 수 있는 tosspayments-restdocs 라이브러리와, 라이브러리에 녹인 기술들을 소개합니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://toss.tech/wp-content/uploads/2023/03/00017-3291509353.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2356,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":580,"name":"이준희","slug":"junhee-lee","shortDescription":"Server Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/junlee-lee.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"최소한의 코드로 문서 작성하기\n\n들어가며\n토스페이먼츠에서는 두 가지 장점 때문에 Spring REST Docs를 권장하고 있는데요. 첫 번째는 문서 작성 단계부터 API를 통합 테스트할 수 있다는 점, 두 번째는 인터페이스의 의도치 않은 변경을 감지할 수 있다는 점 때문입니다.\n\n하지만 Spring REST Docs에는 단점도 있습니다. 장황한 코드 때문에 가독성이 떨어지고, 코드 반복으로 인해 생산성이 떨어지는 아쉬움이 있었습니다. 이런 문제를 해소하기 위해 Kotlin DSL을 구현해서 반복적이고 지루한 Spring REST Docs 코드 작성에 필요한 노력을 줄이는 방법을 한규주님의 이전 글 'Kotlin으로 DSL 만들기: 반복적이고 지루한 REST Docs 벗어나기'에서 소개했었습니다.\n\n이번에는 나아가 더 높은 가독성, 더 최소화된 코드 중복, 세부 구현 및 의존성 은닉, 마지막으로 확장에 열려있는 특성을 갖춘 문서화 라이브러리 'tosspayments-restdocs'를 소개하고 개발 후기를 공유합니다.\n\n\n동일한 컨트롤러를 Spring REST Docs(좌측)와 tosspayments-restdocs(우측)로 문서화했을 때의 차이. 작성한 문서화 코드의 양이 크게 감소했다.\n\n다시 살펴보기: Spring REST Docs의 문제들\nSpring REST Docs 기반 문서화 코드의 아쉬운 점을 아래 코드를 통해 다시 한번 살펴볼게요.\n\n\n요청 필드 2개, 응답 필드 3개로 구성된 단순한 PUT 인터페이스지만, 장황하게 작성된 코드 때문에 전체 구조를 한눈에 파악하기 어렵습니다. 이런 구조의 코드는 처음 작성하는 비용이 많이 들 뿐만 아니라 유지보수 비용도 늘립니다. 위 코드의 문제점을 좀 더 구체적으로 살펴보겠습니다.\n\n1. 코드 중복\n먼저, 같은 내용이 반복적으로 명세에 포함되어 있습니다. 예를 들어 MockMvcResponse와 REST Docs Snippet을 만들기 위해 Path Variable, 그리고 Request Body Field 코드 중복이 발생했습니다.\n\n또한 Request Body값을 MockMvc에 전달하는 과정에서 샘플 데이터를 통해 필드의 타입 및 샘플이 추론 가능함에도 REST Docs Snippet에 불필요하게 다시 명세하고 있습니다.\n\n2. 불필요한 명령\ngiven(), prettyPrint(), then(), preprocessRequest(), preprocessResponse() 등의 메서드는 인터페이스 명세에 꼭 필요한 핵심이라 하기 어렵습니다. 문서 작성과 관계 없이 빌드에 필요하기 때문에 추가된 사항입니다.\n\n3. 인터페이스 명세 순서\n실제 HTTP 프로토콜에서는 Request Line → Request Header → Request Body → Response Line → Response Header → Response Body 순으로 페이로드가 만들어집니다.\n\n그러나 위의 예시 코드는 이러한 흐름에 맞춘 자연스러운 명세 작성 대신, MockMvc를 구성하는 기반 기술에 의존하는 명령을 나열하는데 집중하고 있습니다. 그래서 코드를 작성할 때나 읽을 때 모두 코드 블록을 왔다갔다 해야 하는 불편을 겪습니다.\n\n4. 기반 기술에 강한 의존\n기반 기술에 강하게 의존하고 있기 때문에 기반 기술에 브레이킹 체인지가 생기거나, 유지보수가 중단되면 대응이 어렵습니다.\n\n또, 이렇게 기반 기술에 많이 의존하게 되면 문서를 작성하는 모든 개발자가 기반 기술의 세부 항목을 학습해야 합니다. 가령 MultiPart API, Streaming API, Reactive API 등 다른 형태의 API를 문서화할 때마다 개발자는 사용할 MockMvc의 세부 기능을 각각 학습해야 합니다. 이런 방식은 문서화에 필요한 학습 비용을 높이고 지속적인 대응을 어렵게 만듭니다.\n\n위 코드를 tosspayments-restdocs 라이브러리를 사용해서 다시 작성한 코드 예시입니다.\n\n생성될 문서를 직관적으로 예측할 수 있고, 기반 기술을 완전히 추상화해서 코드가 절반 이하로 감소했습니다.\n\n\ntosspayments-restdocs를 적용한 결과\n\n이런 개선점을 만든 tosspayments-restdocs 라이브러리에는 선언형 프로그래밍, 타입 추론 개념이 녹아있는데요. 어떻게 적용됐는지 하나씩 설명해보겠습니다.\n\n선언형 프로그래밍\n\nhttps://developer.mozilla.org/en-US/docs/Glossary/Element\n\n선언적으로 코드를 작성하는 대표적인 사례는 HTML입니다. HTML에서는 표현하고자 하는 항목을 요소(Element)로 추상화하고, 요소의 태그(Tag), 속성(Attribute), 내용(Content)을 명세해서 최종 결과물을 만듭니다.\n\n같은 방식으로, tosspayments-restdocs에서는 API의 실제 형태(HTTP의 페이로드)를 있는 그대로 표현할 수 있도록 Documentation, Request Line, Request Header, Request Body, Response Body를 요소화했습니다. 이렇게 모든 문서화 항목을 요소로 만들었기 때문에 HTML을 작성하는 방식처럼 선언적으로 문서를 작성할 수 있습니다.\n\n선언적인 작성에는 이런 장점이 있습니다.\n\n명세의 내용에 집중하게 됩니다. 세부 기술 및 이를 위한 불필요한 명령 없이, 문서화 코드의 본질인 인터페이스 명세에 집중할 수 있습니다.\n꼭 필요한 정보만 명세할 수 있습니다. 꼭 필요한 항목만 요소의 속성으로 선언하고, 추가적인 속성들은 중괄호를 열어 표현하게 됩니다.\n읽기 쉬운 코드가 됩니다. 최종 결과물의 실제 형태가 그대로 녹아져 있으므로, 위에서 아래로 한번만 읽으면 결과를 파악할 수 있습니다.\n확장이 쉽습니다. 새로운 문서화 항목이 생기는 경우 요소를 새로 정의하면 됩니다. 기존 항목에 자식 항목이 새롭게 생기는 경우에도 마찬가지로 대응이 가능합니다.\n구현 방법에서 자유로워집니다. 각 요소를 어떻게, 무엇으로 렌더링 할 지를 모두 라이브러리에 위임해서 기반 기술의 변화나 결과물의 포맷 변화가 코드에 미치는 영향을 줄일 수 있습니다.\n선언형 프로그래밍 구현 - 함수와 확장 함수\ntosspayments-restdocs의 문서화 코드 진입점인 documentation 요소 함수를 살펴보겠습니다.\n\n\ndocumentation 함수 호출 예\n\n\ndocumentation 내부 구현(이해를 돕기 위해 단순화하였습니다)\n\ndocumentation은 문서의 이름(documentName)을 필수 속성으로, requestLine 등 세부 스펙 요소 추가적인 속성으로 취급하는 요소 함수로, 문서화의 시작(문서 스펙 정의)과 끝(문서 출력)을 담당합니다.\n\n앞서 꼭 필요한 항목만 요소의 속성으로 선언하고, 추가적인 속성들은 중괄호를 열어 표현한다고 했는데요. 이 개념을 코틀린으로 구현하면서 필수 속성은 함수의 파라미터로, 추가 속성은 람다 함수 파라미터로 표현했습니다. 요소의 모든 속성을 파라미터로 펼쳐두면 함수가 장황해지고 확장성이 떨어지기 때문입니다.\n\n추가 속성을 람다 확장 함수(Extension Function) 스코프 내에서 정의하도록 하면 스코프 내에서 일어나는 일들에는 함수가 관여하지 않습니다. 그래서 편의성을 확보하면서 확장성을 유지할 수 있고, 스코프를 계층화하여 도메인을 더욱 잘 표현할 수 있습니다.\n\n예를 들어 documentation 요소 함수의 람다 확장 함수(specCustomizer: DocumentSpec.() -> Unit) 스코프에서는 RequestLineSpec, RequestBodySpec, ResponseBodySpec 등을 세부 요소 스펙으로 품고 있는 DocumentSpec의 this가 주어집니다. 스코프 및 스코프에 this를 주입하는 이런 방식에는 다음과 같은 장점이 있습니다.\n\n스코프 단위로 특화된 기능을 제공할 수 있습니다. 예를 들어 requestLine 함수는 DocumentSpec의 세부 요소 스펙인 RequestLineSpec을 정의하기 위한 요소 함수입니다.\n구조화된 확장성을 갖습니다. 새로운 속성이 추가되었을 때 스코프 내에 함수나 프로퍼티를 추가하여 쉽게 대응할 수 있습니다. 또한 새로운 자식 요소를 갖게 되는 경우에도 동일한 방식으로 람다 확장 함수 스코프를 정의해 대응할 수 있습니다. documentation → requestBody → field 로 이어지는 nested scope 가 그 예입니다.\n타입 추론\nSpring REST Docs의 문제 중 하나는 필드의 타입을 REST Docs Snippet에 다시 명세하는 비효율적인 작성 방식입니다.\n\nKotlin에서는 Inline Function 한정으로 Reified Type Parameter를 제공합니다. 타입 정보가 소거되는 일반적인 Generic Function의 Type Parameter와 달리, Reified Type Parameter의 경우에는 타입 정보가 소거되지 않아 라이브러리에서 접근할 수 있습니다.\n\ntosspayments-restdocs에서는 항상 문서화 요소가 샘플을 받게 강제하고, 샘플의 타입과 값을 내부 자료구조에 저장하도록 했습니다.\n\n\nsample이 reified T로 선언되어 타입 정보(T::class.java)에 접근이 가능합니다.\n\n타입 정보가 남아있다면 문서를 작성하는 개발자를 대신해 다양한 작업을 자동화 할 수 있습니다. tosspayments-restdocs에서는 타입 명세, 열거형 예시 작성, 포멧 명세 등에 타입 정보를 활용하고 잇습니다.\n\n\n타입 정보 활용 예(타입별 양식 자동생성) – 열거형은 엔트리 나열, 시간 타입은 타임 포멧을 반환\n\n\n타입 정보 활용 예(생성된 문서) – 열거형 타입으로부터 얻은 정보로 ResultType의 엔트리(SUCCESS, ERROR)가 자동생성 되었습니다.\n\n지금까지 문서를 최소한의 코드로 작성하면서 변화에도 더 유연하게 대처할 수 있는 tosspayments-restdocs 라이브러리와, 라이브러리에 녹인 생각들을 소개했습니다.\n\ntosspayments-restdocs는 토스페이먼츠의 다양한 팀에서 Spring REST Docs, kotlin-dsl-restdocs를 대신해 활용하며 생산성을 높이고 있습니다.\n\n개발자가 더욱 변하지 않고 가치있는 일에 집중할 수 있도록, 토스페이먼츠에서는 생산성을 높이기 위한 다양한 활동을 이어나가고 있습니다. 함께 고민하며 더욱 좋은 문화와 기술을 만들어나가면 좋겠습니다.","isDisplayingFeedback":true},{"id":21018,"updatedTime":"2023-04-12T17:25:58+09:00","createdTime":"2023-04-12T16:02:37+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"선언적인 코드 작성하기","subtitle":"선언적인 코드, 토스 프론트엔드 챕터는 어떻게 생각을 하고 있을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/declarative.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/declarative.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"frontend-declarative-code","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-16T21:41:13+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21018,"title":null,"description":"선언적인 코드(Declarative Code)는 프론트엔드 개발을 하다 보면 자주 만나게 되는 개념입니다. 특히 React 생태계에서 웹 서비스를 개발하다 보면 선언적인 코드에 대해 고민하게 되는데요. 이번 아티클에서는 토스 프론트엔드 챕터에서 생각하는 선언적인 코드란 무엇인지, 그리고...","urlSlug":"frontend-declarative-code","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"선언적인 코드 작성하기","description":"선언적인 코드, 토스 프론트엔드 챕터는 어떻게 생각을 하고 있을까요?","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://og.toss.tech?title=%EC%84%A0%EC%96%B8%EC%A0%81%EC%9D%B8%20%EC%BD%94%EB%93%9C%0D%0A%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0&imageUrl=https%3A%2F%2Fstatic.toss.im%2Fassets%2Ftoss-tech%2Fdeclarative_right.png&v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2357,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":556,"name":"박서진","slug":"sojin-park","shortDescription":"Frontend Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/sojin.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":6,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"선언적인 코드(Declarative Code)는 프론트엔드 개발을 하다 보면 자주 만나게 되는 개념입니다. 특히 React 생태계에서 웹 서비스를 개발하다 보면 선언적인 코드에 대해 고민하게 되는데요. 이번 아티클에서는 토스 프론트엔드 챕터에서 생각하는 선언적인 코드란 무엇인지, 그리고 실제로 어떻게 선언적인 코드를 작성하는지 공유해드리려고 합니다.\n\n선언적인 코드\n토스 프론트엔드 챕터에서는 선언적인 코드를 “추상화 레벨이 높아진 코드”로 생각하고 있습니다. 예를 들어서, 아래와 같이 주어진 배열의 합을 구하는 함수 sum 을 생각해봅시다.\n\n\nsum 함수는 아래와 같이 for 문으로 구현할 수 있습니다.\n\n\n여기에서 sum 함수는 초기값이 0이고, 배열이 가지고 있는 각각의 원소를 순회하면서 결과값에 더하는 작업을 추상화합니다. 덕분에 sum 을 다루는 사람은 복잡한 제어 흐름을 이해할 필요 없이, “배열의 합을 구한다” 라고 하는 동작에 집중하여 함수를 사용할 수 있습니다.\n\n토스는 이렇게 동작에 집중하여 추상화된 sum 함수를 선언적인 코드로 생각하고 있습니다.\n\n여기에서 한 걸음 더 나아가서 sum 함수 내부의 for ... of 문을 살펴봅시다.\n\n\n이 제어 흐름도 선언적인 코드로 볼 수 있습니다. 배열이 가지고 있는 각각의 요소를 순회하는 동작을 추상화하고 있기 때문입니다.\n\n실제로 ECMAScript 표준에 따라서 for ... of 가 추상화하는 로직을 그대로 드러내면 아래와 같이 나타낼 수 있습니다.\n\n\n위와 같이, for ... of 문은 Iterator를 생성하고, Iterator가 끝날 때까지 다음 요소를 차례차례 가져오는 작업을 “각각의 요소를 순회하는 작업”으로 추상화합니다. 이런 관점에서 봤을 때, for ... of 문은 선언적인 코드입니다.\n\n실제로는 생성된 Iterator를 삭제하는 동작도 존재하므로 보다 추상화되는 로직이 많습니다.\n코드의 관점을 벗어나면 보다 재미있는 예시를 생각할 수 있습니다.\n\n“왼쪽으로 10걸음 걸어라” 라고 하는 말을 생각합시다. 여기에서\n\n“왼쪽”은 “북쪽을 바라보았을 때 90도 돌아간 위치” 를 추상화한 것입니다.\n“90도”는 “한 번의 회전을 360등분한 각의 90배만큼 시초선에 대해 시계 반대 방향으로 돌아간 것” 을 추상화한 것입니다.\n“시계 방향” 의 정의는 “북반구에서 해시계의 바늘이 돌아가는 방향” 을 추상화한 것입니다.\n그래서 “왼쪽으로 10걸음 걸어라”는 사실 “북쪽을 바라보았을 때 한 번의 회전을 360등분한 각의 90배만큼 북반구에서 해시계의 바늘이 돌아가는 방향으로 돌아서, 동물이 육상에서 다리를 이용해 움직이는 가장 빠른 방법보다 느린, 신체를 한 지점에서 다른 지점으로 옮겨가는 행위를 10번 반복해라” 라는 말을 추상화한, 선언적인 말로 볼 수 있을 것입니다.\n\n좋은 선언적인 코드 작성하기\n위에서 선언적인 코드를 추상화 레벨이 높아진 코드로 살펴보았습니다. 그런데 선언적인 코드는 항상 좋은 것일까요? 토스에서는 추상화가 항상 좋은 것은 아닌 것처럼 선언적인 코드도 잘 쓰는 것이 중요하다고 생각합니다.\n\n토스에서는 좋은 코드를 판단하는 제1원칙을 “수정하기 쉬운 코드”라고 생각합니다. 비즈니스 요구사항은 항상 빠르게 변하기 때문에, 개발자가 기민하게 대응하는 것이 중요하기 때문입니다. 그러면 선언적인 코드가 언제 수정하기 쉽고, 언제 그렇지 않은지 살펴봅시다.\n\n먼저 아래와 같은 회원가입 폼 컴포넌트를 살펴봅시다.\n\n\n위 컴포넌트는 회원가입 로직을 하나의 컴포넌트로 추상화했기 때문에 선언적인 컴포넌트로 볼 수 있습니다.\n\n이 코드는 수정하기 쉬울까요?\n\n먼저 회원가입 폼을 여러 곳에서 사용한다면 각각의 폼을 중복해서 개발할 필요 없이 한 번만 개발하면 되기 때문에 효율적일 것입니다. 또한 회원가입 폼에 변경이 생긴다고 하더라도, 한 곳에서만 바꾸면 다른 화면들에 모두 반영되기 때문에 빨리 수정할 수 있을 것입니다.\n\n수정하기 어려운 지점은 없을까요?\n\n화면마다 SignUpForm 이 조금씩 다르다면, 공통화된 것이 오히려 코드의 복잡함을 가져올 수도 있습니다. 예를 들어서, 어떤 페이지에서는 SNS 회원가입을 일반 이메일 회원가입보다 먼저 보여줘야 할 수 있습니다. 또, 다른 페이지에서는 텍스트나 스타일을 조금씩 다르게 보여줘야 할 수 있습니다.\n\n아래와 같이 SignUpForm 에서 바뀔 수 있는 부분이 많다면, 내부 구현과 인터페이스도 복잡해지고, 쓰는 쪽에서도 불편할 것입니다.\n\n\n이처럼 토스에서는 선언적인 코드가 항상 좋은 것이 아니라, 앞으로 제품이 어떻게 변화할지, 비즈니스 요구사항이 어떻게 되는지에 따라서 달라질 수 있다고 생각하고 있습니다. 앞으로 코드의 어떤 부분이 수정될지 예측하고, 이에 따라 적절한 선언 레벨을 따르는 코드를 작성할 필요가 있습니다.\n\n토스의 선언적 라이브러리\n그렇다면 다양한 상황에서 일반적으로 사용할 수 있는 좋은 선언적 코드는 없을까요? 이번 아티클은 토스 프론트엔드 챕터가 100개가 넘는 서비스들에서 자주 사용하고 있는 선언적 라이브러리에 대해서 소개하고 마무리하려고 합니다.\n\nuseOverlay\n\n토스에서는 BottomSheet, Dialog, Toast와 같이 화면 위에 뜨는 오버레이를 띄워야 하는 상황이 많습니다. 토스는 이렇게 오버레이를 띄우는 동작을 추상화하여 useOverlay 라고 하는 Hook 을 사용합니다.\n\n\n예를 들어서, 위 코드에서는 바텀시트 열기 버튼을 누르면 나는 바텀시트야 라고 하는 바텀시트를 띄웁니다.\n\nuseOverlay 가 없었더라면 아래와 같이 제어 흐름이 드러나는 코드를 작성했어야 할 것입니다.\n\n\nuseOverlay에 대한 자세한 정보는 Slash libraries의 useOverlay Hook을 참고해주세요.\n\nImpressionArea\n토스 앱에서는 어떤 영역이 보여졌는지/숨겨졌는지에 따라서 동작하는 로직이 많습니다. 예를 들어서, 사용자가 특정한 요소를 보면 폭죽을 터뜨리거나 토스트를 보여주는 식이죠. 토스에서는 ImpressionArea 라고 하는 컴포넌트로 이를 추상화하고 있습니다.\n\n\nImpressionArea 가 없었더라면, 복잡한 IntersectionObserver API 를 사용하거나, 복잡한 Scroll 이벤트 핸들러 로직을 사용해야 했을 것입니다.\n\nImpressionArea 에 대한 자세한 정보는 Slash libraries의 ImpressionArea 컴포넌트를 참고해주세요.\n\nLoggingClick\n토스에서는 데이터 주도 의사결정을 위해서 화면에 진입하는 사용자가 몇 명인지, 그 중 몇 명이 버튼을 누르는지를 기록하는 경우가 있습니다. 이런 누르는 동작에 대한 기록을 추상화하여 LoggingClick 컴포넌트를 사용하고 있습니다.\n\n\n예를 들어서, 위 코드에서 사용자가 버튼을 누르면 “사기” 버튼에 대한 동작이 분석 시스템에 기록됩니다.\n\nLoggingClick 이 없었다면 아래와 같이 log 함수를 실행하는 것이 그대로 드러났어야 할 것입니다.","isDisplayingFeedback":true},{"id":21009,"updatedTime":"2023-04-12T17:25:57+09:00","createdTime":"2023-04-12T16:01:20+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"똑똑하게 브라우저 Polyfill 관리하기","subtitle":"현대적인 JavaScript를 쓰면서도 넓은 범위의 기기를 지원하기 위한 Polyfill을 어떻게 똑똑하게 설정할 수 있는지 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/01/js_center.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/01/js_center.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"smart-polyfills","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-01-21T12:52:16+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21009,"title":null,"description":"토스 앱은 넓은 범위의 기기를 지원하면서도 현대적인 JavaScript를 이용해서 개발되고 있습니다. 그렇지만 최신 JavaScript를 오래된 브라우저 위에서 실행하기 위해서는 “Polyfill” 문제를 해결해야 하는데요.이번 아티클에서는 Polyfill 문제가 무엇인지 알아보고, 토...","urlSlug":"smart-polyfills","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"똑똑하게 브라우저 Polyfill 관리하기","description":"현대적인 JavaScript를 쓰면서도 넓은 범위의 기기를 지원하기 위한 Polyfill을 어떻게 똑똑하게 설정할 수 있는지 소개합니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://og.toss.tech?title=%EB%98%91%EB%98%91%ED%95%98%EA%B2%8C%20%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%0D%0APolyfill%20%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0&imageUrl=https%3A%2F%2Fstatic.toss.im%2Fassets%2Ftoss-tech%2Fjs_right.png&v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2349,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":556,"name":"박서진","slug":"sojin-park","shortDescription":"Frontend Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/sojin.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":6,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스 앱은 넓은 범위의 기기를 지원하면서도 현대적인 JavaScript를 이용해서 개발되고 있습니다. 그렇지만 최신 JavaScript를 오래된 브라우저 위에서 실행하기 위해서는 “Polyfill” 문제를 해결해야 하는데요.\n\n이번 아티클에서는 Polyfill 문제가 무엇인지 알아보고, 토스에서 어떻게 똑똑하게 다루고 있는지 살펴보려고 합니다.\n\nPolyfill이란?\n오래된 버전의 브라우저에서는 현재 JavaScript가 당연하게 사용하고 있는 Promise나 Set 객체가 없는 경우가 있습니다. 편리한 Array.prototype.at() API는 Chrome 92 이상에서만 지원되기도 합니다.\n\n예를 들어서, 아래와 같은 코드는 최신 브라우저에서는 잘 동작하지만, 오래된 브라우저에서는 실패합니다. 객체나 메서드에 대한 구현이 없기 때문이죠.\n\n\n이런 문제를 해결하기 위해서는 오래된 브라우저에서 없는 구현을 채워주어야 합니다. 이렇게 구현을 채워주는 스크립트를 Polyfill이라고 합니다. 대부분의 Polyfill은 아래와 같이 이미 브라우저에 포함되어 있는지 체크하고, 없으면 값을 채워주는 형태로 동작합니다.\n\n\n위 스크립트를 실행한 이후에는, 오래된 브라우저에서도 안전하게 [1, 2, 3].at(-1) 코드를 실행할 수 있습니다.\n\n표준적으로 사용되는 Polyfill들은 core-js 리포지토리에 모여 있습니다. 아래 코드를 실행하면 대부분의 ECMAScript 표준 객체와 메서드를 오래된 브라우저에서도 사용할 수 있게 됩니다.\n\n\nPolyfill의 문제\n위와 같이 코드를 작성하면 폭넓은 브라우저를 지원할 수 있다는 장점이 있지만 문제가 하나 생깁니다. 불러와야 하는 JavaScript 코드가 많아진다는 점입니다. 실행해야 하는 Polyfill 스크립트가 많아질수록 사용자가 경험하는 웹 서비스의 성능은 나빠집니다.\n\n특히, 위와 같이 설정하면 최신 버전의 브라우저에서는 대부분의 ECMAScript 표준 객체와 메서드가 포함되어 있음에도 불구하고 불필요한 Polyfill 스크립트를 내려받아야 합니다. 꼭 필요한 Polyfill 스크립트만 선택적으로 불러올 수 있는 방법은 없을까요?\n\n첫 번째 방법: @babel/preset-env 사용하기\n이 문제를 해결하기 위해 사용할 수 있는 첫 번째 방법은 @babel/preset-env Smart Preset을 사용하는 것입니다. 이 Smart Preset은 이미 정의된 브라우저 목록에 따라서 자동으로 필요 없는 Polyfill을 제거해 줍니다.\n\n예를 들어서, 웹 페이지가 Internet Explorer 11을 지원해야 한다면 아래와 같이 babel.config.js 를 설정할 수 있습니다.\n\n\n이후에 동일하게 core-js/actual 을 import 하더라도 Internet Explorer 11에 필요한 Polyfill 목록만 포함되는 것을 확인할 수 있습니다. 총 221개의 Polyfill이 포함됩니다.\n\n\n\nBabel playground\n\nInternet Explorer 11을 지원 브라우저 목록에서 제외하면 훨씬 적은 25개의 Polyfill이 포함됩니다.\n\n\n\n\nBabel playground\n\n이렇게 @babel/preset-env에 브라우저 지원 범위를 설정하면 Polyfill을 안정적으로 포함하면서 스크립트의 크기를 감축할 수 있습니다.\n\n두 번째 방법: User-agent에 따라 동적으로 스크립트 생성하기\nBabel을 올바르게 설정함으로써 포함되는 Polyfill 스크립트의 크기를 줄일 수 있지만, 최신 버전의 브라우저에서 불필요한 스크립트를 내려받게 되는 문제는 동일합니다. 예를 들어서, Chrome 최신 버전은 문제없이 [1, 2, 3].at(-1) 을 실행할 수 있지만, 관련한 Polyfill 스크립트를 내려받습니다.\n\n이 문제를 해결하는 또다른 방법은 브라우저의 User-agent에 따라서 동적으로 Polyfill 스크립트를 생성하는 것입니다.\n\n예를 들어서, Financial Times에서 관리하고 있는 polyfill.io 서비스에서는 https://polyfill.io/v3/polyfill.min.js 라고 하는 경로로 동적인 Polyfill 스크립트를 제공합니다.\n\n최신 버전의 Chrome에서 해당 경로에 접속하면, 아무 Polyfill 스크립트도 내려오지 않는다는 것을 알 수 있습니다.\n\n\n반대로, Internet Explorer 11에서 실행하면 많은 양의 Polyfill 스크립트가 내려온다는 것을 알 수 있습니다.\n\n\n이렇게 User-agent에 따라 동적으로 Polyfill 스크립트를 생성하면 최신 브라우저에서는 아무 Polyfill도 내려주지 않고, 오래된 브라우저에서는 필요한 Polyfill 만 내려줄 수 있게 됩니다. ✨  브라우저가 꼭 필요한 Polyfill 스크립트만 내려받을 수 있는 것이죠.\n\n자체 Polyfill 서비스 구축하기\n토스에서는 polyfill.io 서비스를 그대로 사용할 수도 있었지만, Financial Times가 제공하는 Polyfill 중 일부가 ECMAScript 표준대로 작동하지 않아 오류가 발생한 경험이 있어서 자체적으로 구현했습니다.\n\ncore-js 와 core-js-compat, browserslist-useragent 라이브러리를 사용하면 손쉽게 동적인 Polyfill을 제공하는 Node.js 서버를 만들 수 있었습니다.\n\n먼저, User-agent에 따라서 필요한 core-js polyfill 목록을 계산하기 위해서 아래와 같은 getCoreJSPolyfillList 함수를 작성할 수 있습니다.\n\n\n이제 필요한 Polyfill 리스트를 하나의 스크립트로 만들면 됩니다. 토스에서는 esbuild 를 이용하여 core-js 스크립트를 하나로 이어붙이는 방법을 선택했습니다.\n\n\n이제 이 함수를 Node.js 서버에 포함시키거나, Lambda@Edge, Compute@Edge 와 같은 Edge Runtime에 포함하면 손쉽게 나만의 Polyfill 서버를 띄울 수 있습니다.\n\n마치며\n토스팀에서는 자체 제작한 Polyfill 시스템을 이용하여 최신 JavaScript API는 마음껏 활용하면서도 오래된 버전의 브라우저도 빠짐없이 지원할 수 있었습니다.\n\n글을 마무리하면서, 글의 내용을 요약해보자면 아래와 같습니다.\n\nPolyfill이란 신규 JavaScript API를 오래된 버전의 브라우저에서도 사용할 수 있도록 하는 방법입니다. 그렇지만, Polyfill 스크립트가 많아지면 웹 성능이 나빠집니다.\nBabel의 @babel/preset-env 스마트 프리셋을 이용하여 포함할 Polyfill 스크립트의 범위를 지정할 수 있습니다. 다만, 이 경우에도 최신 브라우저는 오래된 브라우저를 위한 Polyfill을 내려받습니다.\nUser-agent에 따라 동적으로 Polyfill 스크립트를 생성할 수 있습니다. 이로써 최신 브라우저에서 내려받는 Polyfill 스크립트를 거의 없게 만들 수 있습니다.","isDisplayingFeedback":true},{"id":21034,"updatedTime":"2023-04-12T17:25:57+09:00","createdTime":"2023-04-12T16:04:13+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"토스증권 QA 문화 ‘통합테스트’를 아시나요? (feat. 해외주식)","subtitle":"토스증권 해외주식 출시 전에 사내 임직원 대상으로 진행한 ‘통합테스트’에 대해 소개합니다. 통합테스트 진행 방식을 참고하여 간단한 규칙과 사용자 시나리오를 활용해 사용자의 반응을 미리 확인해 보세요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/12/01-1.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/12/01-1.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"tossinvest-qa-integration-test","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-12-12T21:01:48+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21034,"title":null,"description":"안녕하세요. 토스증권 QA팀에서 일하고 있는 QA Manager 황채은입니다.지난 글에서 잠깐 언급되었던 토스증권의 Closed Beta Test 기억하실까요? 🔗[지난 포스팅 참고하기 링크](https://toss.tech/article/tosssec-qateam)오늘은 해외 증권 ...","urlSlug":"tossinvest-qa-integration-test","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"토스증권 QA 문화 ‘통합테스트’를 아시나요? (feat. 해외주식)","description":"토스증권 해외주식 출시 전에 사내 임직원 대상으로 진행한 &#8216;통합테스트&#8217;에 대해 소개합니다. 통합테스트 진행 방식을 참고하여 간단한 규칙과 사용자 시나리오를 활용해 사용자의 반응을 미리 확인해 보세요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://og.toss.tech?title=%ED%86%A0%EC%8A%A4%EC%A6%9D%EA%B6%8C%EC%9D%98%20QA%20%EB%AC%B8%ED%99%94%3A%0D%0A%E2%80%98%ED%86%B5%ED%95%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%E2%80%99&imageUrl=https%3A%2F%2Fstatic.toss.im%2Fassets%2Ftech-blog%2Fog%20image%2Fthumnail%2F01-og.png&v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2345,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":572,"name":"황채은","slug":"chaeeun-hwang","shortDescription":"QA Manager","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/chaeeun-hwang.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"안녕하세요. 토스증권 QA팀에서 일하고 있는 QA Manager 황채은입니다.\n\n지난 글에서 잠깐 언급되었던 토스증권의 Closed Beta Test 기억하실까요? 🔗지난 포스팅 참고하기 링크\n\n오늘은 해외 증권 서비스 출시를 위해 토스증권 임직원 대상으로 진행한 Closed Beta Test 에 대해 소개하려고 합니다.\n\n토스증권 서비스는 어떤 테스트 과정을 통해 출시되고 있을까요?\n토스증권에서는 기능별로 Silo가 만들어져있고, 그 Silo에는 PO, Developer, PD, DA, QA가 함께 서비스를 만들고 있는데요.\n\nPO(Product Owner), 개발자(Front/Server/Core), PD(Product Designer), DA(Data Analyst), QA(Quality Assurance)\n개발이 완료된 서비스들은 1차로 개발자 단위 테스트를 진행 후 QA Manager는 알파 환경에서 계획한 테스트를 진행하고, 이슈 수정이 모두 완료되면 QA 환경에서 최종 확인된 기능에 대해 서비스 Release를 Silo 별로 진행하고 있습니다. 이런 과정은 일반적인 IT 회사의 QA Cycle과 비슷하게 진행하고 있어요.\n\n하지만, 토스증권에서는 내부 임직원들 대상으로 테스트 참여를 유도하여 미처 발견하지 못한 Edge Case 들과 보다 다양한 사용자의 피드백을 미리 얻고자  Closed Beta Test를 진행하기도 한답니다. 실제 제가 작년에 진행했던 토스증권의 해외 주식 서비스 런칭 경험을 소개해 드리려고 해요.\n\n토스증권에서 진행한 내부 임직원 테스트는 아래의 다양한 테스트 방식의 개념을 조금씩 섞어서 진행했어요.\n\nQA라면 모두가 알고 있는 탐색적 테스팅의 개념, Dog Fooding, Bug Bash를 모두 활용하였는데요. 그전에 개념들을 한번 언급하고 지나갈게요!\n\nClosed Beta Test란?\n비공개 베타 테스트로, 서비스를 정식으로 오픈하기 전에 프로그램의 버그를 찾거나 사용성, 요구사항 충족 등을 검증하기 위해 개발자와 관련되지 않은 사용자에 의해 진행되는 테스트\n\n탐색적 테스팅이란?\n테스트 대상 제품을 사용하면서 제품의 정보 습득과 동시에 테스트를 설계하고 실행하는 방식으로 탐색적 테스팅의 주요 구성요소는 Test Charter, Test Note, Time Boxing, Debrief가 있음\n\nDog Fooding 이란?\n서비스 출시 전 사용자의 입장에서 내부 인원이나 개발자가 직접 사용하며 제품을 개선하는 것\n\nBug Bash란?\n제품이 최종 릴리즈되기 전 다양한 직군의 인원들이 제품을 사용하며 아직 남아있을 수 있는 버그를 찾아내는 활동으로 짧은 시간에 많은 인원이 진행하기 때문에 상대적으로 빠르게 버그를 찾을 수 있음\n\n토스증권의 Closed Beta Test는 어떻게 진행되었을까요?\n업무시간에 임직원 대상으로 진행하는 만큼, 효율적으로 진행하기 위해 여러 준비과정이 필요했는데요.\n\n개개인이 자율적으로 참석 가능한 임직원의 신청을 받았는데, 개발자를 제외한 임직원 중에서 70% 이상이 참여할 정도로 많은 관심을 가져주셨어요.\n\n서비스에 대해 여러 피드백을 받기 위해 직군에 관계없이 참여가 가능한 분들은 모두 신청을 받았는데요. 그러다보니, 알파 환경 자체를 처음 접해보는 임직원분들도 있어 사용성에 어려움이 많아 사전 테스트 환경 준비가 중요했어요. 마치, 실제 서비스가 런칭되었을 때와 동일하게 사용하는 경험을 주기 위해 알파 테스트 환경이지만 운영과 동일한 환경에서 볼 수 있도록 테스트 환경을 마련하였는데, 모두의 시간을 할애하는 만큼 테스트 환경을 위해 InfraOps, Network Engineer, Devops 팀에서 테스트 환경 구축에 많은 도움을 주셨어요.\n\n신청자 대다수가 토스증권 해외 주식에 대한 기본적인 Spec을 전혀 모르기 때문에 테스트 시나리오를 제공해야했어요. 그래서, 탐색적 테스팅의 Test Charter 개념을 섞어서 Test Scenario를 Use Case 형식으로 작성했는데요. 서비스의 주요 퍼널을 통과할 수 있게 작성하고 QA Team의 Peer Review를 통해 시나리오를 준비하였어요.\n\n\n시나리오는 총 36건 작성을 하였고, 해외 증권 거래소 시간에 맞게 테스트를 진행해야 해서, Use Case를 테스트할 수 있는 Timeline을 설정했어요. 해외 증권 거래소의 테스트 거래소와 연동을 하여 실제 주식이 체결되는 것처럼 보이게 환경을 만들어 두었기 때문에, 먼저 증권 거래소 운영 시간에 맞추고 주식의 매수/매도 유형에 맞춰 시나리오를 만들었는데요. 그래서 해외 주식 서비스는 밤 11시가 넘은 심야에도 계속 진행되어야 했어요.\n\n해당 Timeline에 맞게 임직원 모두가 같은 시간대에 테스트를 하는 것을 유도하기 위해 캘린더 초대도 잊지 않았어요! (참석자 모두, 심야 시간인데도 불구하고 수락을 눌러주셨어요!)\n\n이렇게 준비된 테스트 형식을 모두가 이해하기 쉽게 “통합테스트” 라는 용어로 정리하였어요!\n\n\n이제 마지막으로 테스트 진행 관련된 사항을 어떻게 공유할지, 어떻게 Debrief 할지를 정해야 했는데요.\n\n토스증권은 업무를 보다 빠르고 효율적으로 진행할 수 있도록 만들어진 다양한 사내 툴들이 있어요.\n\n대표적으로 Slack에서 JIRA(Bug Tracking System)를 바로 연동하여 이슈를 생성하고 완료까지 처리할 수 있는 (Bot)이 있어요. 또 Slack의 Workflow에서 Emoji를 남기면, 해당 게시글이 다른 채널로 전달되는 기능을 활용해서 보다 편하게 이슈를 모아볼 수 있었어요.\n\n글로 설명하려니 이해가 잘 안되시죠?\n\n그러면, 이제 저와 함께 통합테스트를 함께 진행해 볼까요?\n\n완료 후 미션에 DONE Emoji를 남기면 Thread에 완료 표기\n\n미션 중 이슈로 인해 진행하지 못하는 경우 SOS Emoji를 남기면 Thread에 표기\n\n이슈에 Emoji를 남기면 별도 채널로 이동되고, 해당 채널에 이슈 등록\n\n\n이런 미션의 형태로 진행하니, 임직원들도 게임에 참여하듯이 (미션 클리어! 효과음이 들리시나요?) 즐겁고 적극적으로 진행해 주셨어요. 또한 테스트를 진행하는 동안 이전에 사용하였던 해외증권 서비스의 경험을 비롯한 다양한 의견들을 제시해 주셨어요.\n\n그렇게 통합테스트 기간 동안 약 100개가 넘는 피드백이 등록되었는데요. 👀\n\n\n전달된 의견들은 실제로 Bug나 결함보다는 사용자로서의 의견에 더 가까운 내용들이 많았어요. 제시해 주신 여러 의견들을 통해 오픈 전 서비스의 사용성 및 품질을 더 높일 수 있었다고 생각해요.\n\n3일이라는 짧다면 짧고 길다면 긴 기간 동안 모두가 즐겁게 테스트에 참여해 주셨어요.\n\n서비스 출시 전, 통합테스트는 어떤 의미였을까요?\n임직원 대상으로 진행한 통합테스트는 QA팀에서 QA Plan에 맞게 여러 테스트 Iteration을 수행하고, 개발 Side의 단위 테스트, 성능 테스트가 진행이 되었다 하더라도 우리가 만든 서비스가 만든 의도에 맞게 동작하는지에 대해 미리 임직원 대상으로 실험할 수 있었어요. 우리가 만들었던 기능 중에서 우려했던 부분 역시 다시 드러나면서 개선이 더 필요한 부분에 대해 Maker 들과 공감대 형성에 가장 큰 역할이 되었습니다.\n\n또한, 우리가 사용자에게 의도한 대로 동작하는 부분이 제대로 동작하는지까지 미리 알 수 있었고 그 장치들을 더 효과 있게 바꾸는 계기도 되었어요.\n\n토스증권 QA팀에서는 정량적인 서비스 품질뿐만 아니라, 회사에서 품질을 생각하는 문화에 대해서도 모두가 참여하도록 유도하고 서비스 품질에 대한 정성적인 기준에 대해 다 같이 고민하는 시간을 만들어가는 과정에도 주도적으로 참여해야 한다고 생각합니다.\n\n그래서 bugbash, closed beta testing, 탐색적 테스팅 등과 같이, QA라면 흔히 알고 있는 이런 여러 테스트 방식 중에서 필요한 부분으로 토스증권만의 ‘통합테스트’ 라는 컨셉을 만들었어요. 또한, 임직원 70% 이상이 참여하도록 만들었고 그 결과 또한 성황리에 마무리할 수 있었어요.\n\n이후로 임직원과 함께하는 통합테스트는 토스증권의 QA 문화로 자리매김할 수 있었고, 지금도 큰 서비스가 출시될 때마다 통합테스트를 주기적으로 진행하고 있습니다.","isDisplayingFeedback":true},{"id":21015,"updatedTime":"2023-04-12T17:25:55+09:00","createdTime":"2023-04-12T16:02:14+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"NestJS 환경에 맞는 Custom Decorator 만들기","subtitle":"NestJS에서 데코레이터를 만들기 위해서는 NestJS의 DI와 메타 프로그래밍 환경 등을 고려해야 합니다. 어떻게 하면 이러한 NestJS 환경에 맞는 데코레이터를 만들 수 있을지 고민해보았습니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/11/tech-article-nest-js-02.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"nestjs-custom-decorator"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/11/tech-article-nest-js-02.png","backgroundColor":null,"isFill":false,"imageAlt":"nestjs-custom-decorator"},"key":"nestjs-custom-decorator","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-11-22T00:03:49+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21015,"title":null,"description":"데코레이터는 비즈니스와 상관 없는 로직들을 숨기면서 기능을 변경하거나 확장할 수 있게 합니다. 또한 여러 클래스에서 반복되는 공통 관심사가 있을 때 데코레이터를 사용하면 중복된 코드를 줄이고 코드를 모듈 단위로 관리하는 효과를 거둘 수 있습니다.이런 이유로 저희 Node.js Chapt...","urlSlug":"nestjs-custom-decorator","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"NestJS 환경에 맞는 Custom Decorator 만들기","description":"데코레이터는 비즈니스와 상관 없는 로직들을 숨기면서 기능을 변경하거나 확장할 수 있게 합니다. 또한 여러 클래스에서 반복되는 공통 관심사가 있을 때 데코레이터를 사용하면 중복된 코드를 줄이고 코드를 모듈 단위로 관리하는 효과를 거둘 수 있습니다.이런 이유로 저희 Node.js Chapt...","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/finance-tips/img-financetip-og2.png","imageType":"기본 이미지"},"relatedPostConfig":{"id":2326,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":560,"name":"송현지","slug":"hyeonji-song","shortDescription":"Node.js Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/hyeonji-song.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"데코레이터는 비즈니스와 상관 없는 로직들을 숨기면서 기능을 변경하거나 확장할 수 있게 합니다. 또한 여러 클래스에서 반복되는 공통 관심사가 있을 때 데코레이터를 사용하면 중복된 코드를 줄이고 코드를 모듈 단위로 관리하는 효과를 거둘 수 있습니다.\n\n\n이런 이유로 저희 Node.js Chapter에서도 데코레이터를 적극 활용하고 있습니다. 하지만 NestJS에서는 데코레이터를 만들 때 다음과 같은 질문들이 있었습니다.\n\n데코레이터에서 Provider를 사용해야할 때 어떻게 Provider에 접근할 수 있을까?\n메타데이터를 쓰는 NestJS 데코레이터를 일반 데코레이터와 사용해도 괜찮을까?\nNestJS에서 데코레이터를 만들기 위해서는 NestJS의 DI와 메타 프로그래밍 환경 등을 고려해야 합니다. 그래서 이 글을 통해 NestJS에서는 어떻게 데코레이터를 만드는지 살펴보고, 앞의 두 질문들을 고려하여 NestJS 환경에 맞는 데코레이터를 만들어보려고 합니다.\n\n들어가기 전에, 만약 데코레이터나 메타데이터가 생소하시다면 아래 문서들을 읽어보시는 걸 추천드립니다.\n\nTypescript Decorator\nreflect-metadata\n\nTestService가 있을 때, 캐싱 로직을 Cacheable 데코레이터를 사용해 비즈니스 로직과 분리하려고 합니다.Cacheable 데코레이터에서 CacheManager라는 Provider를 사용하려면 어떻게 접근해야 할까요?\n\n\nCacheManager Provider를 export하는 CacheModule을 import 해봅시다.\n\n\n\nTestModule에서 CacheModule을 import하고 있긴 하지만 TestService에서 CacheManager 를 주입하지 않는 이상 Cacheable에서 CacheManager에 접근할 방법이 없습니다. Cacheable 데코레이터를 사용하려면 클래스에 항상 CacheManager를 주입해주어야 하는 불편함이 있습니다.\n\n게다가 CacheManager를 넣어준다고 해도 멤버 이름을 cache 로 강제해야 합니다. 가능한 방법이지만 휴먼 에러가 발생할 수 있어 좋은 방법은 아닙니다.\n\n그렇다면 NestJS 메서드 데코레이터는 어떻게 되어있을까요?\n\nNestJS가 데코레이터를 등록하는 과정은 ‘마킹 - 조회 - 등록’로 크게 세 단계로 나뉩니다. Cron 메서드 데코레이터를 예로 들어보겠습니다.\n\n\n마킹 - SetMetadata라는 함수로 특정 메서드에 CRON 심볼을 메타데이터 키로 등록합니다.\n조회 - 모듈이 초기화되는 시점에 DiscoveryServiced와 MetadataScanner로 모든 Provider 클래스를 순회하며 CRON 심볼을 메타데이터로 가지고 있는 메서드들을 찾습니다.\n등록 - 메서드를 찾았으면 해당 메서드를 크론 잡으로 등록합니다.\nNestJS에서 제공하는 SetMetadata와 DiscoverService, 그리고 MetadataScanner를 사용하면, 특정 클래스나 메서드만 필터링하여 IoC 내 다른 Provider를 사용해 원하는 로직들을 적용할 수 있습니다.\n\nSetMetadata\nSetMetadata는 타겟(클래스, 메서드)에 메타데이터를 마킹하는 데코레이터를 반환하는 함수입니다. NestJS의 코드를 보면 아래와 같습니다. setMetadata 코드\n\n\nReflect.defineMetadata(metadataKey, metadataValue, class or method);\n\nSetMetadata 함수 내부에서는 *Reflect.defineMetadata 메서드를 통해 타겟 객체에 metadataKey를 키, metadataValue를 값으로 하는 내부 슬롯을 정의합니다. ([[Metadata]] )*Reflect 는 reflect-metadata 라이브러리가 설치되어있는 경우 사용할 수 있습니다. 메타데이터를 정의하거나 조회하는 데 사용합니다.\n\nSetMetadata(KEY, value) -> CustomDecorator;\n\nSetMetadata의 리턴값은 클래스, 메서드 데코레이터로 사용 가능합니다. 해당 데코레이터로 타겟 클래스나 메서드에 대한 메타데이터를 설정할 수 있습니다.\n\n\nDecoratedClass에 SOMETHING 심볼을 메타데이터 키, 'KEY1'을 메타데이터 값으로 등록합니다.\n\nDiscoveryService\nNestJS는 DiscoveryModule 을 제공합니다. DiscoveryModule의 DiscoveryService에서는 내부적으로 modulesContainer를 사용하여 모든 모듈의 Controller와 Provider 클래스를 조회할 수 있습니다.\n\nDiscoverService를 사용하여 모든 Provider 클래스를 순회하며, SetMetadata로 등록했던 메타데이터 키로 특정 Provider를 필터링할 수 있게 됩니다.\n\nDiscoveryService 코드\n\n\nCustomDecorator 가 붙은 메서드를 찾는 과정을 예로 들어보겠습니다. 메타데이터 키는 CUSTOM_DECORATOR  심볼이고, 메타데이터 값은 test-value 입니다.\n\n\n아래의 explorerService.find(CUSTOM_DECORATOR) 메서드를 실행하면 어떻게 될까요?\n\n\n첫번째 필터: filter((wrapper) => wrapper.isDependencyTreeStatic())\n\nrequest scope가 아닌 싱글톤 프로바이더만 필터링합니다.\n\n두번째 필터: Reflect.getMetadata(metadataKey, metatype)\n\n해당 필터는 메타데이터가 등록된 클래스만 필터링합니다.\n\n\nmetatype 은 class TestService 와 같이 해당 Provider의 클래스를 의미합니다.\n\nReflect.getMetadata(metadataKey, metatype) 은 metatype(클래스)에 metadataKey로 등록된 메타데이터의 값을 가져옵니다. TestService 클래스의 경우 메타데이터 키는 CUSTOM_DECORATOR 이고 값은 test-value 입니다.\n\n만약 등록된 메타데이터가 없으면 undefined를 반환하고 해당 Provider는 필터링됩니다.\n\nMetadataScanner\n앞의 DiscoverService의 예시에서는 데코레이팅된 메서드를 가진 인스턴스에 접근하는 데 그쳤습니다. 실제 데코레이팅된 메서드에 접근하기 위해서는 DiscoveryModule에서 제공하는 MetadataScanner 를 사용해야 합니다.\n\nMetadataScanner 코드\n\n\nscanFromPrototype 는 getAllFilteredMethodNames 메서드로 인스턴스의 모든 메서드 이름들을 가져와 인자로 받은 callback을 실행시킵니다. 이 중에서 메타데이터가 있는 메서드만 필터링합니다.\n\nscanFromPrototype 의 callback 파라미터에서 인스턴스 메서드에 접근할 수 있습니다. 이제 메서드에 접근해 데코레이팅 함수로 덮어씌울 수 있습니다.\n\nSetMetadata, DiscoveryService, MetadataScanner 모든 재료들이 모였으니 Provider에 접근 가능한 메서드 데코레이터를 만들어봅시다.\n\nCacheable 데코레이터\n\n메서드에 CACHEABLE 심볼을 메타데이터 키로, ttl을 메타데이터 값으로 설정합니다.\n\n\nCacheDecoratorRegister 클래스\n\n\n해당 클래스를 모듈의 provider에 등록하면, onModuleInit 단계에서 @Cacheable로 데코레이팅된 메서드를 찾아 기존 메서드를 덮어씌웁니다.\n\n메서드 데코레이터를 만드는 과정은 다음과 같습니다.\n\n#1. 모든 Provider 클래스를 순회하며\n\n#2. 특정 메타데이터가 등록된 메서드를 찾아\n\n#3. 기존 메서드를 덮어씌웁니다.\n\n#3의 과정에서, CacheDecoratorRegister 생성자에 주입한 CacheManager를 사용할 수 있습니다.\n\n그런데 메서드 데코레이터를 만들 때마다 매번 이렇게 복잡한 과정을 거쳐야하는 걸까요? 저희 챕터에서는 메서드 데코레이터마다 반복되는 과정을 AopModule이라는 모듈로 해결했습니다.\n\n해당 모듈은 2022년 12월에 오픈소스로 공개되었습니다. 현재 npm에서 @toss/nestjs-aop 라이브러리를 다운 받아 사용해보실 수 있습니다.\n\n관련해서 NestJS 밋업에서 발표한 자료도 있으니 함께 참고하시면 좋을 듯 합니다. :)\n\nAopModule\nAopModule이 데코레이터들을 등록하는 과정은 이렇습니다.\n\n\n간단히 설명하면\n\nAspect 데코레이터가 붙은 클래스를 찾고 (CacheableDecorator)\nCacheable 데코레이터가 붙은 함수를 찾아 (FooService.foo)\n1번 클래스의 wrap 함수로 2번의 함수를 감쌉니다. (CacheableDecorator.wrap)\n코드를 보며 좀 더 자세히 설명해볼게요.\n\n1. Aspect 데코레이터 사용\nAspect 데코레이터\n\n\n데코레이터 사용\n\n\n데코레이터 로직을 실행할 클래스에 ASPECT 라는 심볼을 메타데이터로 설정합니다.\n\n2. 데코레이터 생성\n\n특정 심볼(또는 문자열)을 메타데이터 키로 하여 SetMetadata로 원하는 데코레이터를 만듭니다.\n\n3. LazyDecorator 구현\nAopModule에 등록되는 모든 데코레이터들은 LazyDecorator 인터페이스를 구현해야 합니다. 데코레이팅 하는 시점을 모듈이 초기화되는 시점으로 미루기 때문에 LazyDecorator라고 합니다.\n\nLazyDecorator 인터페이스\n\n\nCacheLazyDecorator 구현\n\n\n접근하고자 하는 Provider는 이제 생성자에 주입하여 사용할 수 있습니다.\n\n4. AutoAspectExecutor\nonModuleInit 단계에서 AopModule의 AutoAspectExecutor 가 ASPECT가 붙은 데코레이터 클래스들의 wrap 함수를 실행시키며 기존 메서드를 덮어씌웁니다.\n\nAutoAspectExecutor 코드\n\n\nProvider에 접근 가능한 데코레이터를 만드는 과정을 다시 요약하면 이렇습니다.\n\nSetMetadata로 필터링할 클래스에 메타데이터를 등록하고\nDiscoveryService로 모든 Provider를 조회하며\n등록된 Metadata로 특정 클래스나 메서드를 필터링하여 원하는 작업을 하면 됩니다.\n\n\nProvider에 접근이 필요없는 경우 일반 메서드 데코레이터를 구현하면 될 것입니다. 하지만 메타데이터를 사용하는 NestJS 데코레이터를 일반 데코레이터와 함께 사용해도 괜찮을까요?\n\n결론부터 말하자면 둘을 함께 사용하면 예상치 못한 버그가 발생할 수 있습니다.\n\n일반 메서드 데코레이터를 사용하면 안되는 이유\n메타데이터를 등록하는 다른 데코레이터와 함께 쓰이는 경우, 기존 메서드가 덮어씌워지면서 프로토타입에 등록된 메타데이터가 사라질 수 있습니다.\n\n\nOnError 데코레이터는 기존 메서드를 새로운 메서드로 덮어씌웁니다.\n\n아래 코드에서는 메타데이터를 등록하는 RegisterMetadata 데코레이터와 OnError 데코레이터를 함께 사용하고 있습니다. 데코레이터 선언 순서에 따라 기존에 등록된 메타데이터는 사라질 수 있습니다.\n\n아래 메서드 중에 Reflect.getMetadata를 했을 때 메타데이터가 사라지는 메서드는 무엇일까요?\n\n\n정답은 test 메서드입니다. 실행 결과는 타입스크립트 플레이그라운드에서 직접 확인하실 수 있습니다.\n\n\n왜 이렇게 되는 걸까요? 데코레이터의 실행 순서가 힌트입니다.\n\ng∘f(x) = g(f(x)) 와 같은 합성 함수가 있을 때 선언은 g가 f보다 먼저 되었지만 실행은 f 함수가 먼저 실행됩니다. 마찬가지로 데코레이터는 평가될 때는 선언된 순서대로 위에서 아래로, 실행될 때는 아래에서 위로 실행됩니다.\n\n\nRegisterMetadata에서 Reflector.defineMetadata가 먼저 실행되고 그 다음 OnError 데코레이터가 기존 함수를 덮어씌웁니다.\n\n덮어씌워지면서 기존에 메타데이터가 저장된 프로토타입과 끊기게 되고 test 메서드에서 메타데이터를 찾을 수 없게 됩니다.\n\n이런 사례도 있을 수 있습니다.\n\n\n@nestjs/schedule 의 Cron 데코레이터 역시 CRON 심볼을 메타데이터로 등록합니다. 모듈이 초기화되는 시점에 해당 메타데이터가 등록된 메서드들을 조회하여 cron job을 등록합니다.\n\n하지만 OnError 데코레이터가 Cron 데코레이터 이후에 실행됨으로써 메타데이터가 사라지게 되고, NestJS에서는 task 메서드를 찾지 못해 cron job을 등록하지 못하게 됩니다.\n\n이렇듯 일반 메서드 데코레이터를 NestJS 환경에서 그냥 사용하게 되면 개발자의 실수에 의해 코드의 동작이 바뀔 수 있습니다. 데코레이터 실행 순서나 메타데이터 환경에 대해 알고 있지 못하다면 이런 류의 버그를 찾는 데는 시간이 오래 걸릴 지도 모릅니다.\n\n이를 방지하기 위해서는 메타데이터를 고려하여 데코레이터를 생성해야 합니다.\n\n메타데이터를 유지하는 데코레이터\n메타데이터를 유지하는 가장 naive한 방법은, 오버라이딩 되기 전에 메타데이터를 저장해둔 뒤 오버라이딩이 끝나면 메타데이터를 다시 등록해주는 것입니다.\n\nOnErrorPreserveMeta 코드\n\n\n직관적이지만 매번 Decorator를 만들어줄 때마다 이런 과정을 거쳐야 하는 게 불편합니다. 이를 해결하는 좀 더 간단한 방법이 있습니다.\n\n프로토타입을 사용해 메타데이터 유지하기\nSetMetadata 파트에서 Reflect.defineMetadata 는 타겟 객체에 [[Metadata]] 라는 내부 슬롯을 정의한다고 말씀드렸습니다.\n\n\n내부 슬롯 또한 프로토타입의 내부 프로퍼티이니, 기존 프로토타입에 메타데이터 내부 슬롯이 저장되어있을 것입니다. 따라서 새롭게 정의한 메서드에 기존 프로토타입을 연결해주면 됩니다.\n\n변경된 OnErrorPreserveMeta 코드\n\n\nObject.setPrototypeOf(arg1, arg2) 은 arg1 객체의 프로토타입을 arg2로 설정합니다.\n\n기존 메서드를 덮어씌운 후 Object.setPrototypeOf(wrapper, originMethod)로 originMethod를 wrapper의 프로토타입으로 설정해주면 메타데이터가 유지됩니다.\n\n\n메타데이터와 NestJS의 DiscoveryModule 을 사용하여 NestJS의 IoC 컨테이너에 접근할 수 있는 데코레이터, 그리고 메타데이터를 유지할 수 있는 데코레이터를 만들어보았습니다.\n\n메타데이터 태깅, DiscoveryModule, 프로토타입을 사용해 NestJS 환경에 맞는 데코레이터를 만들 수 있었습니다. 이 글을 통해 더욱 더 NestJS의 Aop 패턴에 맞는 프로그래밍을 하게 되었기를 바랍니다.\n\n또한 토스 Node.js 챕터는 토스의 다양한 제품과 라이브러리 개발을 위해 팀원들의 지속적인 성장이 중요하다고 믿으며, 이를 위해 코드 리뷰, 스터디와 엔지니어링 세미나 등을 통해 꾸준히 공부하고 공유하는 자리를 가지고 있으니 많은 관심 부탁드립니다.\n\n\nReferences\nhttps://zuminternet.github.io/nestjs-custom-decorator/\nhttps://github.com/nestjs/nest\nhttps://github.com/nestjs/swagger/issues/217\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf","isDisplayingFeedback":true},{"id":21019,"updatedTime":"2023-04-12T17:25:56+09:00","createdTime":"2023-04-12T16:02:41+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"TypeScript 타입 시스템 뜯어보기: 타입 호환성","subtitle":"타입호환성은 무엇이며 왜 필요할까요? 타입호환이 지원되지 않는 경우가 존재한다는 것을 아셨나요? 평소 익숙했던 개념들에 대해 질문을 던져가며 TypeScript 타입 시스템에 관해 심도있게 알아보고자 합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/10/tech-article-ts.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/10/tech-article-ts.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"typescript-type-compatibility","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-10-26T00:38:54+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21019,"title":null,"description":"토스 Node.js 챕터에서는 높은 코드 가독성과 품질을 위해 TypeScript의 타입 시스템을 적극적으로 활용하고 있고 이에 대한 이해도를 높이기 위해 스터디를 꾸준히 진행하고 있습니다. TypeScript의 타입 시스템에 대해 공부해보던 중 알게된 흥미로운 몇가지 토픽들을 소개하려...","urlSlug":"typescript-type-compatibility","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"TypeScript 타입 시스템 뜯어보기: 타입 호환성","description":"타입 호환성은 무엇이며 왜 필요할까요? 타입호환이 지원되지 않는 경우가 존재한다는 것을 아셨나요? 평소 익숙했던 개념들에 대해 질문을 던져가며 TypeScript 타입 시스템에 관해 심도있게 알아보고자 합니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://og.toss.tech?title=TypeScript%0D%0A%ED%83%80%EC%9E%85%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EB%9C%AF%EC%96%B4%EB%B3%B4%EA%B8%B0%3A%0D%0A%ED%83%80%EC%9E%85%20%ED%98%B8%ED%99%98%EC%84%B1&imageUrl=https%3A%2F%2Fstatic.toss.im%2Fassets%2Ftoss-tech%2Ftech-article-ts-og.png&v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2339,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":568,"name":"김병묵","slug":"byeongmuk-kim","shortDescription":"Node.js Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/byeongmuk-kim.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스 Node.js 챕터에서는 높은 코드 가독성과 품질을 위해 TypeScript의 타입 시스템을 적극적으로 활용하고 있고 이에 대한 이해도를 높이기 위해 스터디를 꾸준히 진행하고 있습니다. TypeScript의 타입 시스템에 대해 공부해보던 중 알게된 흥미로운 몇가지 토픽들을 소개하려 합니다. 그 중 한가지로 이번글에서는 “타입 호환성 (type compatibility)”에 대해 알아보고자 합니다.\n\nTypeScript 공식문서 타입 호환성에 관한 글을 보면 아래와 같이 소개하고 있습니다.\n\nTypeScript의 타입 호환성은 구조적 서브타이핑(structural subtyping)을 기반으로 합니다. 구조적 타이핑이란 오직 멤버만으로 타입을 관계시키는 방식입니다. 명목적 타이핑(nominal typing)과는 대조적입니다. TypeScript의 구조적 타입 시스템의 기본 규칙은 y가 최소한 x와 동일한 멤버를 가지고 있다면 x와 y는 호환된다는 것입니다.\n위 내용에 대해 하나씩 이해해봅시다. 우선 강한 타입 시스템을 통해 높은 가독성과 코드 품질을 지향하는 TypeScript가 왜 타입 호환성을 지원하는 것일까요? 이 경우 타입 안정성에 문제가 생기게 되는 것은 아닐까요? 아래 예시를 통해 타입 호환성이 왜 필요한지 살펴보겠습니다.\n\n\n위와 같이 음식 Food 타입의 객체를 인자로 받아 간단한 칼로리 계산 공식으로 주어진 음식의 칼로리를 구하는 calculateCalorie 함수가 있습니다. 타입과 함수는 아래와 같이 구현되어 있습니다.\n\n\n한편, 개발자가 코드를 작성하는 과정에서 (의도했거나 혹은 실수로) calculateCalorie 함수 인자에 여러가지 타입의 객체를 전달해본다고 가정해봅시다. 이 경우 TypeScript 타입 시스템은 프로그램이 타입 오류를 일으킬 가능성을 검사하게 됩니다.\n\n\n위 3가지 케이스에 대해 Type Checker가 어떻게 판단하는 것이 좋을까요?\n\n개발자가 정의한 Food 타입과 동일한 타입인 경우 (1번) 오류 없음이 명확하며, Computer 타입과 같이 다른 타입이며 칼로리 계산이 불가능한 경우 (2번) 오류로 판단하는 것이 명확합니다. 하지만, 햄버거를 의미하며 음식의 한 종류인 Burger 타입이 전달되는 경우 (3번) 어떻게 판단하는 것이 맞을까요?\n\n\n심지어 Burger 타입이 위와 같이 Food 타입을 상속하며 칼로리 계산에 필요한 모든 프로퍼티를 포함하고 있어 런타임 상에서 정상적으로 동작한다면 이를 타입 오류라고 판단하는게 올바른 걸까요?\n\n이처럼 실제로 정상적으로 동작할 수 있는 올바른 코드라면 타입 시스템은 개발자의 의도에 맞게 유연하게 대응하여 타입 호환성을 지원하는 것이 더 좋을 수 있습니다. 이러한 유연성을 위해 TypeScript 타입 시스템은 부분적으로 타입 호환을 지원하고 있습니다.\n\n한편 위에 예시에서 Computer 타입 사례처럼 타입오류로 판단하는 것이 명확한 경우가 있으며, 타입 안정성을 해치면서까지 유연함을 제공하는 것은 바람직하지 못합니다. 이를 위해서는 어떠한 경우에 호환을 허용할 것인지에 대한 명확한 규칙이 필요합니다. 이러한 규칙 중 프로그래밍 언어들에서 널리 활용되는 방식으로 명목적 서브타이핑(nominal subtyping)과 구조적 서브타이핑(structural subtpying)이 있습니다.\n\n명목적 서브타이핑은 아래와 같이 타입 정의 시에 상속 관계임을 명확히 명시한 경우에만 타입 호환을 허용하는 것입니다. 이 방법을 통해 타입 오류가 발생할 가능성을 배제하고, 개발자의 명확한 의도를 반영할 수 있습니다.\n\n\n한편, 구조적 서브타이핑은 아래와 같이 상속 관계가 명시되어 있지 않더라도 객체의 프로퍼티를 기반으로 사용처에서 사용함에 문제가 없다면 타입 호환을 허용하는 방식입니다. 아래 예시를 보면 비록 상속 관계임을 명시하지는 않았지만 burger 변수는 Food 타입의 프로퍼티를 모두 포함하고 있고 따라서calculateCalorie 함수 실행과정에서 오류가 발생하지 않습니다.\n\n\n구조적 서브타이핑 방식은 타입 시스템이 객체의 프로퍼티를 체크하는 과정을 수행해주므로써, 명목적 서브타이핑과 동일한 효과를 내면서도 개발자가 상속 관계를 명시해주어야 하는 수고를 덜어주게 됩니다. 참고로, 구조적 서브타이핑은 “만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다.” 라는 의미에서 덕 타이핑 (duck typing) 이라고도 합니다.\n\n\nTypeScript Type Checker는 구조적 서브타이핑을 기반으로 타입 호환을 판단합니다.\n\nTypeScript는 구조적 서브타이핑을 지원하며, 명목적 서브타이핑만 지원하는 C#, Java 등의 언어는 명시적으로 상속 관계를 명시해주어야 타입 호환이 가능합니다.\n\n💡  한편, 여기서부터 좀 더 본격적인 이야기를 다루어 보겠습니다.\n위 구조적 서브타이핑 예시의 코드는 타입 호환성에 따라 타입 오류가 발생하지 않지만, 아래 코드의 경우 컴파일 과정에서 Argument is not assignable to parameter of type 'Food' 라는 타입 오류가 발생하게 됩니다. 글을 더 읽으시기에 앞서 실제로 TS Playground를 통해 오류를 확인해보시고 다양하게 테스트해보시는 것도 추천합니다.\n\n\n왜 위 코드는 타입 호환이 지원되지 않는 것일까요? 처음에 이 오류를 마주쳤을 때 이런저런 테스트를 해보며 함수에 값을 바로 인자로 전달하는 경우만 타입 호환이 지원되지 않는 것 같다고 유추하기는 했으나 조금 더 구체적인 규칙과 이렇게 예외가 발생하는 이유에 대해 이해해보고자 했습니다.\n\n결과적으로 TypeScript 컴파일러 코드 상의 구현로직과 위 이슈와 연관된 TypeScript Github PR을 통해 이해할 수 있었습니다. 이에 대해 알아보기 위해 우선 TypeScript 컴파일러가 동작하는 방식에 대해 간략히 살펴보겠습니다.\n\nTypeScript 컴파일러가 동작하는 방식에 관해 아래 영상에 자세히 소개되어 있으며, 이 중 몇가지 내용만 요약하여 살펴보겠습니다.\n\nhttps://www.youtube.com/watch?v=X8k_4tZ16qU\n\nTypeScript 컴파일러의 역할은 TypeScript 소스코드를 AST (Abstract Syntax Tree)로 변환한 뒤, 타입 검사를 수행하고, 그 후 JavaScript 소스코드로 변환하는 과정을 담당합니다.\n\nTypeScript 소스코드를 AST로 변환하는 과정은 parser.ts, scanner.ts , 타입 검사를 수행하는 과정은 binder.ts, checker.ts, AST를 JavaScript 소스코드로 변환하는 과정은 emitter.ts, transformer.ts 등의 파일이 담당하고 있습니다.\n\n\n실제로 TypeScript Github의 compiler 디렉토리에 가면 위 코드 파일이 어떤식으로 구현되어 있는지 확인해볼 수 있으며, 이번 글에서 다루고 있는 주제인 구조적 서브타이핑과 타입 호환에 관한 부분은 타입 검사와 가장 연관이 높은 checker.ts 파일의 hasExcessProperties() 함수에서 처리하고 있었습니다.\n\n아래는 checker.ts 코드 중 타입 호환의 예외가 발생하는 지점의 코드를 주요한 부분만 남기고 간소화한 것입니다. 주석과 함께 봐주시면 좋을 것 같습니다.\n\n\n지면상 다소 간소화한 코드만 남겨두었지만, 함수에 인자로 들어온 값이 FreshLiteral 인지 아닌지 여부에 따라 조건분기가 발생하여 타입 호환 허용 여부가 결정된다는 것을 확인할 수 있었습니다.\n\n그렇다면 Fresh Literal 이란 무엇이며, 왜 이 경우에는 타입 호환의 예외가 발생하도록 되어 있는 것일까요?\n\nTypeScript는 구조적 서브타이핑에 기반한 타입 호환의 예외 조건과 관련하여 신선도 (Freshness) 라는 개념을 제공합니다. 모든 object literal은 초기에 “fresh” 하다고 간주되며, 타입 단언 (type assertion) 을 하거나, 타입 추론에 의해 object literal의 타입이 확장되면 “freshness”가 사라지게 됩니다. 특정한 변수에 object literal을 할당하는 경우 이 2가지 중 한가지가 발생하게 되므로 “freshness”가 사라지게 되며, 함수에 인자로 object literal을 바로 전달하는 경우에는 “fresh”한 상태로 전달됩니다.\n\n한편, TypeScript Github PR (2015년 7월) 의 논의에 따르면, fresh object인 경우에는 예외적으로 타입 호환을 허용하지 않기로 했음을 확인할 수 있습니다. 그러한 이유에 대해 살펴보겠습니다.\n\n\n구조적 서브타이핑에 기반한 타입 호환은 유연함을 제공한다는 이점이 있지만, 위 코드 사례와 같이 코드를 읽는 다른 개발자의 입장에서 함수가 실제 다루는 것보다 더 많은 데이터를 받아들인다는 오해를 불러일으킬 수 있고, 프로퍼티 키에 대한 오타가 발생하더라도 오류가 확인되지 않는 부작용이 있습니다.\n\n한편, fresh object를 함수에 인자로 전달한 경우, 이는 특정한 변수에 할당되지 않았으므로 어차피 해당 함수에서만 사용되고 다른 곳에서 사용되지 않습니다. 이 경우 유연함에 대한 이점보다는 부작용을 발생시킬 가능성이 높으므로 굳이 구조적 서브타이핑을 지원해야할 이유가 없습니다.\n\n\nTypeScript Type Checker는 구조적 서브타이핑을 기반으로 타입 호환을 판단하되,Freshness에 따라 예외를 둡니다.\n\n이처럼 타입 호환성은 유연함이라는 이점을 제공하지만 그로 인해 부작용이 발생할 수 있으므로, 이에 대한 절충안으로 타입 호환을 제공해서 얻는 이점이 거의 없는 fresh object에 대해서는 호환성을 지원하지 않기로 논의되어 TypeScript 컴파일러 코드에 반영된 것을 확인해볼 수 있었습니다.\n\n한편, 그럼에도 개발자가 fresh object에 대해서 타입 호환을 허용하고자 한다면 아래와 같이 함수 매개변수 타입에 index signature를 포함시켜두어 명시적으로 타입 호환을 허용시키는 것이 가능합니다. 또는 tsconfig 상에 suppressExcessPropertyErrors 를 true로 설정하는 방식도 가능합니다. (이 또한 동일한 PR 논의에 정의되어 있습니다.)\n\n\n또한 반대로 모든 경우에 대해 타입 호환을 허용하지 않도록 강제하는 것도 가능한데 이를 위해 사용할 수 있는 기법이 Branded type (또는 Branding type) 입니다. 아래와 같이 의도적으로 __brand 와 같은 프로퍼티를 추가시켜, 개발자가 함수의 매개변수로 정의한 타입 외에는 호환이 될 수 없도록 강제하는 기법입니다. 온도(섭씨, 화씨)나 화폐단위(원, 달러, 유로)와 같이 같이 number 타입이지만 서로 다를 의미를 가질 수 있어 명시적인 구분이 필요할 때 사용해볼 수 있습니다.\n\n\n앞선 글을 통해 이해한 타입 호환의 이점과 부작용에 대한 이해를 바탕으로 개발자는 자신의 프로젝트를 진행하는 과정에서 필요에 맞게 index signature, tsconfig > suppressExcessPropertyErrors, branded type 등을 통해 타입 호환성의 범위를 선택하여 개발하는 것이 가능할 것입니다.\n\n\nTypeScript Type Checker는 내부적인 규칙에 따라 타입 호환을 판단하지만,개발자가 필요에 따라 선택하는 것이 가능합니다.\n\n이번글의 내용을 모두 요약하면 아래와 같습니다.\n\n타입 검사의 안정성과 유연함 사이에서 절충안으로 도입된 개념이 타입 호환성입니다. 그리고 타입 호환성을 지원하는 방법과 관련하여 개발자에게 명시적 선언을 어디까지 요구할 것인지에 대한 선택지가 존재합니다.\nTypeScript는 구조적 서브타이핑에 기반한 타입 호환을 통해 개발자의 명시적 선언을 줄여주는 한편 이로 인한 부작용을 개선하고자 freshness에 기반한 예외조건을 두었고, Index Signature와 Branded type 등의 방식을 통해 개발자가 명시적으로 선택할 수 있는 선택지를 만들어두었습니다.\n프로그래밍 언어마다 타입 검사가 동작하는 방식이 다르며 이는 해당 언어를 개발한 커뮤니티의 논의와 의사결정에 따라 선택된 결과라고 볼 수 있습니다. 본 주제 외에도 TypeScript 컴파일러 코드와 Github PR을 살펴보면 흥미로운 논의와 토픽들을 확인해볼 수 있습니다.\n토스 Node.js 챕터는 토스의 다양한 제품과 라이브러리 개발을 위해 팀원들의 지속적인 성장이 중요하다고 믿으며, 이를 위해 꾸준히 공부하고 공유하는 자리를 가지고 있으니 많은 관심 부탁드립니다.\n\n토스 Node.js Chapter 채용 공고 👉 바로가기\n\n감사합니다.","isDisplayingFeedback":true},{"id":21031,"updatedTime":"2023-04-12T17:25:56+09:00","createdTime":"2023-04-12T16:04:03+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"토스증권 QA Team을 소개합니다","subtitle":"이 글은 토스증권 QA Team에 입사를 고려 중인 지원자들을 위해 작성된 글입니다. 토스증권 QA Manager 하는 역할과 일하는 방식은 어떻게 다를까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/10/tech_M.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/10/tech_M.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"tosssec-qateam","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-10-25T15:48:53+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21031,"title":null,"description":"안녕하세요. 저는 3년 전 토스의 첫 QA Manager로 입사해서 현재 토스증권 QA팀에서 일하고 있는 곽수정입니다. 길다면 긴 3년이란 시간 동안 즐겁고 재밌게 일할 수 있었던 토스와 토스증권의 QA팀을 소개해보려고 해요.초창기의 토스팀은 사용자에게 빠른 제품/서비스를 제공하는데 많...","urlSlug":"tosssec-qateam","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"토스증권 QA Team을 소개합니다","description":"이 글은 토스증권 QA Team에 입사를 고려 중인 지원자들을 위해 작성된 글입니다. 토스증권 QA Manager 하는 역할과 일하는 방식은 어떻게 다를까요?","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://og.toss.tech?title=%ED%86%A0%EC%8A%A4%EC%A6%9D%EA%B6%8C%20QA%20Team%EC%9D%84%20%EC%86%8C%EA%B0%9C%ED%95%A9%EB%8B%88%EB%8B%A4&imageUrl=https%3A%2F%2Fstatic.toss.im%2Fassets%2Ftoss-tech%2Fqa-og.png&v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2340,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":569,"name":"곽수정","slug":"sujeong-kwak","shortDescription":"QA Manager","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/sujeong-kwak.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"안녕하세요. 저는 3년 전 토스의 첫 QA Manager로 입사해서 현재 토스증권 QA팀에서 일하고 있는 곽수정입니다. 길다면 긴 3년이란 시간 동안 즐겁고 재밌게 일할 수 있었던 토스와 토스증권의 QA팀을 소개해보려고 해요.\n\nQA가 없었던 토스팀, 왜 첫 번째 QA Manager를 채용하게 되었을까요?\n초창기의 토스팀은 사용자에게 빠른 제품/서비스를 제공하는데 많은 노력을 기울이고 있었어요. 제품의 퀄리티 역시 PO, 개발자 등 제품을 만드는 ‘메이커(Maker)’들이 간단한 테스트를 통해 관리하고 있었죠. 버그가 발생하더라도 누구보다 빠르게 대응할 수 있다는 강한 자신감과 팀원 개개인의 오너십이 있었기 때문에 가능한 일이었다고 생각해요.\n\n이러한 동력에 힘입어 토스는 시장에서 빠른 속도감을 무기로 존재감을 높여갔어요. 그만큼 우리가 제공하는 제품과 서비스의 수도 증가했죠. 이에 따라 메이커들이 제품을 만들면서, 동시에 높은 수준의 제품 안정성을 체크하고 유지하는 데 한계가 생기기 시작했어요. 이 시기에 토스팀에서도 QA 담당자의 필요성이 논의되기 시작했지만, QA가 진행하는 품질 테스트가 우리의 속도에 영향을 주지는 않을지 우려가 공존하기도 했답니다.\n\n시장에서의 빠른 속도만큼이나, 고객들에게 안정적이고 높은 퀄리티의 서비스를 제공하는 것도 중요하다고 믿었던 토스팀은 2019년 첫 번째 QA Manager를 채용하게 됩니다. 그게 바로 저고요!\n\n그럼 토스팀의 QA는 어떻게 일할까요?\nQA가 없던 회사에서 QA가 일하는 방식을 만들어 나가는 것은 아주 어려움이 많았어요. 일반적인 IT 회사에서는 서비스 출시 전에 테스트하는 것이 너무 당연한데요. 처음 토스에 입사했을 땐 이것도 알려야 할 만큼 어려움이 있었답니다.\n\n이전 회사의 경우, 기획팀에서 기획서를 작성한 후에 개발/QA팀에 공유해서 서비스 출시 일정을 결정했어요. 그래서 QA팀에서는 QA 중에 발견한 버그로 인해 출시 일정이 뒤로 밀리거나 개발이 늦어지지 않도록 Sanity Test(BVT)라는 절차를 만들어서 QA 가용 리소스를 확보하는 장치를 만들기도 했고요. 오히려 이러한 장치가 개발자와 QA 모두에게 업무적인 비효율을 초래해서 서비스 출시일이 미뤄지는 경우가 많다는 점이 아쉬웠어요.\n\n하지만 토스의 방식은 달라요.\n\nQA Manager는 다양한 툴을 통해 서비스와 관련된 크고 작은 변경 사항들을 미리 확인할 수 있어요. 접근 권한 또한 열려 있어서 개발자의 작업 상태를 확인할 수 있고요. 자체적으로 QA계획을 수립해서 작은 단위부터 미리 테스트를 시작할 수도 있고, 통합테스트(Integration Test) 및 모니터링과 같은 QA 단계도 직접 조율할 수 있어요.\n\nQA Manager가 테스트를 진행하지만, 살충제 패러독스(Pesticide Paradox)에 빠지지 않도록 개발자도 배포를 위한 Regression Test Case를 별도로 수행하고 있어요. 매주 랜덤으로 수행자를 지정한 뒤 테스트가 완료되어야만 앱 심사 등록 요청이 가능하도록 하고 있어요. 서비스를 만들어가는 담당자 모두가 안정적인, 높은 품질의 서비스를 제공하고자 하는 마음이 크기 때문에 가능한 방식이라고 생각해요.\n\n토스증권이 서비스를 처음 출시했을 땐, 어떻게 QA를 했을까요?\n토스증권 출범을 준비하던 시기에는 토스증권 소속 QA Manager가 전무한 상태였어요. 당시 토스 소속이었던 제가 파견을 나가 QA 업무를 지원해주고 있었죠.\n\n조직 내 QA 매니저가 없는 상태에서 새로운 분을 모셔오는건 정말 어려운 일이었어요. 그래서 외주업체에서 QA 테스트 전문가분들을 모셔와 MTS(모바일 트레이딩 시스템) 출시를 위한 테스트를 진행했어요.\n\n다시 말하면, 새로운 법인에서 메인 서비스를 출시하는데 단 3명의 QA 인력이 그 모든 품질 테스트를 담당했다는 것이죠.\n\n👀 “3명이라고요?? 그게 가능한 일인가요?”\n\n당연히, 저 혼자만 QA를 진행할 수는 없었어요.\n\n많은 팀원분들이 적극적으로 도움을 주셔서 가능했어요.\n\n토스증권이 서비스를 성공적으로 런칭할 수 있도록 같은 마음으로 바라봐주는 든든한 팀원분들이 없었다면 힘들었을 것 같아요. 당시 토스증권 팀원 총 70명 정도를 대상으로 클로즈 베타 테스트를 1~2회 정도 진행하였고, 토스커뮤니티의 타 계열사 팀원분들께도 사전 신청을 받아 150명을 대상으로 하는 추가 테스트도 진행했어요.\n\n이러한 과정을 통해 Edge Case를 발견하고 고객의 피드백도 미리 체험해볼 수 있었습니다. 제품에 진심인 팀원분들이 꼼꼼하게 피드백을 주시다 보니 서비스를 빠르게 개선해서 출시할 수 있었어요.\n\n(토스증권 서비스 출시 과정과 관련된 에피소드는 다음 포스팅에서 자세히 공개할께요)\n\n토스증권 QA팀은 어떤 업무를 하나요?\n홀로 QA Manager로 근무하던 때에는 리소스가 부족하니 고객 접점이 높은 프론트 서비스를 기준으로 QA 범위를 정했었어요.\n\n이제는 QA팀이 되어서 함께하는 든든한 동료분들이 있습니다. 각각 제품을 만드는 Silo/Team에 소속되어 프로덕트를 만드는 전 과정을 함께하고 있어요.\n\nQA가 일할 때 필요한 공통 정책을 정의하기도 하고 프로덕트의 QA 커버리지 확대를 위해 노력하고 있기도 합니다. QA Manager는 본인이 담당하고 있는 서비스를 대상으로 팀원들에게 탐색적 테스팅이나 Bug Bash를 제안하기도 해요. 주기적으로 QA Study도 진행하면서 자기 계발도 함께해요.\n\n최근에는 Test Automation Engineer를 채용하기도 했어요. UI Automation Testing 설계뿐만 아니라 QA팀에서 필요한 도구를 개발하는 업무까지 수행하고 계세요.\n\n토스증권 QA팀은 테스트 커버리지를 계속해서 넓혀가고 있습니다. 장기적으로는 QA 품질 서비스 지표를 만들어서 변하지 않는 북극성 같은 목표를 만들고자 해요.\n\n토스증권에서 QA로 근무하면서 가장 만족하는 점은 무엇인가요?\n제가 재직했던 여러 회사에서는 QA의 권한이 곧 QA 품질 보고서(Sign Off)라고 생각하는 경우가 많았어요. QA의 중요성을 주장하기 위해 보고서를 작성하느라 야근하는 일도 잦았죠. 품질팀에서는 버그나 장애에 대한 책임을 피하고자 테스트를 아웃소싱에 맡기는 경우도 많았습니다. QA에서 발견한 버그의 Priority, Severity를 고려하지 않고 품질 확보라는 명목으로 서비스 출시일 자체를 미뤄버리는 경우도 있었어요.\n\n서비스 출시일이 계속 뒤로 밀리고 있는 게 과연 회사를 위한 일이 맞는지는 아직도 공감되지 않아요.\n\n토스증권은 이러한 비효율적인 부분을 가장 지양합니다. 테스트케이스 수행 결과를 취합하고, Sign Off 결과에 대한 근거를 제공하기 위해 추가 이터레이션, Regression Test 일정을 확보하기 위해 문서 작업을 하는 등의 비효율이 없어요.\n\n서비스 출시를 할 때 QA가 허들이 되는 것이 아니라, 안정적인, 좋은 품질의 서비스를 제공하여 고객 만족을 추구한다는 점에서 토스증권 QA Manager로 근무하고 있는 것이 만족스러워요.\n\n토스증권에서는 어떠한 사람을 찾고 있나요? 🙋‍♂️🙋‍♀️\n토스증권과 함께 성장하는 QA Manager가 되기 위해서는 다음과 같은 부분이 중요하다고 말씀드리고 싶어요.\n\nQA에 대한 열정과 긍정적인 마음가짐을 바탕으로 토스증권 서비스의 품질을 향상시키기 위해 함께 고민할 수 있는, 고민하는 것을 즐기는 분\nQA 업무를 하시는 분들은 대부분 팀이 세팅되어있고 안정적으로 Iteration하고 있는 회사를 선호하시는 것 같아요. 새롭게 설립되는 QA팀의 경우, QA가 회사에서 꼭 필요한 역할이라는 것을 내부적으로 설득하는 것이 어렵기 때문일 수 있겠죠.\n\n토스증권은 팀원들이 QA의 중요성을 잘 알고 있고 QA팀이 설정해둔 목표 또한 명확합니다. 빠르게 성장하고 있는 서비스와 함께 QA 커버리지를 확대하기 위해 함께할 동료분들을 찾고 있어요.\n\n토스증권에서 메이커와 같은 시선으로 제품의 전 과정을 함께하는 QA Manager가 되어보세요!\n\n토스증권 QA Manager 채용공고 👉 바로가기\n\n토스증권 Test Automation Engineer 채용공고 👉 바로가기","isDisplayingFeedback":true},{"id":21005,"updatedTime":"2023-04-12T17:25:55+09:00","createdTime":"2023-04-12T16:01:01+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"CommonJS와 ESM에 모두 대응하는 라이브러리 개발하기: exports field","subtitle":"Node.js에는 두 가지 Module System이 존재합니다. 토스 프론트엔드 챕터에서 운영하는 100개가 넘는 라이브러리들은 그것에 어떻게 대응하고 있을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/10/techblog-11-node-js.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/10/techblog-11-node-js.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"commonjs-esm-exports-field","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-10-04T17:37:32+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21005,"title":null,"description":"토스 프론트엔드 챕터에서는 개발 생산성을 극대화하기 위해 코드를 지속적으로 라이브러리로 만들고 있습니다. 그 결과 지금은 100개가 넘는 라이브러리를 운영하고 있습니다.Node.js 12부터 ECMAScript Modules라는 새로운 Module System이 추가되면서, 기존의 Co...","urlSlug":"commonjs-esm-exports-field","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"CommonJS와 ESM에 모두 대응하는 라이브러리 개발하기: exports field","description":"Node.js에는 두 가지 Module System이 존재합니다. 토스 프론트엔드 챕터에서 운영하는 100개가 넘는 라이브러리들은 그것에 어떻게 대응하고 있을까요?","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://og.toss.tech?title=CommonJS%EC%99%80%20ESM%EC%97%90%20%EB%AA%A8%EB%91%90%20%EB%8C%80%EC%9D%91%ED%95%98%EB%8A%94%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%20%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0%3A%20exports%20field&imageUrl=https%3A%2F%2Fstatic.toss.im%2Fassets%2Fhomepage%2Ftosstech%2Fog%2Ftechblog-11-node-js-og.png&v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2325,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":559,"name":"장호승","slug":"hoseung-jang","shortDescription":"Frontend Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/hoseung-jang.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스 프론트엔드 챕터에서는 개발 생산성을 극대화하기 위해 코드를 지속적으로 라이브러리로 만들고 있습니다. 그 결과 지금은 100개가 넘는 라이브러리를 운영하고 있습니다.\n\nNode.js 12부터 ECMAScript Modules라는 새로운 Module System이 추가되면서, 기존의 CommonJS라는 Module System까지, 라이브러리는 두 가지 Module System을 지원해야 하게 되었습니다.\n\n토스팀에서는 그것을 package.json의 exports field를 통해 지원하고 있습니다. 각각의 모듈 시스템과 exports field에 대해 자세히 알아봅시다.\n\nNode.js에는 CommonJS, ECMAScript Modules(이하 CJS, ESM)라는 두 가지 모듈 시스템이 존재합니다.\n\nCommonJS (CJS)\n\nECMAScript Modules (ESM)\n\nCJS는 require / module.exports 를 사용하고, ESM은 import / export 문을 사용합니다.\nCJS module loader는 동기적으로 작동하고, ESM module loader는 비동기적으로 작동합니다.\nESM은 Top-level Await을 지원하기 때문에 비동기적으로 동작합니다.\n따라서 ESM에서 CJS를 import 할 수는 있지만, CJS에서 ESM을 require 할 수는 없습니다. 왜냐하면 CJS는 Top-level Await을 지원하지 않기 때문입니다.\n이 외에도 두 Module System은 기본적으로 동작이 다릅니다.\n따라서 두 Module System은 서로 호환되기 어렵습니다.\n왜 두 Module System을 지원해야해요?\n서로 호환되기 어려운 두 Module System을 지원해야하는 이유는 뭘까요? 그냥 하나로 통일하면 안될까요? 토스팀에서는 왜 그것을 중요하게 생각할까요?\n\n토스팀에서는 Server-side Rendering(이하 SSR)을 적극적으로 사용하고 있기 때문에, Node.js의 CJS를 지원하는 것이 중요했습니다.\n\n그리고 Module System의 지원은 브라우저 환경에서의 퍼포먼스와도 관련이 있습니다. 브라우저 환경에서는 페이지 렌더링을 빠르게 하는 것이 중요한데, 이 때 JavaScript는 로딩되어 실행되는 동안 페이지 렌더링을 중단시키는 리소스들 중 하나 입니다.\n\n따라서 JavaScript 번들의 사이즈를 줄여서 렌더링이 중단되는 시간을 최소화 하는 것이 중요합니다. 이를 위해 필요한 것이 바로 Tree-shaking입니다. Tree-shaking이란 필요하지 않은 코드와 사용되지 않는 코드를 삭제하여 JavaScript 번들의 크기를 가볍게 만드는 것을 말합니다.\n\n이 때, CJS는 Tree-shaking이 어렵고, ESM은 쉽게 가능합니다.\n\n왜냐하면 CJS는 기본적으로 require / module.exports 를 동적으로 하는 것에 아무런 제약이 없습니다.\n\n\n따라서 CJS는 빌드 타임에 정적 분석을 적용하기가 어렵고, 런타임에서만 모듈 관계를 파악할 수 있습니다.\n\n하지만 ESM은 정적인 구조로 모듈끼리 의존하도록 강제합니다. import path에 동적인 값을 사용할 수 없고, export는 항상 최상위 스코프에서만 사용할 수 있습니다.\n\n\n따라서 ESM은 빌드 단계에서 정적 분석을 통해 모듈 간의 의존 관계를 파악할 수 있고, Tree-shaking을 쉽게 할 수 있습니다.\n\n위와 같은 배경으로 토스팀에서는 CJS/ESM 모두 지원하는 라이브러리를 운영하게 되었습니다.\n\n파일이 CJS인지 ESM인지 어떻게 알아요?\nModule System이 두 개가 존재하며 둘 다 지원해야할 필요성은 알겠는데, .js 파일이 CJS인지 ESM인지 어떻게 알 수 있을까요? package.json의 type field 또는 확장자를 보고 알 수 있습니다.\n\n.js 파일의 Module System은 package.json의 type field에 따라 결정됩니다.\ntype field의 기본값은 'commonjs' 이고, 이 때 .js 는 CJS로 해석됩니다.\n다른 하나는 'module' 입니다. 이 때 .js 는 ESM으로 해석됩니다.\n.cjs 는 항상 CJS로 해석됩니다.\n.mjs 는 항상 ESM으로 해석됩니다.\nTypeScript도 4.7부터 tsconfig.json 의 moduleResolution 이 nodenext 또는 node16 으로 설정된 경우, 위 규칙이 똑같이 적용됩니다.\n\ntype field가 'commonjs' 인 경우, .ts 는 CJS로 해석됩니다.\ntype field가 'module' 인 경우, .ts 는 ESM으로 해석됩니다.\n.cts 는 항상 CJS로 해석됩니다.\n.mts 는 항상 ESM으로 해석됩니다.\nCJS와 ESM의 차이, 패키지의 기본 Module System을 설정하는 방법과 확장자 모두 알아봤는데, 그래서 어떻게 하면 하나의 패키지가 CJS/ESM을 동시에 매끄럽게 제공할 수 있을까요?\n\n정답은 exports field입니다. exports field는 무슨 문제를 해결해줄까요? 어떤 역할을 할까요?\n\n패키지 entry point 지정\n기본적으로는 package.json의 main field와 같은 역할을 합니다. 패키지의 entry point를 지정할 수 있습니다.\n\nsubpath exports 지원\n기존에는 filesystem 기반으로 동작했기 때문에, 패키지 내부의 임의의 JS 파일에 접근할 수 있었고, 또한 실제 filesystem 상의 위치와 import path를 다르게 둘 수 없었습니다.\n\n\n\n이 때, exports field를 사용해 subpath exports를 사용하면, 명시된 subpath 외에는 사용할 수 없고, filesystem 상의 위치와 import path를 다르게 지정할 수 있습니다.\n\n\n\nconditional exports 지원\n기존에는 filesystem 기반으로 동작했기 때문에, Dual CJS/ESM 패키지를 자연스럽게 운영하기가 어려웠습니다.\n\nexports field를 사용하면, 똑같은 import path에 대해 특정 조건에 따라 다른 모듈을 제공할 수 있습니다.\n\n\n\n올바른 exports field\nDual CJS/ESM 패키지의 exports field를 올바르게 작성하기 위해 주의해야할 점을 알아봅시다.\n\n상대 경로로 표시하기\nexports field는 모두 . 으로 시작하는 상대 경로로 작성되어야 합니다.\n\n\nModule System에 따라 올바른 확장자 사용하기\nconditional exports를 사용할 때, 패키지가 따르는 Module System에 따라, 즉 package.json의 type field에 따라 올바른 JS 확장자를 사용해야 합니다.\n\nCJS 패키지일 때\n\nESM 패키지일 때\n\n이 규칙을 지키지 않고 전부 .js 확장자를 사용했을 때는 어떤 일이 발생할까요? 아래와 같이 상황을 가정하겠습니다.\n\ncjs-package 는 CJS 패키지이다.\ntype field가 'commonjs' 이기 때문이다.\n./dist/index.js 는 CJS 문법(require / module.exports)으로 작성된 모듈이다.\n./esm/index.js 는 ESM 문법(import / export)으로 작성된 모듈이다.\n\nCJS 환경에서 cjs-package 를 require 했을 땐 잘 동작합니다. ./dist/index.js 는 CJS 모듈이고, 확장자가 .js 이므로, 가장 가까운 package.json의 type field를 따라 CJS Module Loader가 사용될 것이기 때문입니다.\n\n\n하지만 ESM 환경에서 cjs-package 를 import 했을 땐 에러가 발생합니다. ./esm/index.js 는 ESM 모듈이지만, 확장자가 .js 이므로 가장 가까운 package.json의 type field를 따라 CJS Module Loader가 사용됩니다.\n\nESM 문법으로 작성된 JavaScript를 CJS Module Loader로 읽기 때문에 당연히 에러가 발생합니다.\n\n(예시: import 문은 ESM에서만 사용 가능하다는 에러가 발생)\n\n\nTypeScript 지원하기\nTypeScript에서 module import시, 항상 Type Definition을 찾게 되는데요. 기존에는 filesystem 기반으로 Type Definition을 탐색했습니다.\n\n\n하지만 TypeScript 4.7부터 moduleResolution 옵션에 node16 과 nodenext 가 정식으로 추가되었고, node16 과 nodenext 는 filesystem 기반이 아닌 exports field로부터 Type Definition을 탐색합니다. 또한, CJS TypeScript( .cts )와 ESM TypeScript( .mts )를 구분합니다.\n\nTypeScript는 conditional import의 조건 중 types 를 참조하며, 이 때 JavaScript와 마찬가지로 package.json의 type field에 따라 알맞은 확장자 ( .cts / .mts )를 사용해야 합니다.\n\nCJS 패키지\n\nESM 패키지\n\n그럼 TypeScript의 경우에는 위 규칙을 지키지 않으면 어떻게 될까요? 아래와 같이 상황을 가정하겠습니다.\n\nesm-package 는 ESM 패키지이다.\ntype field가 'module' 이기 때문이다.\n.cts (CJS TypeScript)에서 esm-package 를 사용한다.\n\n이 때 .cts (CJS TypeScript)에서 esm-package 를 require하면 타입 에러가 발생합니다.\n\nesm-package 는 Type Definition을 ./index.d.ts 만 지원합니다. 즉, ESM/CJS TypeScript 모두 ./index.d.ts 를 바라보게 됩니다.\n\n이 때, esm-package 는 ESM 패키지이기 때문에 index.d.ts 는 ESM TypeScript로써 해석됩니다.\n\n따라서 esm-package 는 CJS TypeScript 입장에서 Pure ESM Module이고, CJS는 ESM을 불러올 수 없기 때문에 esm-package 가 순수 ESM으로만 확인된다는 타입 에러가 발생합니다.\n\n\n최근 토스팀 내부 라이브러리들은 위처럼 올바르게 exports field를 작성하여 배포되고 있습니다. CJS/ESM JavaScript는 물론 TypeScript 지원까지 잘 되있습니다.\n\nJavaScript/TypeScript 생태계는 계속해서 발전하고 있지만, TypeScript까지 잘 지원하는 라이브러리는 정말 유명한 라이브러리들 중에서도 찾아보기가 많이 힘듭니다.\n\n그렇다면 우리가 그 시작점이 되면 어떨까요? 토스팀에서는 이런 기술적인 문제를 함께 풀어가고 싶으신 분들을 언제나 환영합니다. 함께 좋은 생태계를 만들어 나가고 싶어요.\n\nNode.js의 CJS/ESM에 대해\nCJS\nESM\nDetermining Module System\nexports field에 대해\npackage.json export field\nSubpath exports\nConditional exports\nTypeScript의 CJS/ESM 지원에 대해\n4.7 릴리즈 노트\n","isDisplayingFeedback":true},{"id":21026,"updatedTime":"2023-04-12T17:25:55+09:00","createdTime":"2023-04-12T16:03:33+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"테스트 의존성 관리로 높은 품질의 테스트 코드 유지하기","subtitle":"혹시 테스트 코드에서도 의존성을 관리해본 적이 있으실까요? 해당 포스트에서는 Gradle의 java-test-fixtures 플러그인을 사용하여 테스트 의존성 관리를 통해 높은 품질의 테스트 코드를 유지하는 방법을 알아봅니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/06/techblog-10-test-code.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"테스트 의존성 관리로 높은 품질의 테스트 코드 유지하기"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/06/techblog-10-test-code.png","backgroundColor":null,"isFill":false,"imageAlt":"테스트 의존성 관리로 높은 품질의 테스트 코드 유지하기"},"key":"how-to-manage-test-dependency-in-gradle","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-06-09T00:17:10+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21026,"title":null,"description":"테스트 코드는 애플리케이션 코드 못지 않게 높은 품질을 유지해야 합니다.낮은 품질(이해하기 어려운 코드, 여기저기 깨져있는 테스트)의 테스트는 유지보수가 어렵고 기술부채에 못지 않은 부채로 다가옵니다.그래서 테스트 코드의 높은 품질을 유지하기 위해 다양한 Builder, Helper 클...","urlSlug":"how-to-manage-test-dependency-in-gradle","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"테스트 의존성 관리로 높은 품질의 테스트 코드 유지하기","description":"혹시 테스트 코드에서도 의존성을 관리해본 적이 있으실까요? 해당 포스트에서는 Gradle의 java-test-fixtures 플러그인을 사용하여 테스트 의존성 관리를 통해 높은 품질의 테스트 코드를 유지하는 방법을 알아봅니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/tech-blog/og-image:/techblog-10-test-code-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2324,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":558,"name":"양권성","slug":"gwonsung-yang","shortDescription":"Server Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/gwonsung-yang.jpeg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":2,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"테스트 코드는 애플리케이션 코드 못지 않게 높은 품질을 유지해야 합니다.\n\n낮은 품질(이해하기 어려운 코드, 여기저기 깨져있는 테스트)의 테스트는 유지보수가 어렵고 기술부채에 못지 않은 부채로 다가옵니다.\n\n그래서 테스트 코드의 높은 품질을 유지하기 위해 다양한 Builder, Helper 클래스들이 나오게 되고, 테스트 전용으로 의존성을 추가하기도 합니다. 하지만 이 또한 관리의 대상이며 제대로 관리하지 않으면 중복 코드와 얼기설기 얽힌 의존성 지옥을 맛보게 됩니다.\n\n이 포스트에서는 Gradle의 java-test-fixtures 플러그인을 사용하여 위 문제를 해결하는 방법에 대해 설명합니다.\n\nTL;DR\nGradle의 java-test-fixtures 플러그인을 사용하면 테스트용으로 작성한 Builder, Helper 클래스 등등을 다른 모듈과 공유할 수 있습니다.\n추가적으로 해당 모듈의 테스트 전용 의존성까지 전파시킬 수 있어 각 모듈마다 불필요한 테스트 전용 의존성들을 일일이 추가할 필요가 사라집니다.\n프로젝트 구조\n예제를 이해하기 쉽게 하기 위해 프로젝트 구조(멀티 모듈)를 가정하고 이야기를 진행하겠습니다.\n\n\ndomain 모듈: 핵심 비즈니스 로직에만 관심이 있는 모듈, 외부(써드파티 라이브러리, DB, HTTP 등등)에 의존하지 않고 온전히 비즈니스 로직에만 관심을 갖고 있는 모듈로써 어떠한 의존성도 가지지 않습니다.\ndb 모듈: 데이터의 CRUD(저장, 조회, 수정, 삭제)에만 관심이 있는 모듈, 클라이언트의 요구사항을 처리하기 위해 domain 모듈에 의존(implementation)하고 있습니다.\n\n이미지 출처: Gradle Docs\n\n\napplication 모듈: 클라이언트의 요청을 받아 처리하는 모듈, 클라이언트의 요구사항을 처리하기 위해 domain 모듈에 의존(implementation)하고 있으며, application 모듈에 main 함수가 존재하기 때문에 데이터 조작(저장, 조회 등등)을 위해 db 모듈에도 의존(runtimeOnly)하고 있습니다.\n\n이미지 출처: Gradle Docs\n\n\n테스트 전용으로 작성한 클래스를 다른 모듈에게 노출시키기\ndomain 모듈에 아래와 같은 객체가 있다고 가정해보겠습니다.\n\n\n테스트에서 위 클래스를 사용해야할 때 객체를 생성하려고 생각하면 매우 번거로워집니다. (공감이 되지 않는다면 파라미터가 10개 정도 된다고 생각해보면 됩니다.)\n\n이 때 모든 파라미터에 기본값을 넣는 절충안도 존재하는데, 객체의 필수값이 기본값으로 채워진 채 객체가 생성되면 불안정하게 동작할 수 있습니다. 누군가의 실수로 프로덕션에서 객체의 필수값 중 일부가 기본값으로 생성된다면 의도치 않은 동작을 하게 될 수도 있기 때문입니다.\n\n따라서 테스트에서 사용할 목적으로 디폴트 값이 들어간 빌더 객체를 만들게 됩니다.\n\n참고로 IntelliJ IDEA에서 코틀린 클래스의 빌더를 만들어주는 플러그인은 kotlin-builder-generator를 사용하면 손 쉽게 만들 수 있습니다.\n\n하지만 빌더는 테스트에서만 사용해야하기 때문에 domain/src/test 디렉토리 밑에 생성해야합니다. test가 아닌 main 디렉토리 밑에 존재하게 되면 프로덕션 코드에서 누가 해당 빌더로 온전치 않은 상태의 객체를 생성하고 사용하는 실수를 할 수 있기 때문입니다.\n\n이런 Builder나 Helper 같이 테스트 전용으로 만든 클래스들을 해당 클래스가 존재하는 모듈(domain 모듈)이 아닌 해당 모듈을 의존하고 있는 다른 모듈(domain 모듈에 의존하고 있는 application, db 모듈)의 테스트에서 사용하고 싶다는 니즈가 생겼다고 가정해보겠습니다.\n\n하지만 application과 db 모듈에서 domain 모듈에 의존하고 있다고 할지라도 각 모듈의 테스트에서는 OrderBuilder를 import 할 수 없습니다.\n\n\nbuild된 jar 파일의 압축을 해제했을 때 나오는 결과물을 보면 main 디렉토리 밑에 있는 Order 클래스는 포함하고 있지만, test 디렉토리 밑에 있는 OrderBuilder 클래스는 포함하고 있지 않기 때문입니다.\n\n어떻게 생각해보면 당연한 결과입니다.\n\ndomain 모듈을 테스트하는데 필요한 정보들은 프로덕션 코드에서는 필요가 없고, 그렇기 때문에 굳이 불필요하게 테스트 전용 클래스들까지 포함시킬 필요는 없기 때문입니다.\n\n이제 문제를 해결하기 위한 간단한 방법 두 가지를 떠올리게 됩니다.\n\n각 모듈의 test 디렉토리에 빌더를 복사/붙여넣기 합니다. 하지만 이는 코드의 중복을 유발하며 Order 클래스의 변경사항이 생겼을 때 각 모듈에 존재하는 OrderBuilder 클래스를 각각 수정해야한다는 번거로움이 존재합니다.\nBuilder/Helper를 모아놓은 별도의 test-data 같은 테스트 전용 모듈을 만들고, 각 모듈에서 test-data 클래스에 의존(testImplementation)하게 만듭니다.\n\n하지만 이는 실제 소스코드(Order는 domain 모듈에 존재)와 거리가 멀어지게 만들어(OrderBuilder는 test-data 모듈에 존재) 응집도가 떨어지는 모듈이 나오게 됩니다.\n\n또한 테스트 전용임에도 불구하고 test-data 모듈의 클래스들을 외부에 노출시켜야하기 때문에 test 디렉토리가 아닌 main 디렉토리에 둬야 하는 점도 약간의 혼란(’main 디렉토리에 있으니까 프로덕션 레벨에서 사용하는 건가…?’ 하는 정도의)을 유발할 수 있습니다.\n\n둘 다 좋은 방법은 아니라는 생각이 듭니다. 이 문제를 해결하기 위한 빛과 소금과 같은 존재가 있습니다.\n\n구세주: java-test-fixtures 플러그인\nGradle에는 이런 문제를 해결하고자 java-test-fixtures 플러그인이 존재합니다.\n\n우선 외부에 노출시키고자 하는 Builder나 Helper 클래스가 존재하는 domain 모듈의 build.gradle.kts 파일에 플러그인을 추가해주고 프로젝트를 reload 하면 됩니다.\n\n\n\njava-test-fixtures 플러그인이 적용된 모듈에서 디렉토리를 생성하려고 하면 IntelliJ IDEA에서는 testFixtures 디렉토리가 자동완성 됩니다.\n\n그럼 아까 생성했던 OrderBuilder 클래스는 test가 아닌 testFixtures 디렉토리로 이동시켜준 후 build를 했을 때 수행되는 Gradle Task들을 보게 되면 testFixture 관련된 task가 추가된 걸 알 수 있습니다.\n\n\n그리고 빌드된 결과물을 보면 test-fixtures.jar가 추가된 걸 볼 수 있습니다.\n\n\nplain.jar는 plain에, test-fixtures.jar는 test에 각각 풀었는데 OrderBuilder는 test에 존재하는 걸 보니 test-fixtures.jar에 존재한다는 걸 알 수 있습니다.\n\n여기서 또 java-test-fixtures 플러그인의 장점이 나오게 되는데 다른 모듈에서 불필요하게 여기는 클래스들(test 디렉토리에 있는 @Test 어노테이션이 붙은 테스트 코드들 등등)은 노출되지 않고, 필요한 클래스들(testFixtures 디렉토리에 있는 Helper나 Builder 클래스 등등)만 노출된다는 점입니다.\n\n하지만 이렇게 했다고 해서 아직 application이나 db 모듈에서 OrderBuilder를 import 할 수 있는 건 아닙니다. application과 db 모듈에서는 plain.jar에 의존하고 있는 것이지, test-fixtures.jar에 의존하고 있는 건 아니기 때문입니다.\n\n따라서 application과 db 모듈에서 test-fixtures.jar에 의존하도록 각 모듈의 build.gradle.kts에 추가해줘야합니다.\n\n\n위와 같이 의존성을 추가해줘야 비로소 application과 db 모듈의 테스트 코드에서도 domain 모듈의 testFixtures에 존재하는 OrderBuilder를 사용할 수 있게 됩니다.\n\n\n이해하기 쉽게 모듈 간의 디렉토리 관계를 좀 더 세분화해서 표현해보았습니다.\n\n테스트 전용으로 추가한 의존성을 다른 모듈에게 노출시키기\ndb 모듈의 통합테스트를 위해 인메모리 DB인 H2를 테스트 전용으로 의존성을 추가했다고 가정해보겠습니다.\n\n\n이미지 출처: Gradle Docs\n\n\n이 상태에서 db 모듈의 통합테스트를 돌리게 되면 H2 DB를 사용하여 실제 DB와 격리된 환경에서 테스트가 돌아가는 것을 볼 수 있습니다.\n\n그리고 application 모듈은 아래와 같이 db 모듈에 의존하고 있기 때문에 통합테스트를 작성할 때도 인메모리 DB를 쓸 것이라 희망하게 되는데 실제로 테스트를 짜고 돌려보면 그렇지 않습니다.\n\n\n\ngradle 모듈의 디펜던시를 보게 되면 db 모듈의 testRuntimeClasspath에는 H2가 존재하지만, application 모듈의 testRuntimeClasspath에 존재하는 db 모듈에는 H2가 존재하지 않기 때문입니다.\n\n이 때도 application 모듈의 build.gradle.kts에 H2를 의존성으로 추가하는 방법이 있겠지만 관심사 문제가 있습니다. application 모듈의 관심사는 ‘어떻게 클라이언트와 커뮤니케이션해서 요구사항을 만족시킬 것인가?’이지 세부적인 내용(’저장소는 무엇을 쓸까? 데이터는 어디서 저장하고 어떻게 불러올까?’ 같은)은 관심사가 아닙니다. 따라서 H2를 직접적으로 의존성을 추가하는 순간 관심사 분리가 제대로 되지 않게 됩니다.\n\n이 문제를 해결하기 위해 또 우리의 구세주 java-test-fixtures 플러그인이 필요합니다.\n\ntestFixturesComplieClasspath와 testFixturesRuntimeClasspath\n우선 외부에 테스트 전용 의존성(H2)을 노출시키고 싶은 db 모듈에 java-test-fixtures 플러그인을 추가하고, testRuntimeOnly로 추가했던 H2 의존성을 testFixturesRuntimeOnly로 변경해줘야 합니다.\n\n\n그리고 나서 다시 db 모듈의 디펜더시를 보면 기존에 보지 못했던 testFixturesCompileClasspath와 testFixturesRuntimeClasspath가 추가된 게 보입니다.\n\n사실 두 가지 클래스패스는 java-test-fixtures 플러그인을 추가하기만 해도 추가되는 클래스패스입니다.\n\n\n여기서 눈여겨봐야할 것은 기존에는 testRuntimeClasspath에만 존재하던 H2 의존성이 testFixturesRuntimeClasspath에도 추가된 점입니다.\n\n이에 대한 해답은 java-test-fixtures 플러그인 문서를 보다보면 아래와 같은 내용에 나오게 됩니다.\n\nTest fixtures are configured so that: • they can see the main source set classes • test sources can see the test fixtures classes\n두 번째로 나와있는 테스트 소스(test 디렉토리에 있는 내용들)에서 test fixture(testFixtures 디렉토리에 있는 내용들)에 있는 내용을 참조(can see)할 수 있도록 구성된다는 내용이 핵심입니다.\n\n\n따라서 testFixturesRuntimeOnly로만 추가(testFixturesRuntimeClassPath)했지만 testRuntimeOnly로도 추가된 것과 동일한 효과(testRuntimeClasspath에 추가된 효과)를 같이 보게 됩니다. 따라서 db 모듈의 통합테스트를 돌렸을 때는 여전히 H2 DB를 사용하게 됩니다.\n\n하지만 H2를 db 모듈에 testFixturesRuntimeClasspath에 추가했지만, 여전히 application 모듈의 testRuntimeClasspath를 보면 아직도 db 모듈에는 H2 의존성이 추가되지 않은 모습을 볼 수 있습니다.\n\n\n그 이유는 application 모듈의 build.gradle.kts를 보면 알 수 있습니다.\n\n\n\n이미지 출처: Gradle Docs\n\n바로 정답은 runtimeOnly 키워드에 있습니다.runtimeOnly로 추가한 디펜던시는 testRuntimeClasspath에도 추가됩니다. (물론 runtimeClasspath에도 추가됩니다.)하지만 testRuntimeClasspath에 추가된 의존성은 외부 모듈에 노출되지 않는다는 특성이 있습니다.\n\n따라서 우리는 db 모듈의 testRuntimeClasspath가 아닌 testFixturesRuntimeClasspath에 추가된 의존성들에 주목해야하며 해당 의존성들이 추가되도록 application 모듈의 build.gradle.kts를 수정해야 합니다.\n\n\n마지막 부분이 db 모듈의 testFixturesRuntimeClasspath에 있는 의존성을 testRuntimeOnly로 추가(testRuntimeClasspath에 추가)하는 내용입니다.\n\n\n이제 application 모듈의 testRuntimeClasspath에도 db 모듈의 testFixutresRuntimeClasspath에 있는 H2 의존성이 추가된 걸 볼 수 있습니다.\n\n\n이 상태에서 application 모듈의 통합테스트를 돌리더라도 H2 DB를 사용하는 걸 볼 수 있습니다.\n\n결론\n테스트 코드는 실제 프로덕션에 영향을 미치지 않으므로 신경을 덜 쓰기 마련입니다. 그러다보면 중복이 난무하고 관심사 분리도 제대로 되지 않고 의존성 지옥에 빠지기 십상입니다. 하지만 테스트 코드는 우리의 소프트웨어를 좀 더 나은 설계로 유도하며 안정감도 주기 때문에 품질을 관리해야하는 소프트웨어임에는 분명합니다.\n\n혹시 해당 포스트를 보고 ‘어, 그거 그렇게 하는 거 아닌데…’라는 생각이 들었다면 토스페이먼츠에 와서 신나게 토론할 준비가 되어있으니 언제든 환영합니다!","isDisplayingFeedback":true},{"id":21010,"updatedTime":"2023-04-12T17:25:54+09:00","createdTime":"2023-04-12T16:01:32+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"에러 핸들링을 다른 클래스에게 위임하기 (Kotlin 100% 활용)","subtitle":"Kotlin의 Result로 MSA에서 에러가 전파되지 않는 안전한 환경을 만드는 방법을 알아봅니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/05/techblog-09-error-handling.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"에러 핸들링을 다른 클래스에게 위임하기 (Kotlin 100% 활용)"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/05/techblog-09-error-handling.png","backgroundColor":null,"isFill":false,"imageAlt":"에러 핸들링을 다른 클래스에게 위임하기 (Kotlin 100% 활용)"},"key":"kotlin-result","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-05-14T23:38:16+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21010,"title":null,"description":"아래와 같은 서비스 호출 흐름이 있다고 가정해보겠습니다.Server A 입장에서는 Server B에서 발생하는 에러 처리를 해야하는 고민에 빠집니다.API를 호출하는 코드에서 API의 에러 응답에 따른 비즈니스 로직을 다르게 가져가고 싶은 경우가 있습니다. 예를 들어 위 사례에서 비밀번...","urlSlug":"kotlin-result","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"에러 핸들링을 다른 클래스에게 위임하기 (Kotlin 100% 활용)","description":"Kotlin의 Result로 MSA에서 에러가 전파되지 않는 안전한 환경을 만드는 방법을 알아봅니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/tech-blog/og%20image/thumnail/error.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2323,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":557,"name":"한규주","slug":"gyuju-han","shortDescription":"Server Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/gyuju-han.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":2,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"TL;DR\nResult를 이해한다면, MSA 환경에서 에러가 전파되지 않도록 막을 수 있습니다.\nrunCatching과 Result를 사용하면 에러 핸들링을 클라이언트에게 위임할 수 있습니다.\n예제: 로그인 요청을 전달하는 서비스 흐름에서 에러 처리하기\n아래와 같은 서비스 호출 흐름이 있다고 가정해보겠습니다.\n\n\nServer A 입장에서는 Server B에서 발생하는 에러 처리를 해야하는 고민에 빠집니다.\n\nAPI를 호출하는 코드에서 API의 에러 응답에 따른 비즈니스 로직을 다르게 가져가고 싶은 경우가 있습니다. 예를 들어 위 사례에서 비밀번호가 틀리거나 이메일 주소가 틀린 경우 이 에러를 캐치해서 다른 메세지를 던지고 싶을 수 있고, 어떤 코드에서는 그 에러를 무시하고 다른 로직을 수행하고 싶을 수 있습니다.\n\n에러 처리를 API Client 단에서 하지 않고 다른 클래스에 위임을 하고 싶은 이런 경우에는 어떤 방법을 사용할 수 있을지 아래 코드 예시로 알아보겠습니다.\n\n\n이 경우에 아래와 같은 두 케이스를 해결하고 싶어집니다.\n\n이 API를 사용하는 쪽(ex. LoginService)에서 에러 핸들링을 강제하고 싶습니다.\nAPI 호출 로직마다 에러 핸들링을 다른 방식으로 가져가게 하고 싶습니다.\nLoginService가 아닌 다른 호출 로직에서는 에러를 다르게 처리하고 싶을 수 있습니다.\n위 고민을 해결할 방법이 있습니다. 바로 Result입니다.\n\n\n코틀린의 runCatching\n💡 이미 runCatching을 잘 사용하고 있다면 넘겨도 좋습니다.\n위 코드를 이해하기에 앞서서 runCatching을 알아둘 필요가 있습니다. 코틀린은 물론 자바의 try ... catch를 동일하게 지원하지만 이와는 조금 다른 방법으로 에러 핸들링을 할 수도 있습니다.\n\n예제\n아래 요구사항이 있다고 가정합시다.\n\nLoginApiClient 호출 시 LoginException이 발생했는데,\nerrorCode가 INVALID_PASSWORD 인 경우 예외를 발생시키지 않고 null을 반환한다.\n그 외 모든 에러 상황에서는 예외를 발생시킨다.\ntry ... catch를 사용했을때\n\nJava에서 위와 같이 작성하는 코드를 runCatching을 사용하면 아래처럼 표현할 수 있습니다.\n\nrunCatching을 사용했을 때\n\n\nkotlin.runCatching\n\ntry..catch 로직을 그대로 사용하지만 Result로 감싸서 반환하는 것을 알 수 있습니다.\n\n에러가 발생하지 않았을 때에는 Result.success 반환\n에러가 발생했을 때에는 Result.failure 반환\nResult가 뭔가요?\nResult가 무엇인지 알아보기 위해서 Kotlin 1.3 표준 라이브러리의 코드를 살펴봅시다.\n\n\n즉, Result의 value는\n\n성공일 경우 T를 타입으로 하는 값을 가지게 되고\n실패일 경우는 Failure를 wrapper class로 하는 exception을 값으로 가지게 됩니다.\nResult가 제공하는 함수들은 다음과 같습니다.\n\n\nResult 사용 예시\nrunCatching은 Result<T>를 반환하게 되는데, Result가 제공하는 함수를 이용해서 다양하게 활용할 수 있습니다.\n\n에러를 무시하고 null 반환\n\n기본값 반환\n\n에러 발생 시 다른 동작 수행\n\n에러가 발생한 경우에만 해당 에러 객체 반환\n\n에러가 발생하는지 아닌지만 확인하고 싶을 때에도 유용할 수 있습니다.\n\n\n성공/에러 시 각각 특정 동작 수행 후 에러 던지기\n\nrunCatching으로 try .. finally 구현하기\n\nResult를 사용해서 예외 처리를 다른 클래스에 위임하기\nrunCatching을 사용하면 Result가 제공하는 다양한 함수의 편의에 기댈 수 있다는 것을 배웠습니다.\n\nResult에 대한 처리를 즉시 하지 않고 함수의 반환 값으로 반환하게 된다면, Result에 대한 핸들링을 다른 클래스에 위임할 수도 있습니다.\n\nLoginApiClient\n\nResult를 반환하여 다른 클래스가 에러 핸들링을 하도록 위임합니다.\n\nLoginService\n\n에러가 발생한 경우 에러를 무시하고 기본값으로 null을 반환합니다.\n\n하지만 아래처럼 다른 컴포넌트에서는 에러를 핸들링하고 싶을 수도 있습니다.\n\nPasswordChangeService\n\n[1] 에러가 발생한 경우 에러를 기록합니다.\n\n[2] 성공한 경우 해당 값을 받아서 다른 컴포넌트를 호출합니다.\n\n→ [1], [2]번 두 케이스는 배타적이고 동시에 일어날 수 없습니다.\n\n[3] 그리고 에러인 경우 예외를 발생시킵니다.\n\n결론\n정리하자면 Result(runCatching)는 다음의 용도에서 사용할 수 있습니다.\n\n외부 서비스에 의존하는 로직이라 예외 발생 가능성이 빈번한 컴포넌트\n해당 컴포넌트에서 에러가 발생할 수 있다는 것을 클라이언트에게 알려주고 싶을 때, 에러 핸들링을 다른 컴포넌트에 강제하고 위임하고 싶을 때\ntry ... catch를 쓰고 싶지 않을 때","isDisplayingFeedback":true},{"id":21003,"updatedTime":"2023-04-18T15:33:20+09:00","createdTime":"2023-04-12T16:00:46+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"Kotlin으로 DSL 만들기: 반복적이고 지루한 REST Docs 벗어나기","subtitle":"토스페이먼츠에서는 API docs를 REST Docs를 사용해서 작성할 수 있도록 권장하고 있습니다. 이 글에서는 DSL을 통해서 반복적인 REST Docs 테스트 코드 작성을 줄일 수 있는 방법을 알아봅니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/04/techblog-08-rest-docs.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"Kotlin으로 DSL 만들기: 반복적이고 지루한 REST Docs 벗어나기"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/04/techblog-08-rest-docs.png","backgroundColor":null,"isFill":false,"imageAlt":"Kotlin으로 DSL 만들기: 반복적이고 지루한 REST Docs 벗어나기"},"key":"kotlin-dsl-restdocs","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-04-11T05:24:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21003,"title":null,"description":"REST Docs 테스트 코드량을 70% 줄여주는 DSL 개발기읽는 데 걸리는 시간: 6분Domain Specific Languages(DSL)은 코드의 내부 로직을 숨기고 재사용성을 올려줍니다. 어떤 경우는 비 개발자가 사용하도록 고안되는 경우도 있어서, 일반적인 프로그래밍 언어보다 ...","urlSlug":"kotlin-dsl-restdocs","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"Kotlin으로 DSL 만들기: 반복적이고 지루한 REST Docs 벗어나기","description":"토스페이먼츠에서는 API docs를 REST Docs를 사용해서 작성할 수 있도록 권장하고 있습니다. 이 글에서는 DSL을 통해서 반복적인 REST Docs 테스트 코드 작성을 줄일 수 있는 방법을 알아봅니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/tech-blog/og-image:/techblog-08-rest-docs-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2332,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":557,"name":"한규주","slug":"gyuju-han","shortDescription":"Server Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/gyuju-han.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":2,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"REST Docs 테스트 코드량을 70% 줄여주는 DSL 개발기\n\n읽는 데 걸리는 시간: 6분\n\nDSL\nDomain Specific Languages(DSL)은 코드의 내부 로직을 숨기고 재사용성을 올려줍니다. 어떤 경우는 비 개발자가 사용하도록 고안되는 경우도 있어서, 일반적인 프로그래밍 언어보다 훨씬 쉬운 사용성을 가집니다. 핵심은 해당 도메인을 아는 사람이면 누구나 쉽게 해당 도메인을 제어할 수 있도록 DSL을 제공하는것이 목적이며, 그렇기 때문에 프로그래밍 언어가 아닌 일반적인 언어에 가깝도록 호출 방식을 설계합니다. 때문에 DSL 호출 내부에서 어떤 로직이 작동하는지는 사용자가 알도록 할 필요가 없으며 훨씬 더 간결하고 빠르게 코드를 작성할 수 있습니다.\n\nSpring REST Docs, 더 쉽고 간결하게 쓸 수 없을까\n토스페이먼츠에서는 API docs를 REST Docs를 사용해서 작성할 수 있도록 권장하고 있습니다. docs를 작성하는 행위 자체에서부터 API를 통합테스트할 수 있다는 점이 매력적이며, 인터페이스의 의도치 않은 변경을 감지할 수 있다는 장점이 있습니다. 문제는 독스를 작성할 때마다 테스트 코드를 작성해줘야 하기 때문에 Swagger 보다 더 번거롭게 작업하게 된다는 문제가 있습니다.\n\n이 글에서는 DSL을 통해서 API 인터페이스의 안정성과 개발자의 생산성을 모두 가져갈 수 있는 방법을 소개합니다.\n\nREST Docs DSL\n먼저 기존의 작성법(AS-IS)과 DSL을 이용한 작성법(TO-BE)을 비교해보겠습니다.\n\nAS-IS.\n\nTO-BE.\n\n한 눈에 봐도 간결해보이지 않나요? AS-IS에서 볼 수 있듯, 기존의 작성법은 여러 문제가 있습니다.\n\n반복적인 코드 호출이 많음. 기존 작성법으로 작성할 때마다 생산성 저하를 느꼈습니다. API를 만드는 시간만큼이나 docs를 생성하는 시간이 걸린다니, 이것 참 비효율이지 않나요?\n코드가 장황하여 읽히지 않음. 인터페이스에 변화가 생기면 REST Docs 테스트 코드를 수정해야 하는데, 어떤 코드를 수정해야 하는지 빠르게 찾기가 어려웠습니다. 즉 해당 코드가 무엇을 수행하는지 한번에 읽기가 힘들고, 이 코드 수행 결과가 어떤 docs를 만들어낼지 단번에 떠올리기 어렵다는 단점이 있었습니다.\n첫 번째 단점은 기존의 다른 코드로부터 복붙으로 시간을 좀 줄여낼 수는 있었지만, 두 번째 단점은 참 신경 쓰였습니다. 저는 JSON과 같은 간결한 구조로부터 docs를 테스트하는 코드가 만들어지길 원했습니다.\n\nKotlin으로 DSL 만들기\n다행히도 Kotlin은 여러 함수 선언 방식이 존재하여서, 이런 문제를 풀기에 매우 좋습니다. Kotlin의 테스트 코드 라이브러리인 Kotest와 MockK이 대표적인 사례라고 생각합니다.\n\ninfix 함수\nInfix Notation (kotlinlang.org)\n\n잘 만들어진 DSL은 인간의 자연어를 사용하듯이 자연스럽게 쓰고 읽힐 수 있어야 한다고 생각합니다. Kotlin의 infix notation은 이 목표를 달성하기에 최적의 도구입니다.\n\n\n'data.businessId' type NUMBER는 'data.businessId'.type(NUMBER)와 동일한 효과를 낳습니다.\n\n\n(1):\ninfix notation으로 해당 함수를 선언해줍니다.\ntype이라는 함수는 String을 receiver로 받는 함수입니다.\n파라미터는 docsFieldType 하나만 받습니다 (DocsFieldType는 아래에서 서술합니다.)\n(2): 원래 restdocs가 제공하던 FieldDescriptor를 유연하게 다루기 위해 Field라는 Wrapper 클래스를 정의합니다.\n(3): 원래의 RestDocs를 만들던 동작을 수행합니다\ninfix 함수를 사용할때는 제한사항이 있습니다.\n\n호출할때는 receiver와 parameter가 명시적으로 있어야 함 (this로 암시적인 전달 불가능)\nparameter는 하나여야 함 (default value도 지정할 수 없음)\n그래야만 'data' type OBJECT 처럼 간결한 구조를 만들어 낼 수 있기 때문입니다.\n\nDocsFieldType\nREST Docs에서는 응답, 요청 필드의 type을 JsonFieldType으로서 구분합니다.\n\n여기에 저는 자주 사용하는 format인 Date, DateTime을 쉽게 정의할 방법을 찾고 싶었고, enum class도 간단히 전달하여 어떤 필드가 사용될 수 있는지 docs에 쉽게 표기하고 싶었습니다. date, datetime, enum은 모두 JsonFieldType.STRING이지만 format과 sample이 다르게 표시될 필요가 있는 특이 케이스이기 때문입니다.\n\n\n이런 식으로 정의한다면 아래 예시와 같이 간단하게 Field를 생성해내면서 DocsFieldType을 정의해낼 수 있습니다.\n\n\nDocsFieldType - enum\n다만 enum을 정의하고 싶을때는 조금 디테일이 필요합니다.\n\n\n로도 선언할 수는 있지만 매번 example을 호출해주는 건 조금 귀찮습니다. 어차피 enum이 string이라는건 누구나 다 아는 사실인데 두 함수 호출을 나눠야 할까요?\n\n\n훨씬 간결해졌습니다.\n\n다음과 같이 DocsFieldType을 확장한 sealedSubclass를 만든다면 위와 같은 dsl 작성이 가능합니다.\n\n\n(1): secondary constructor 덕분에 모든 enum값이 아니라 특정 조건에 맞는 enum 값을 collection으로 넘길수도 있습니다.\nex) 개인사업자에 해당하는 companyType만 해당 필드에 존재할 수 있을 때 'individualCompanyType' type ENUM(CompanyType.values().filter { it.isIndividual() })\n이로써 type infix 함수는 아래와 같이 완성할 수 있습니다.\n\n\nField 클래스에서 DSL 확장하기\n\n이제 좀 더 욕심을 내봅시다. 위 예시처럼 얼마든지 함수 호출을 chaining할 수 있습니다.\n\n어떤가요? 괄호로 계속 호출하는 것보다 좀 더 직관적이지 않나요?\n\ntype이라는 infix function이 Field를 반환할 수 있도록 했으니, Field에서 더 많은 DSL을 호출하도록 확장할 수 있게 되었습니다.\n\n\n이렇게 얼마든지 코드를 확장해나갈 수 있을뿐더러, 해당 프로젝트에서 사용하는 REST Docs snippet의 attribute를 코드 상으로 좀 더 명확하게 정의할 수 있게 되었습니다.\n\n마무리\n이 글은 REST Docs의 반복적인 코드를 제거하고, docs의 생성이라는 본래의 목적을 달성하고자 기존 MockMvc 테스트코드 작성법에서 벗어나, REST Docs DSL을 만드는 방식으로 문제를 해결하고자 했습니다.\n\n우리가 흔히 쓰는 gradle configuration 작성 방식인 build.gradle.kts 또한 org.gradle.kotlin.dsl에서 그 선언 방식을 찾아볼 수 있고, MockK이나 Kotest에서도 다양한 방식으로 Kotlin의 장점을 최대한 끌어낸 모습을 확인할 수 있습니다.\n\nbuild.gradle.kts (https://github.com/gradle/kotlin-dsl-samples)\nMockK의 every(https://mockk.io/#dsl-examples),\nKotest의 여러 Testing Styles(https://kotest.io/docs/framework/testing-styles.html)\n혹시나 여러분도 반복적인 작업을 일일히 복붙으로 하고 있다면 여러분의 팀만을 위한 DSL을 만들어보는 건 어떨까요?\n\n이 REST Docs DSL은 토스페이먼츠 *엔지니어링 데이에 장태영(Server Developer, taeyoung.jang@tosspayments.com)님과 함께 만들었습니다.\n\n토스페이먼츠에서는 매주 목요일에 엔지니어링 데이를 진행하고 있어요. 이 시간에는 평소 업무에 병목이 되는 문제들을 해결하거나, 인프라를 개선하는 등의 작업을 진행합니다.","isDisplayingFeedback":true},{"id":21030,"updatedTime":"2023-04-12T17:25:55+09:00","createdTime":"2023-04-12T16:03:58+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"조금만 신경써서 초기 렌더링 빠르게 하기 (feat. JAM Stack)","subtitle":"SPA(Single Page Application) 구조로 웹 프론트엔드 애플리케이션이 개발되면서 초기 렌더링 속도는 프런트엔드 개발자에게 중요한 과제 중 하나가 되었습니다. 사용자 경험에 영향을 줄 수 있는 가장 큰 요소 중 하나가 바로 속도이기 때문입니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/02/techblog-07-jam-stack.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"조금만 신경써서 초기 렌더링 빠르게 하기 (feat. JAM Stack)"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/02/techblog-07-jam-stack.png","backgroundColor":null,"isFill":false,"imageAlt":"조금만 신경써서 초기 렌더링 빠르게 하기 (feat. JAM Stack)"},"key":"faster-initial-rendering","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-02-09T14:25:46+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21030,"title":null,"description":"SPA(Single Page Application) 구조로 웹 프론트엔드 애플리케이션이 개발되면서 초기 렌더링 속도는 프런트엔드 개발자에게 중요한 과제 중 하나가 되었습니다. 사용자 경험에 영향을 줄 수 있는 가장 큰 요소 중 하나가 바로 속도이기 때문입니다. 이번 개선은 Web Vit...","urlSlug":"faster-initial-rendering","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"조금만 신경써서 초기 렌더링 빠르게 하기 (feat. JAM Stack)","description":"SPA(Single Page Application) 구조로 웹 프론트엔드 애플리케이션이 개발되면서 초기 렌더링 속도는 프런트엔드 개발자에게 중요한 과제 중 하나가 되었습니다. 사용자 경험에 영향을 줄 수 있는 가장 큰 요소 중 하나가 바로 속도이기 때문입니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/tech-blog/og-image:/techblog-07-jam-stack-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2330,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":561,"name":"한재엽","slug":"jaeyeop-han","shortDescription":"Frontend Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/jaeyeop-han.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"들어가면서\nSPA(Single Page Application) 구조로 웹 프론트엔드 애플리케이션이 개발되면서 초기 렌더링 속도는 프런트엔드 개발자에게 중요한 과제 중 하나가 되었습니다. 사용자 경험에 영향을 줄 수 있는 가장 큰 요소 중 하나가 바로 속도이기 때문입니다. 이번 개선은 Web Vitals 지표를 중심으로 측정했습니다.\n\n주어진 과제들\n과제 1. 번들 사이즈\n애플리케이션에 기능이 추가되면서 번들 사이즈가 커졌고 이로 인해 초기 렌더링이 늦어지는 문제가 발생하게 됩니다. 네트워크 비용을 줄이기 위해 Webpack으로 번들링했던 소스코드를 다시 적절한 단위로 코드 스플리팅(Code Splitting)을 하기도 하고 사용되지 않는 코드, 불필요한 코드들을 덜어내기 위한 트리 세이킹(Tree Shaking)을 위한 작업을 하기도 합니다.\n\n→ [SLASH 21] 이한 – JavaScript Bundle Diet\n\n이러한 노력을 하더라도 개선할 수 있는 부분엔 한계가 존재했습니다. 초기에 렌더링되는 index.html 자체가 비어있는 문서(Document)이기 때문에 스크립트가 실행되어 실제로 렌더링이 되기까지의 시간이 존재하기 때문입니다.\n\n과제 2. 렌더링 시점\n그렇다면 이제 렌더링 시점을 어떻게 앞당길 것인가에 대한 문제를 해결해야 됩니다. 사용자가 tosspayments.com 에 접근했을 때, 사용자가 최종적으로 볼 수 있는 화면을 서버에서 미리 그리고 그 화면을 브라우저에 전달해주면 초기 렌더링 시점이 앞당겨지지 않을까요?\n\n물론 인터랙션이 가능해지기 까지는 하이드레이트(Hydrate) 시간이 필요하지만, 사용자 입장에서는 우선 화면이 보여지는 것이 중요합니다. 초기에 렌더링 되는 index.html이 비어있는 문서가 아니라 무언가 렌더링되어 있는 문서라면 LCP(Largest Contentful Paint) 시점을 크게 앞당길 수 있을 것입니다.\n\nJAM Stack\n서론이 길었는데요, 토스페이먼츠에서 만들고 있는 일부 제품에서 SSR(Server Side Rendering)없이 초기 렌더링 속도를 개선해 보았습니다. 어떤 결과를 낳았으며 어떻게 개선했는지 이야기하고자 합니다.\n\nJAM Stack이란 JavaScript와 Markup에 해당하는 HTML, CSS 정적 리소스들을 활용하여 웹 애플리케이션을 구성하는 스택을 말합니다. 그리고 이 정적 리소스들을 CDN(Content Delivery Network)에 배포하여 서버 관리를 최소화 할 수 있습니다.\n\n토스페이먼츠에서는 AWS S3, CloundFront, Lambda@edge 를 사용하여 인프라를 운영하고 있습니다.\n\n→ JAM Stack에 대해 더 알아보기\n\nSSG\nStatic Site Generation이라는 개념인데요, 앱을 빌드하는 시점에 미리 그려두고 이를 서빙(serving)하는 방식을 말합니다. JAM Stack에서 정적 리소스를 생성하는 용도로 사용합니다.\n\n컴파일 단계에서 미리 그릴 수 있는 부분을 최대한 그려서 사용자에게 도달하는 최초 index.html 파일이 비어있지 않도록 합니다.\n\n미리 그릴 수 있다는 것은 말 그대로 컴파일 단계에서 리액트 코드를 읽어 HTML로 렌더링 할 수 있는 부분을 말합니다. 정적인 부분을 포함하여 인증이 필요하지 않은 데이터 또한 서버로부터 가져와 미리 그릴 수 있습니다.\n\n결과 (지표)\n구체적인 내용을 다루기에 앞서 어느 정도의 개선이 있었는지 먼저 소개하고자 합니다. 기대한 것 이상의 결과가 나와서 매우 즐거웠던 경험이었습니다.\n\n토스페이먼츠 상점관리자 초기 로딩 화면\n\nLighthouse 지표\nbefore\n\n\n개선 하기 전 지표\n\nAfter\n\n\n개선 후 지표\n\n구체적인 지표 측정\nChrome Browser에서 FP(First Paint)부터 LCP(Largest Contentful Paint)까지 걸린 시간을 측정해봤습니다.\n\nbefore(FP → LCP: 484ms)\n\n\nafter(FP → LCP: 0ms)\n\n\nLarge Contents에 해당하는 것을 일단 그려버리고 시작하니 0ms입니다.\n최대한 그릴 수 있는 영역을 미리 그림으로써 사용자는 흰 화면을 마주하지 않고 바로 제품을 만나는 것과 같은 느낌을 받을 수 있습니다.\n\nHow?\nNext.js\n토스페이먼츠의 프런트엔드 애플리케이션은 Next.js 라는 프레임워크를 사용하고 있습니다. Next.js는 서버 사이드 렌더링은 물론이고 앞서 설명드린 Static Site Generate 또한 지원합니다. (Next.js Automiatic Static Optimization)\n\nSuspense\n우선 토스 대부분의 프런트엔드 애플리케이션 제품은 React의 Suspense를 통해 비동기를 제어하고 있으며 토스페이먼츠 제품 또한 예외가 아니었습니다. 이와 동시에 에러 핸들링 또한 ErrorBoundary를 통해 제어하면서 비동기 상황을 제어하고 있습니다.\n\n→ [SLASH 21] 박서진 – 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기\n\n→ 선언적으로 에러 상황 제어하기\n\n이 Suspense를 Next.js와 함께 사용하기 위해선 약간의 추가 작업이 필요한데요, 앞서 설명드렸다시피 Next.js는 서버사이드 렌더링 또한 지원하는 프레임워크이기 때문에 Isomophic한 코드를 작성해야 합니다. 아쉽게도 Suspense는 서버사이드 렌더링이 지원되지 않습니다. (글을 작성하는 시점에 알파로 공개되어 있는 React 18에서 개선될 예정)\n\n그래서 다음과 같이 Suspense를 한번 감싸서 사용해줄 수 있습니다.\n\n\n이렇게 수정된 Suspense로 제어하고 있는 컴포넌트를 SSG로 빌드하게 되면 fallback이 렌더링됩니다.\n\n다음과 같은 코드일 경우, SSG 시점엔 <Loading /> 컴포넌트만 그려지게 됩니다.\n\n\n즉, 빌드 단계에서 SSG로 미리 그려주고자 했던 UserPage에는 Loading 컴포넌트만 렌더링 될 뿐, UserProfile , UserDetailInfo 컴포넌트는 전혀 렌더링 되지 않습니다. 미리 렌더링하는 것에 대한 이점을 전혀 얻지 못하게 되는 것입니다.\n\n번들 사이즈를 아무리 줄여도 사용자는 일단 로딩만 돌고 있는 흰 화면을 마주하게 되는 것입니다.\n\n컴포넌트 배치 되돌아보기\n우선 Suspense가 정말 필요한 컴포넌트인지, 레이아웃 영역인지 되돌아 볼 필요가 있습니다.\n\n정말 Suspense가 필요한 영역이라면 fallback 컴포넌트를 정의해줄 때 로딩 컴포넌트만 정의해주지 않는다면 어떨까요? API 응답이 돌아오고 결국 그려질 컴포넌트와 응답이 오지 않았을 경우 보여줄 이 fallback 컴포넌트를 최대한 비슷하게 구성해주는 겁니다. 그렇다면 컴파일 시점에 그릴 수 있는 영역이 늘어나지 않을까요?\n\n즉, 위와 같이 Loading 컴포넌트만 렌더링하지 않으려면 API 응답이 돌아왔을 때 그려져야 할 컴포넌트와 응답이 아직 돌아오지 않았을 때 보여줄 컴포넌트 두 벌이 최대한 비슷하게 구성되어 있어야 합니다.\n\n컴포넌트와 API를 가깝게\n처음 보셨던 화면에서는 총 16개의 API call이 존재합니다. 너무나 당연하게도 이 모든 API 응답은 제각각으로 올 것이고 모든 응답이 돌아오기를 기다렸다가 그려주는 것은 정말 낭비입니다.\n\n각각의 API들을 따로 격리시켜 서로의 렌더링을 block하지 않도록 합니다.\n데이터가 필요한 곳에서 가장 가까운 곳에서 API를 호출합니다. client caching이 이젠 너무나도 자연스럽기 때문에 이를 최대한 활용해줍니다.\nUserPage 컴포넌트의 구조를 다음과 같이 변경해 볼 수 있습니다.\n\n\n페이지 컴포넌트(UserPage) 전체를 감싸고 있던 Suspense 컴포넌트가 사라지고 비동기로 처리되는 영역이 좁게 정의가 되었습니다. 또한 비동기 처리 과정 중 노출되는 컴포넌트의 모습도 원래 보여질 컴포넌트와 비슷하게 정의해줬습니다.\n\n디자인이 필요한 영역이 늘었어요. API를 호출하고 기다리는 순간에 대해서도 디자인이 필요해요. 그대로 컴포넌트도 만들어줘야 하고 그만큼 손도 많이 갑니다. 하지만 서버 관리하는 비용보다 더 신경써줄 필요는 없다고 생각합니다.\n\n조금만 신경쓰더라도 많은 개선을 볼 수 있는 방법입니다.\n\n더 나아가기\n지난 Next.js Conf에서 공식적으로 React의 Server Component를 사용한 렌더링 방식이 공개되었습니다. React 18도 알파 단계이니 프런트엔드 애플리케이션을 개발하면서 성능 상 이점을 많이 챙길 수 있는 환경으로 뒤바꿈 될 것 같습니다. ISR 방식과 컴포넌트 단위의 캐싱이 적용되어 웹이 더 빨라질 수 있을 것이라 기대합니다.\n\n마무리\n초기 로딩 속도가 중요한 것은 비즈니스에도 영향을 미치기 때문입니다. web.dev에서 초기 로딩 속도를 개선하여 성과가 개선된 사례가 소개된 바 있습니다.(https://web.dev/vitals-business-impact/)\n\n당장에 SSR 도입이 쉽지 않은 상황이라면 SSG를 통한 초기 렌더링을 최적화 할 수 있습니다.\n\n토스 팀은 계속해서 초기 로딩 속도를 계속해서 개선 중입니다. 곧 있을 SLASH22에서는 ‘매달, 유저가 기다리는 시간을 2.3년씩 아낄 수 있는 초기 렌더링 개선기 (feat. SSR)’라는 제목으로 초기 렌더링 개선 경험을 공유할 예정이니 많은 관심 부탁드립니다.\n\n👉 토스페이먼츠 프런트엔드 챕터에 대해 더 알아보기\n\n감사합니다.","isDisplayingFeedback":true},{"id":21036,"updatedTime":"2023-04-14T12:25:40+09:00","createdTime":"2023-04-12T16:04:31+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null}],"series":null,"title":"개발자의 애질리티","subtitle":"이 글은 토스페이먼츠에 입사하신, 혹은 입사를 고려 중인 개발자분들을 위해 작성된 글입니다. 애자일하게 일한다는 것은 어떠한 의미일까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/10/techblog-06-agility.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"개발자의 애질리티"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/10/techblog-06-agility.png","backgroundColor":null,"isFill":true,"imageAlt":"개발자의 애질리티"},"key":"dev-agility","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2021-10-14T22:32:16+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21036,"title":null,"description":"이 글은 토스페이먼츠에 입사하신, 혹은 입사를 고려 중인 개발자분들을 위해 작성된 글입니다.애자일하게 일한다는 것은 어떠한 의미일까요? 한 시간을 일하면 한 시간 만큼의 가치를 만들어 내는 방식이 아닐까 합니다. 예를 들어, 동작하는 함수를 구현하거나 난해한 개념을 이해하는 식으로요.","urlSlug":"dev-agility","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"개발자의 애질리티","description":"이 글은 토스페이먼츠에 입사하신, 혹은 입사를 고려 중인 개발자분들을 위해 작성된 글입니다. 애자일하게 일한다는 것은 어떠한 의미일까요?","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/tech-blog/og-image:/techblog-06-agility-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2331,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":562,"name":"강병훈","slug":"byeonghun-kang","shortDescription":"Head of Technology","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/byeonghun-kang.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"이 글은 토스페이먼츠에 입사하신, 혹은 입사를 고려 중인 개발자분들을 위해 작성된 글입니다.\n\n애자일하게 일하기\n애자일하게 일한다는 것은 어떠한 의미일까요? 한 시간을 일하면 한 시간 만큼의 가치를 만들어 내는 방식이 아닐까 합니다. 예를 들어, 동작하는 함수를 구현하거나 난해한 개념을 이해하는 식으로요. \n\nBig up-front 설계\n과거에는 프로젝트 진행 초기부터 분석과 설계에 많은 시간을 투자했습니다. 전체 프로젝트의 ⅓ 이상이 분석과 설계일 정도로요. 문제는 프로젝트 기간의 ½ 시점에 요구사항이 크게 변한다면 결과물 하나 없이 다시 새로 시작해야 한다는 점이었습니다. 세상의 변화속도가 엄청나게 빨라진 지금, 초기 설계 비용이 큰 big up-front 설계가 항상 잘 들어맞지 않는다는 사실을 이제는 대부분의 사람이 알게 되었습니다.\n\n애자일 개발 방법론\n애자일 개발 방법론에서는 애초에 크게 설계하지 않습니다. 간단한 사용 시나리오를 작성하고 그것의 구현을 목표로 하는 짧은 주기를 가집니다. 거대한 아키텍처를 설계하지 않고 이번 주기(이터레이션(Iteration) 혹은 스프린트(Sprint))에서 달성할 수 있는 만큼의 설계를 추구합니다. (앞으로는 주기가 아닌 스프린트라고 표현하겠습니다.)\n\n예를 들어 카드 승인이 100가지의 하위 기능으로 구분할 수 있다면, 이번 스프린트의 목표를 그중에 3가지로 결정할 수 있습니다. 나머지 기능을 함께 확인하고 싶으면 어떻게 하냐구요? 애초에 3가지 기능 외에는 개발하지 않는다는 목표로 일을 진행하기 때문에 스프린트 목표 달성 여부를 확인할 때에도 오직 이 3가지 기능만 확인합니다. 이번 스프린트를 성공적으로 달성했다면 팀은 최소한 3개의 작은 기능을 획득할 수 있게 됩니다. \n\n개발자들은 요구사항 전체가 아닌 이번 스프린트에 필요한 요구사항에 더 집중할 수 있게 되고, 만약 스프린트가 성공적으로 진행되었다면 3개의 기능을 제공하는 소프트웨어를 가지게 됩니다. 팀은 점진적으로 비즈니스에 대한 학습을 진행하면서 작지만 동작하는 일부 기능을 확실히 정복해 갈 수 있게 되는 것이죠. 이런 방식으로 팀은 매 스프린트 목표에 맞추어 성장하고, 그에 맞추어 제품도 계속 성장해 나가게 됩니다. 나아가 다음 스프린트에 전혀 다른 기능을 개발하더라도 충분히 다시 쓸 수 있는 동작하는 코드를 확보하게 됩니다. 이러한 점에서 애자일 개발 방법론은 투자한 만큼의 가치를 만드는 방식이라고 볼 수 있습니다.\n\n\n그림: 애자일 프로젝트에서의 기능과 시간의 관계\n\n\n그림: big up-front 설계가 적용된 프로젝트에서의 기능과 시간의 관계\n\n애자일 프로젝트는 시간에 비례하여 기능의 수가 증가하고, 비-애자일 프로젝트에서는 상대적으로 후반부에 기능이 집중적으로 증가함을 표현해 봤습니다.\n\n품질과 생산성\n어떤 코드를 보고 최고의 품질인지 판단하는 것은 매우 어려운 일입니다. 피카소조차도 더 탁월한 화가를 만난다면 자신의 작품에 몇 점을 매겨야 할지 애매할 수 있습니다.\n\n평범한 화가가 심혈을 기울인다고 하여 피카소 만큼 훌륭한 그림을 그릴 확률 역시 극히 낮을 것입니다. 이러한 논리는 개발자에게도 그대로 적용 가능합니다. 개인의 품질 역량을 10이라고 가정했을 때 평균적으로 8정도의 품질을 보여줄 확률이 높으며, 상당한 노력을 투입해야 10의 품질을 만들어 낸다고 생각할 수 있습니다. 따라서 11의 품질을 추구하게 된다면 생산성이 극적으로 저하될 수 있습니다. \n\n기존의 코드를 개선하여 품질을 높이고자 한다면 어느 정도의 품질 개선을 목표로 해야 할까요? 만약 전체 코드를 복제한다면 품질 개선율 0%, 공정률 100%를 즉시 달성할 수 있습니다. 만약 품질 개선율 1%, 생산 공정률 100%를 달성하고자 한다면 전체 코드의 1%를 개선하는 만큼의 시간을 더 사용해야 합니다.\n\n품질을 더 개선하고 싶은데 스스로 해내기가 쉽지 않다고 판단된다면 다양한 주변 환경(동료, 메이트, 멘토, 팀, 단위 테스트 등)을 활용하여 성장 환경을 만들어 가는 것이 중요한 것 같습니다. 특히 토스페이먼츠에는 기술 논의를 즐기는 기술 덕후들이 꽤 많습니다. 내 주변이 나 때문에 활기 넘치게 만들어 보세요.\n\n핵심은 코드 리딩의 생산성\n대부분의 회사에는 다른 개발자들이 생산한 코드가 항상 산적해 있습니다. 어떤 기능을 개선하고 싶다면 다른 사람이 작성한 코드를 읽어야 하죠. 그래서 보통은 코드를 읽는 시간이 작성하는 시간보다 훨씬 깁니다. 따라서 읽기 좋은 코드를 만드는 것은 개발자의 삶에 굉장히 중요합니다.\n\n기존 코드를 읽는 것에 과도한 시간을 써야 한다면 기능 개선을 위한 준비 작업에만 상당한 시간을 소비하게 되어 생산성이 떨어지게 됩니다.읽기 좋은 코드를 만들어서 코드 리딩의 생산성을 향상시키는 것이 중요한 이유입니다.\n\n가능하다면 코드를 읽을 때 리팩토링 기술(Rename Method, Extract Method 등)을 활용하는 것이 좋습니다. 이러한 리팩토링을 Michael Feathers는 ‘탐색적 리팩토링(Exploratory Refactoring)’ 이라고 부르며, 이 과정에서 수정된 코드가 최종적으로 코드 저장소에 반영되지 않는다고 하더라도 충분히 가치있는 일입니다. 제가 느끼기에 Exploratory Refactoring은 정말로 효과적인 학습 프로세스이기 때문입니다.Exploratory Refactoring을 수행하게 되면 코드를 읽은 즉시 나의 해설을 표시하기 때문에 굉장히 적극적으로 코드 리딩이 되며, 코드 리딩의 주도권을 자연스럽게 리더(reader)가 가져가게 됩니다. 책을 읽었는데도 이해가 안되서 다시 읽어야 하는 것과 같은 수동적인 상태에서 벗어날 수 있게 됩니다. 따라서 Exploratory Refactoring은 탁월한 개발자가 탁월해지게 만들어주는 진정한 OP 기술입니다.\n\n리팩토링의 가치\n개발자들이 리팩토링의 욕구를 강하게 느낄 때는 보통 유지보수 비용이 과도한 경우입니다. 유지보수 비용이 높은 이유는 기능을 수정해야 하는데 어느 코드를 수정해야 할지, 몇 줄의 코드를 바꿔야 할지, 변경을 했다면 올바르게 변경했는지 등을 파악하기 어렵기 때문입니다.\n\n따라서 요구사항에 대응하는 코드가 어디인지 명확하게 찾아낼 수 있고, 수정한 부분의 동작이 정확한지 파악하기 쉽다면 유지보수 비용을 낮출 수 있습니다. 리팩토링의 목적은 이러한 부분을 달성하는 데 있습니다.\n\n따라서 리팩토링이 잘 수행되었다면 새로운 개발자(혹은 미래의 자신)가 기능 변경 요청을 받았을 때 아래의 3가지를 쉽게 해낼 수 있습니다.\n\n코드 위치 파악\n코드 수정 \n기능 테스트\n리팩토링으로 잘 설계된 코드는 이러한 핵심 과업을 쉽게 이행하는데 큰 도움이 됩니다.\n\n결론\n애자일 기법은 요구사항이라는 큰 덩어리를 작지만 동작하는 작은 기능으로 나누고 매 스프린트 마다 목표한 바를 착실히 정복해가는 방식이라고 할 수 있습니다.\n\n이 때 안전하게 기능을 수정 혹은 추가하기 위해서는 3개의 핵심 과업을 잘 수행해야 하는데요,\n\n코드로부터 도메인 파악하기(a.k.a. 코드 고고학)\n수정에 필요한 코드 파악하기\n수정된 코드 쉽게 검증하기\n토스페이먼츠에서는 애자일하게 일하는 방법을 동료들과 함께 일 하면서 쉽게 터득할 수 있는 좋은 문화와 프로세스를 만들기 위해 서툰 실험을 계속하고 있습니다.","isDisplayingFeedback":true},{"id":21002,"updatedTime":"2023-04-12T17:25:54+09:00","createdTime":"2023-04-12T16:00:42+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"Template Literal Types로 타입 안전하게 코딩하기","subtitle":"TypeScript 코드베이스의 타입 안전성을 한 단계 올려줄 수 있는 Template Literal Type의 뜻과 응용에 대해 알아봅니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/05/techblog-05-template-literal.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"Template Literal Types로 타입 안전하게 코딩하기"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/05/techblog-05-template-literal.png","backgroundColor":null,"isFill":false,"imageAlt":"Template Literal Types로 타입 안전하게 코딩하기"},"key":"template-literal-types","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2021-05-14T15:26:37+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21002,"title":null,"description":"2020년 11월 TypeScript 4.1이 출시되면서 \"Template Literal Type\"을 사용할 수 있게 되었습니다. TypeScript로 JSON Parser를 만들거나, document.querySelector 의 결과 타입을 추론할 수 있게 되어 화제가 되었는데요. 이...","urlSlug":"template-literal-types","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"Template Literal Types로 타입 안전하게 코딩하기","description":"TypeScript 코드베이스의 타입 안전성을 한 단계 올려줄 수 있는 Template Literal Type의 뜻과 응용에 대해 알아봅니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/tech-blog/og-image:/techblog-05-template-literal-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2322,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":556,"name":"박서진","slug":"sojin-park","shortDescription":"Frontend Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/sojin.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":6,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"2020년 11월 TypeScript 4.1이 출시되면서 'Template Literal Type'을 사용할 수 있게 되었습니다. TypeScript로 JSON Parser를 만들거나, document.querySelector 의 결과 타입을 추론할 수 있게 되어 화제가 되었는데요. 이번 아티클에서는 Template Literal Type이란 무엇인지, 이를 바탕으로 어떻게 그런 결과물을 만들 수 있었는지 간단히 예시로 소개드리고자 합니다.\n\nTemplate Literal Type이란?\n간단히 말해, Template Literal Type이란 기존 TypeScript의 String Literal Type을 기반으로 새로운 타입을 만드는 도구입니다. 구체적인 예시로 Template Literal Type에 대해 자세히 살펴보겠습니다.\n\n예시 1: 가장 간단한 형태\n\nTypeScript Playground\n\n가장 간단한 형태로, 원래 있던 'toss' 라고 하는 타입을 바탕으로 'toss payments' 라고 하는 타입을 만드는 경우를 생각할 수 있습니다.\n\nTypeScript 4.1 이전에는 이런 문자열 작업이 불가능했지만, Template Literal Type을 이용함으로써 보다 넓은 타입 연산이 가능해졌습니다.\n\n예시 2: 하나의 Union Type\n\nTypeScript Playground\n\nTemplate Literal Type을 Union type(합 타입)과 함께하면, 결과물도 Union Type이 됩니다.\n\n예를 들어, 위 예시에서 'toss' 타입과 'core' | 'bank' | 'securities' | ... 타입을 Template Literal Type으로 연결하면 'toss core' | 'toss bank' | 'toss securities' | ... 와 같이 확장되는 것을 확인할 수 있습니다.\n\n예시 3: 여러 개의 Union Type\n\nTypeScript Playground\n\n여러 개의 Union Type을 연결할 수도 있습니다.\n\n예를 들어, 위에서는 VerticalAlignment 타입과 HorizontalAlignment 타입을 연결하여, ${VerticalAlignment}-${HorizontalAlignment} 타입을 만들었습니다.\n\n원래라면 중복해서 Alignment 타입을 다시 정의해야 했겠지만, Template Literal Type을 사용함으로써 중복 없이 더욱 간결히 타입을 표현할 수 있게 되었습니다.\n\n예시 4: 반복되는 타입 정의 없애기\n문제 상황\n\n\n이벤트에 대한 핸들러를 등록할 때, addEventListener('event', handler) 와 onEvent = handler 의 두 가지 형식을 모두 사용할 수 있는 MyElement 타입을 생각해봅시다.\n\n\n예를 들어, click 이벤트를 구독할 때, 위의 두 가지 방법을 모두 사용할 수 있는 것입니다.\n\n요소에 추가할 수 있는 이벤트의 종류는 자주 변경되고는 합니다. 예를 들어, 브라우저 API가 바뀌면서 'pointerDown' 과 같은 이벤트가 새로 추가될 수 있습니다.\n\n이런 경우, TypeScript 4.1 이전에는 매번 수동으로 여러 곳의 타입을 수정해야 했습니다. 우선 addEventListener의 인자로 사용되는 이벤트 이름 EventNames 타입에 'pointerDown' 을 넣어야 했습니다. 또 onPointerDown 메서드를 명시해야 했습니다. 잊지 않고 두 곳을 수정해야 했기 때문에, 실수하기 쉬웠습니다.\n\n하지만 Template Literal Type을 이용하면 한 곳만 수정해도 모두에 반영되도록 할 수 있습니다.\n\n\n위 코드를 한번 자세히 살펴봅시다.\n\nCapitalizedEventNames 타입을 정의할 때, TypeScript 4.1에서 추가된 Capitalize<T> 타입을 이용하여 EventNames의 첫 글자를 대문자로 만들었습니다.\nHandlerNames 타입을 만들 때, Template Literal Type으로 onClick 과 같이 on 접두사를 붙였습니다.\nHandlers 타입에서는 기존의 onClick, onMouseDown 과 같은 이벤트 핸들러를 메서드로 가지도록 했고,\n마지막으로 MyElement 에서는 addEventListener 메서드를 가지는 객체와 연결하여 원래와 동일한 동작을 하는 타입을 만들 수 있었습니다.\n이제 EventNames 만 수정하면 MyElement 에서 이벤트를 구독하는 양쪽 모두 대응이 되므로, 코드가 깔끔해지고 실수의 여지가 적어졌습니다. ✨\n\nConditional Type과 더 강력한 추론하기\nTemplate Literal Type은 Conditional Type과 함께 더욱 강력하게 사용할 수 있습니다.\n\nConditional Type 되짚어보기\nConditional Type은 JavaScript의 삼항 연산자와 비슷하게 분기를 수행하면서, 타입을 추론하는 방법인데요. 고급 TypeScript 사용에서 강력한 타입 연산을 하기 위해서 빠지지 않습니다.\n\nTemplate Literal Type을 더 잘 다루기 위해 반드시 필요한 개념이므로, 간단한 예시로 Conditional Type을 사용하는 방법에 대해 살펴보겠습니다.\n\n예시 1: 제네릭 타입 인자 꺼내오기\n\nConditional Type을 가장 자주 사용하는 경우로,  Promise<number>와 같은 타입에서 number 를 꺼내오고 싶은 상황을 생각해봅시다.\n\n\nTypeScript Playground\n\n위 코드를 살펴보면, PromiseType<T> 타입에 Promise<number> 타입을 인자로 넘기면 number 타입을 얻고 있습니다.\n\nConditional Type이 동작하는 방식을 간단히 알아봅시다.\n\n삼항 연산자처럼 생긴 부분 가운데 X extends Y 와 같이 생긴 조건 부분은 X 타입의 변수가 Y 타입에 할당될 수 있는지에 따라 참값이 평가됩니다.\n\n예시:\n\ntrue extends boolean: true 는 boolean 에 할당될 수 있으므로 참으로 평가됩니다.\n'toss' extends string: 'toss' 는 string 에 할당될 수 있으므로 참으로 평가됩니다.\nArray<{ foo: string }> extends Array<unknown>: 마찬가지로 참으로 평가됩니다.\nstring extends number: 문자열은 숫자 타입에 할당될 수 없으므로 거짓입니다.\nboolean extends true: boolean 타입 가운데 false 는 true 에 할당될 수 없으므로 거짓입니다.\n조건식이 참으로 평가될 때에는 infer 키워드를 사용할 수 있습니다. 예를 들어, Promise<number> extends Promise<infer U> 와 같은 타입을 작성하면, U 타입은 number 타입으로 추론됩니다. 이후 참인 경우에 대응되는 식에서 추론된 U 타입을 사용할 수 있습니다.\n\n예를 들어, Promise<number> extends Promise<infer U> ? U : never 에서는 조건식이 참이고 U 타입이 number로 추론되므로, 이를 평가한 타입의 결과는 number 가 됩니다.\n\n반대로 number extends Promise<infer U> ? U : never 에서는 조건식이 거짓이므로 이를 평가한 결과는 never가 됩니다.\n\n예시 2: Tuple 다루기\n\n[string, number, boolean] 과 같은 TypeScript의 Tuple Type에서 그 꼬리 부분인 [number, boolean] 과 같은 부분만 가져오고 싶은 상황을 생각해봅시다.\n\nConditional Type과 Variadic Tuple Type을 활용함으로써 이를 간단히 구현할 수 있습니다.\n\n\nTypeScript Playground\n\n첫 요소를 제외하고 ...infer U 구문을 이용하여 뒤의 요소들을 모두 선택한 것을 확인할 수 있습니다.\n\n이 외에 간단한 형태로 특정한 튜플이 비어 있는지 검사하기 위해서, 아래와 같은 IsEmpty<T> 타입을 정의할 수도 있습니다.\n\n\nTypeScript Playground\n\nConditional Type에 대해 더 궁금하신 분은 TypeScript 공식 문서를 참고하시기 바랍니다.\n\n이제 Conditional Type과 Template Literal Type을 함께 사용했을 때 어떤 결과를 얻을 수 있는지 살펴봅시다.\n\n초급 예시 1: 간단한 추론\n\n가장 간단한 예시로, 'fadeIn' | 'fadeOut' 과 같은 타입에서 앞의 fade 접두사를 버리고 'In' | 'Out' 만 가져오고 싶은 상황을 생각해봅시다.\n\nPromise<number> 에서 number 를 가져오는 것과 유사하게, Conditional Type을 이용하여 접두사를 제외할 수 있습니다.\n\n중급 예시 1: 문자열에서 공백 없애기\n위의 예시를 응용하면 문자열의 공백을 없애는 타입을 정의할 수 있습니다. 예를 들어, 아래와 같이 오른쪽의 공백을 모두 제거한 타입을 만들 수 있습니다.\n\n\nTrimRight<T> 타입은 재귀적 타입 선언을 활용합니다.\n\n\nTypeScript Playground\n\n위 코드를 살펴보시면, infer R 문 뒤에 하나의 공백이 있는 것을 확인하실 수 있습니다.\n\n즉, T 타입의 오른쪽에 공백이 하나 있다면, 공백을 하나 빠뜨린 것을 R 타입으로 추론하고, 다시 TrimRight<R> 을 호출합니다.\n\n만약 공백이 더 이상 존재하지 않는다면, 원래 주어진 타입 그대로를 반환합니다.\n\nTypeScript에는 if 문이 존재하지 않지만, 만약 존재한다고 가정했을 때 아래와 같이 작성해볼 수 있습니다.\n\n\n보다 재귀적인 구조를 잘 확인할 수 있습니다.\n\n중급 예시 2: 점으로 연결된 문자열 Split하기\n재귀적 타입 정의를 활용하면 'foo.bar.baz' 와 같은 타입을 ['foo', 'bar', 'baz'] 로 나누는 타입을 정의할 수 있습니다.\n\n\nTypeScript Playground\n\n주어진 S 타입에서 첫번째 점(.) 을 찾고, 그 앞 부분을 T, 뒷 부분을 U 로 추론합니다. 이후 이를 [T, ...Split<U>]와 같이 재귀적으로 하나씩 값을 이어 나가면서 원하는 결과 타입을 만들어 나갑니다.\n\n이 경우에도 if 문이 있다는 가정 하에 pseudo-code로 정리해볼 수 있습니다.\n\n\n고급 예시: lodash.set() 함수 타입 추론하기\nlodash.set()는 아래와 같이 문자열로 된 접근자를 이용하여 객체의 깊은 프로퍼티까지 수정할 수 있는 함수입니다.\n\n\nTemplate Literal Type이 있기 전, 이런 함수는 타입 안전하게 사용할 수 없어 세 번째 인자를 any 로 규정해야 했습니다. 그러나 위에서 살펴본 타입 정의를 조합하면 lodash.set() 를 더욱 안전하게 타이핑할 수 있습니다. 💯\n\nlodash.set() 함수를 정확하게 타이핑하기 위해서는 아래의 ValueOf<T, P> 타입이 필요합니다. ValueOf<T, P> 타입은 객체 T 와 접근 경로 P가 주어졌을 때, T 를 P 경로로 순서대로 접근했을 때 결과로 나오는 타입을 나타냅니다.\n\n\n만약에 위와 같은 ValueOf<T, P> 이 있다면, 위에서 만들었던 Split<S> 과 조합하여 쉽게 lodash.set() 함수에 타입을 부여할 수 있을 것입니다.\n\n\n이제 ValueOf<T, P> 타입을 만들어봅시다. if 문과 내부 타입 선언이 있는 pseudo-code로 나타낸다면, 아래와 같이 코드를 작성할 수 있습니다.\n\n\nValueOf<T, P> 타입이 그렇게 동작한다면, 위의 Foo 예시에서는 아래와 같이 차례대로 값이 계산될 것입니다.\n\n\n작성했던 의사 코드를 유효한 TypeScript 코드로 나타내면 다음과 같습니다.\n\n\n위 내용을 모두 조합하면 lodash.set()을 안전하게 다룰 수 있는데요. 실제로 동작하는 방식을 TypeScript Playground에서 확인해보실 수 있습니다. 😉\n\nTemplate Literal Type의 응용\n위에서 살펴본 바와 같이, Template Literal Type을 Conditional Type과 사용하면 더욱 많은 코드를 안전하게 사용할 수 있습니다. awesome-template-literal-types 레포지토리에는 상상력을 자극하는 Template Literal Type의 사용 예시들이 모여 있습니다.\n\n대표적으로 화제가 되었던 예시들에 대한 링크를 남기고 글을 맺습니다.\n\n1. TypeScript로 JSON 파서 만들기\n\n\n코드와 같이 JSON 문자열을 바로 TypeScript 타입으로 옮길 수 있다는 Proof-of-concept로 화제가 되었습니다.\n\n2. document.querySelector를 타입 안전하게 사용하기\n\n\na 태그를 선택했을 때 결괏값이 HTMLAnchorElement가 되는 것을 확인하실 수 있습니다.\n\n3. Express의 Route Parameter로부터 타입 추론하기\n\n\nExpress에서 사용하는 경로 문자열에서 Route Parameter의 타입을 추론할 수 있습니다.","isDisplayingFeedback":true},{"id":21012,"updatedTime":"2023-04-12T17:25:55+09:00","createdTime":"2023-04-12T16:01:46+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"node_modules로부터 우리를 구원해 줄 Yarn Berry","subtitle":"토스 프론트엔드 레포지토리 대부분에서 사용하고 있는 패키지 매니저 Yarn Berry. 채택하게 된 배경과 사용하면서 좋았던 점을 공유합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/05/techblog-04-yarn-berry.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"node_modules로부터 우리를 구원해 줄 Yarn Berry"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/05/techblog-04-yarn-berry.png","backgroundColor":null,"isFill":false,"imageAlt":"node_modules로부터 우리를 구원해 줄 Yarn Berry"},"key":"node-modules-and-yarn-berry","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2021-05-07T17:18:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21012,"title":null,"description":"토스 프론트엔드 챕터에서는 지난해부터 의존성을 관리하기 위해 Yarn Berry(v2)를 도입했습니다. 처음에는 일부 레포지토리부터 시작하여, 현재는 대부분의 레포지토리에 Yarn Berry가 적용되어 있는데요. 토스팀이 새로운 패키지 관리 시스템을 도입하게 된 배경과 사용하면서 좋았던...","urlSlug":"node-modules-and-yarn-berry","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"node_modules로부터 우리를 구원해 줄 Yarn Berry","description":"토스 프론트엔드 레포지토리 대부분에서 사용하고 있는 패키지 매니저 Yarn Berry. 채택하게 된 배경과 사용하면서 좋았던 점을 공유합니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/tech-blog/og-image:/techblog-04-yarn-berry-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2327,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":556,"name":"박서진","slug":"sojin-park","shortDescription":"Frontend Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/sojin.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":6,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스 프론트엔드 챕터에서는 지난해부터 의존성을 관리하기 위해 Yarn Berry(v2)를 도입했습니다. 처음에는 일부 레포지토리부터 시작하여, 현재는 대부분의 레포지토리에 Yarn Berry가 적용되어 있는데요. 토스팀이 새로운 패키지 관리 시스템을 도입하게 된 배경과 사용하면서 좋았던 점을 테크 블로그를 통해 공유합니다.\n\nYarn Berry란?\nYarn Berry는 Node.js를 위한 새로운 패키지 관리 시스템으로, Yarn v1의 주요 개발자인 Maël Nison 씨가 만들었습니다. 2020년 1월 25일부터 정식 버전(v2)가 출시되어, 현재는 Babel과 같은 큰 오픈소스 레포지토리에서도 채택하고 있습니다. Yarn Berry는 GitHub yarnpkg/berry 레포지토리에서 소스코드가 관리되고 있습니다.\n\nYarn Berry는 기존의 '깨져 있는' NPM 패키지 관리 시스템을 혁신적으로 개선합니다.\n\nNPM의 문제점\nNPM은 Node.js 설치 시에 기본으로 제공되어 범용적으로 사용되고 있으나, 비효율적이거나 깨져 있는 부분이 많습니다.\n\n\n비효율적인 의존성 검색\nNPM은 파일 시스템을 이용하여 의존성을 관리합니다. 익숙한 node_modules 폴더를 이용하는 것이 특징인데요. 이렇게 관리했을 때 의존성 검색은 비효율적으로 동작합니다.\n\n예를 들어, /Users/toss/dev/toss-frontend-libraries 폴더에서 require() 문을 이용하여 react 패키지를 불러오는 상황을 가정합시다.\n\n라이브러리를 찾기 위해 순회하는 디렉토리의 목록을 확인하려고 할 때, Node.js에서 제공하는 require.resolve.paths() 함수를 사용할 수 있습니다. 이 함수는 NPM이 검색하는 디렉토리의 목록을 반환합니다.\n\n\n목록에서 확인할 수 있는 것처럼, NPM은 패키지를 찾기 위해서 계속 상위 디렉토리의 node_modules 폴더를 탐색합니다. 따라서 패키지를 바로 찾지 못할수록 readdir, stat과 같은 느린 I/O 호출이 반복됩니다. 경우에 따라서는 I/O 호출이 중간에 실패하기도 합니다.\n\nTypeScript 4.0까지는 node_modules를 이용한 패키지 탐색이 너무 비효율적인 나머지, 패키지를 처음으로 import 하기 전까지는 node_modules 내부의 타입 정보를 찾아보지 않기도 했습니다. (TS 4.0 Changelog)\n\n환경에 따라 달라지는 동작\nNPM은 패키지를 찾지 못하면 상위 디렉토리의 node_modules 폴더를 계속 검색합니다. 이 특성 때문에 어떤 의존성을 찾을 수 있는지는 해당 패키지의 상위 디렉토리 환경에 따라 달라집니다.\n\n예를 들어, 상위 디렉토리가 어떤 node_modules를 포함하고 있는지에 따라 의존성을 불러올 수 있기도 하고, 없기도 합니다. 다른 버전의 의존성을 잘못 불러올 수 있는 여지도 존재합니다.\n\n이렇게 환경에 따라 동작이 변하는 것은 나쁜 징조입니다. 해당 상황을 재현하기 까다로워지기 때문입니다.\n\n비효율적인 설치\nNPM에서 구성하는 node_modules 디렉토리 구조는 매우 큰 공간을 차지합니다. 일반적으로 간단한 CLI 프로젝트도 수백 메가바이트의 node_modules 폴더가 필요합니다. 용량만 많이 차지할 뿐 아니라, 큰 node_modules 디렉토리 구조를 만들기 위해서는 많은 I/O 작업이 필요합니다.\n\nnode_modules 폴더는 복잡하기 때문에 설치가 유효한지 검증하기 어렵습니다. 예를 들어, 수백 개의 패키지가 서로를 의존하는 복잡한 의존성 트리에서 node_modules 디렉토리 구조는 깊어집니다.\n\n이렇게 깊은 트리 구조에서 의존성이 잘 설치되어 있는지 검증하려면 많은 수의 I/O 호출이 필요합니다. 일반적으로 디스크 I/O 호출은 메모리의 자료구조를 다루는 것보다 훨씬 느립니다. 이런 문제로 인해 Yarn v1이나 NPM은 기본적인 의존성 트리의 유효성까지만 검증하고, 각 패키지의 내용이 올바른지는 확인하지 않습니다.\n\n유령 의존성 (Phantom Dependency)\nNPM 및 Yarn v1에서는 중복해서 설치되는 node_modules를 아끼기 위해 끌어올리기(Hoisting) 기법을 사용합니다.\n\n\n예를 들어, 의존성 트리가 왼쪽의 모습을 하고 있다고 가정합시다.\n\n왼쪽 트리에서 [A (1.0)]과 [B (1.0)] 패키지는 두 번 설치되므로 디스크 공간을 낭비합니다. NPM과 Yarn v1에서는 디스크 공간을 아끼기 위해 원래 트리의 모양을 오른쪽 트리처럼 바꿉니다.\n\n오른쪽 트리로 의존성 트리가 바뀌면서 package-1 에서는 원래 require() 할 수 없었던 [B (1.0)] 라이브러리를 불러올 수 있게 되었습니다.\n\n이렇게 끌어올리기에 따라 직접 의존하고 있지 않은 라이브러리를 require() 할 수 있는 현상을 유령 의존성(Phantom Dependency)이라고 부릅니다.\n\n유령 의존성 현상이 발생할 때, package.json에 명시하지 않은 라이브러리를 조용히 사용할 수 있게 됩니다. 다른 의존성을 package.json 에서 제거했을 때 소리없이 같이 사라지기도 합니다. 이런 특성은 의존성 관리 시스템을 혼란스럽게 만듭니다.\n\n\n\nPlug'n'Play (PnP)\nYarn Berry는 위에서 언급한 문제를 새로운 Plug'n'Play 전략을 이용하여 해결합니다.\n\nPlug'n'Play의 배경\nYarn v1은 package.json 파일을 기반으로 의존성 트리를 생성하고, 디스크에 node_modules 디렉토리 구조를 만듭니다. 이미 패키지의 의존성 구조를 완전히 알고 있는 것입니다.\n\nnode_modules 파일 시스템을 이용한 의존성 관리는 깨지기 쉽습니다. 모든 패키지 매니저가 실수하기 쉬운 Node 내장 의존성 관리 시스템을 사용해야 할까요? 패키지 매니저들이 node_modules 디렉토리 구조를 만드는 것에 그치지 않고, 보다 근본적으로 안전하게 의존성을 관리하면 어떨까요?\n\nPlug'n'Play는 이런 생각에서 출발했습니다.\n\nPlug'n'Play 켜기\nNPM에서 최신 버전의 Yarn을 내려받고, 버전을 Berry로 설정하면 Yarn Berry를 사용할 수 있습니다.\n\n\nYarn Berry는 기존 Node.js 의존성 관리 시스템과 많이 다르기 때문에 하위호환을 위해 패키지 단위로만 도입할 수 있습니다.\n\nPlug'n'Play의 동작 방법\nPlug'n'Play 설치 모드에서 yarn install 로 의존성을 설치했을 때, 기존과 다른 모습을 볼 수 있습니다.\n\n\nYarn Berry는 node_modules를 생성하지 않습니다. 대신 .yarn/cache 폴더에 의존성의 정보가 저장되고, .pnp.cjs 파일에 의존성을 찾을 수 있는 정보가 기록됩니다. .pnp.cjs를 이용하면 디스크 I/O 없이 어떤 패키지가 어떤 라이브러리에 의존하는지, 각 라이브러리는 어디에 위치하는지를 바로 알 수 있습니다.\n\n예를 들어, react 패키지는 .pnp.cjs 파일에서 다음과 같이 나타납니다.\n\n\nreact 17.0.1 버전 패키지의 위치와 의존성의 목록을 완전하게 기술하고 있는 것을 확인할 수 있습니다. 이로부터 특정 패키지와 의존성에 대한 정보가 필요할 때 바로 알 수 있습니다.\n\nYarn은 Node.js가 제공하는 require() 문의 동작을 덮어씀으로써 효율적으로 패키지를 찾을 수 있도록 합니다. 이 때문에 PnP API를 이용하여 의존성 관리를 하고 있을 때에는 node 명령어 대신 yarn node 명령어를 사용해야 합니다.\n\n\n일반적으로 Node.js 앱을 실행할 때에는 package.json의 scripts 에 실행 스크립트를 등록하여 사용하게 됩니다. 이때 Yarn v1에서 사용하던 것처럼 Yarn으로 스크립트를 실행하기만 하면 자동으로 PnP로 의존성을 불러옵니다.\n\n\nZipFS (Zip Filesystem)\nzip으로 묶인 라이브러리가 저장된 .yarn/cache 폴더\n\n\nYarn PnP 시스템에서 각 의존성은 Zip 아카이브로 관리됩니다. 예를 들어, Recoil 0.1.2 버전은 recoil-npm-0.1.2-9a0edbd2b9-c69105dd7d.zip과 같은 압축 파일로 관리됩니다.\n\n이후 .pnp.cjs 파일이 지정하는 바에 따라 동적으로 Zip 아카이브의 내용이 참조됩니다.\n\nZip 아카이브로 의존성을 관리하면 다음과 같은 장점이 생깁니다.\n\n더 이상 node_modules 디렉토리 구조를 생성할 필요가 없기 때문에 설치가 신속히 완료됩니다.\n각 패키지는 버전마다 하나의 Zip 아카이브만을 가지기 때문에 중복해서 설치되지 않습니다. 각 Zip 아카이브가 압축되어 있음을 고려할 때, 스토리지 용량을 크게 아낄 수 있습니다.\n실제로 토스팀에서 의존성이 차지하는 크기를 대폭 감축할 수 있었습니다.\n한 서비스의 경우 NPM을 이용했을 때 node_modules 디렉토리가 약 400MB를 차지했지만, Yarn PnP를 사용했을 때 의존성 디렉토리의 크기는 120MB에 불과했습니다.\n의존성을 구성하는 파일의 수가 많지 않으므로, 변경 사항을 감지하거나 전체 의존성을 삭제하는 작업이 빠릅니다.\n없는 의존성이나 더 이상 필요 없는 의존성을 쉽게 찾을 수 있습니다.\nZip 파일의 내용이 변경되었을 때에는 체크섬과 비교하여 쉽게 변경 여부를 감지할 수 있습니다.\nPlug'n'Play 도입 결과\n토스 프론트엔드 챕터가 Plug'n'Play를 도입한 결과, 다양한 장점을 느낄 수 있었습니다.\n\n의존성을 검색할 때\n의존성을 검색할 때, 더 이상 node_modules 폴더를 순회할 필요가 없습니다. .pnp.cjs 파일이 제공하는 자료구조를 이용하여 바로 의존성의 위치를 찾기 때문입니다. 이로써 require()에 걸리는 시간이 크게 단축되었습니다.\n\n재현 가능성\n패키지의 모든 의존성은 .pnp.cjs 파일을 이용하여 관리되기 때문에 더 이상 외부 환경에 영향받지 않습니다. 이로써 다양한 기기 및 CI 환경에서 require() 또는 import 문의 동작이 동일할 것임을 보장할 수 있게 되었습니다.\n\n의존성을 설치할 때\n더 이상 설치를 위해 깊은 node_modules 디렉토리를 생성하지 않아도 됩니다. 또 NPM이 설치하는 것처럼 같은 버전의 패키지가 여러 번 복사되어 설치 시간을 극단적으로 단축할 수 있습니다. 이에 더해 Zero-install을 사용하면 대부분 라이브러리를 설치 없이 사용할 수 있습니다.\n\n이를 이용하면 CI와 같이 반복적으로 의존성 설치 작업이 이루어지는 곳에서 시간을 크게 절약할 수 있습니다. 토스팀에서는 원래 CI에서 60초씩 걸리던 설치 작업을 Yarn PnP를 도입함으로써 수 초 이내로 단축했습니다.\n\n엄격한 의존성 관리\nYarn PnP는 node_modules에서와 같이 의존성을 끌어올리지 않습니다. 이로써 각 패키지들은 자신이 package.json에 기술하는 의존성에만 접근할 수 있습니다. 기존에 환경에 따라 우연히 작동할 수 있었던 코드들이 보다 엄격히 관리되는 것입니다. 이로써 예기치 못한 버그를 쉽게 일으키던 유령 의존성 현상을 근본적으로 막을 수 있었습니다.\n\n의존성 검증\nnode_modules를 사용하여 의존성을 관리했을 때에는 올바르게 의존성이 설치되지 못해서 의존성 폴더 전체를 지우고 다시 설치해야 하는 경우가 발생하고는 했습니다. node_modules 폴더를 검증하기 어려웠기 때문입니다. 전체 재설치를 수행할 때 node_modules 디렉토리 구조를 다시 만드느라 1분 이상의 시간이 허비되기도 했습니다.\n\nYarn PnP에서는 Zip 파일을 이용하여 패키지를 관리하기 때문에 빠진 의존성을 찾거나 의존성 파일이 변경되었음을 찾기 쉽습니다. 이로써 의존성이 잘못되었을 때 쉽게 바로잡을 수 있습니다. 이로써 올바르게 의존성이 설치되는 것을 100%에 가깝게 보장할 수 있습니다.\n\nZero-Install\n위에서 Yarn Berry의 PnP를 도입함으로써 얻을 수 있는 다양한 장점들을 살펴보았습니다. 여기에서 한 발 더 나아간 생각을 해 볼 수 있습니다. 바로 의존성도 Git 등을 이용하여 버전 관리를 하면 어떨까? 라고 하는 생각인데요.\n\nYarn PnP은 의존성을 압축 파일로 관리하기 때문에 의존성의 용량이 작습니다. 또한 각 의존성은 하나의 Zip 파일로만 표현되기 때문에 의존성을 구성하는 파일의 숫자가 NPM만큼 많지 않습니다. 예를 들어, 일반적인 node_modules 는 1.2GB 크기이고 13만 5천개의 파일로 구성되어 있는 반면, Yarn PnP의 의존성은 139MB 크기의 2천개의 압축 파일로 구성됩니다.\n\n이처럼 용량과 파일의 숫자가 적기 때문에 Yarn Berry를 사용하면 의존성을 Git으로 관리할 수 있습니다. 그리고 이렇게 의존성의 버전을 관리할 때 더욱 큰 장점들을 발견할 수 있습니다.\n\n이렇게 Yarn Berry에서 의존성을 버전 관리에 포함하는 것을 Zero-Install이라고 합니다.\n\n\nYarn Berry Git 레포지토리에서 사용하는 Zero-install\n\n의존성을 버전 관리에 포함하면 많은 장점들이 생깁니다.\n\n새로 저장소를 복제하거나 브랜치를 바꾸었다고 해서 yarn install을 실행하지 않아도 됩니다. 일반적으로 다른 의존성을 사용하는 곳으로 브랜치를 변경했을 때, 잊지 않고 의존성을 설치해주어야 했습니다. 경우에 따라서는 잘못된 의존성 버전이 사용됨으로써 웹 서비스가 알 수 없는 이유로 오동작하기도 했습니다. Zero-Install을 사용했을 때 이런 문제는 완전히 해결됩니다. 더해서 네트워크가 끊어진 곳에서는 오프라인 캐시 기능을 해주기도 합니다.\nCI에서 의존성 설치하는 시간을 크게 절약할 수 있습니다. 토스에서는 일반적으로 캐시가 존재하지 않을 때 의존성을 설치하기 위해서 60초~90초의 시간이 필요했습니다. Zero-Install을 사용하면 Git Clone으로 저장소를 복제했을 때 의존성들이 바로 사용 가능한 상태가 되어, 의존성을 설치할 필요가 없습니다. 이로써 CI 시간을 크게 절약할 수 있었습니다.\n토스 프론트엔드 챕터에서는 Zero-install 기능을 적극적으로 레포지토리에 도입함으로써 빌드와 배포 시간을 크게 단축할 수 있었습니다.\n\n그 외 Yarn Berry에서 좋았던 점\n이 외에 Yarn Berry는 다양한 개발자 친화적인 기능을 제공합니다.\n\n플러그인 시스템: Yarn Berry는 핵심 기능도 플러그인을 이용하여 개발되어 있을 만큼 플러그인 친화적인 환경을 자랑합니다. 필요한 만큼 Yarn의 기능을 확장하여 손쉽게 CLI로 사용할 수 있습니다.토스 프론트엔드 챕터에서는 이현섭님께서 변경된 워크스페이스를 계산하는 플러그인을 며칠만에 만들어주시기도 하셨습니다. 이처럼 Yarn Berry의 기능이 부족하다면 손쉽게 플러그인을 만들 수 있습니다.\n워크스페이스: Yarn Berry는 Yarn v1와 비교할 수 없을 정도로 높은 완성도의 워크스페이스 기능을 제공합니다. Yarn Berry의 Git 레포지토리에서 대표적으로 사용하는 모습을 확인할 수 있습니다. TypeScript를 사용함에도 한 패키지의 소스 코드의 변경사항이 즉시 다른 패키지에 반영되는 모습이 인상적입니다.토스 프론트엔드 챕터에서도 적극적으로 워크스페이스 기능을 사용하고 있습니다.\n패치 명령어 기본 지원: 경우에 따라서 NPM에 배포된 라이브러리의 일부분만 수정해서 사용하고 싶은 니즈가 있습니다. Yarn Berry는 yarn patch 명령어를 제공함으로써 쉽게 라이브러리의 일부분을 수정해서 사용할 수 있도록 합니다. 이렇게 만든 패치 파일은 patch: 프로토콜을 이용해서 쉽게 의존성 설치에 사용할 수 있습니다.\n토스팀은 이렇게 Yarn Berry를 도입함으로써 JavaScript 의존성을 효율적이고 안전하게 다룰 수 있었습니다. 오래 걸리던 CI 속도를 60초 이상 단축하기도 했습니다.\n\n다음 Yarn Berry 아티클에서는 실제로 거대한 서비스 모노레포를 Yarn Berry로 이전한 경험을 소개드리면서 실사용에서 주의할 점에 대해 보다 자세히 소개드리겠습니다.","isDisplayingFeedback":true},{"id":21014,"updatedTime":"2023-04-12T17:25:54+09:00","createdTime":"2023-04-12T16:02:11+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"JSCodeShift로 기술 부채 청산하기","subtitle":"기술 부채는 개발할수록 쌓여만 갑니다. 프론트엔드 챕터가 JSCodeShift를 이용하여 순식간에 100개 서비스의 기술 부채를 해결한 경험을 소개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/05/techblog-03-jscodeshift.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"JSCodeShift로 기술 부채 청산하기"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/05/techblog-03-jscodeshift.png","backgroundColor":null,"isFill":false,"imageAlt":"JSCodeShift로 기술 부채 청산하기"},"key":"jscodeshift","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2021-05-04T17:16:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21014,"title":null,"description":"토스 프론트엔드 챕터에서는 100개 이상의 서비스들이 작은 패키지 단위로 쪼개져 활발하게 개발되고 있는데요. 공통으로 사용하는 라이브러리에서 인터페이스가 변경되는 Breaking Change가 발생하면, 의존하고 있는 모든 서비스의 코드를 수정해야 했습니다. 관리하는 코드베이스가 점점 ...","urlSlug":"jscodeshift","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"JSCodeShift로 기술 부채 청산하기","description":"기술 부채는 개발할수록 쌓여만 갑니다. 프론트엔드 챕터가 JSCodeShift를 이용하여 순식간에 100개 서비스의 기술 부채를 해결한 경험을 소개합니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/tech-blog/og-image:/techblog-03-jscodeshift-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2321,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":555,"name":"박지우","slug":"jiwoo-park","shortDescription":"Frontend Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/jiwoo.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스 프론트엔드 챕터에서는 100개 이상의 서비스들이 작은 패키지 단위로 쪼개져 활발하게 개발되고 있는데요. 공통으로 사용하는 라이브러리에서 인터페이스가 변경되는 Breaking Change가 발생하면, 의존하고 있는 모든 서비스의 코드를 수정해야 했습니다. 관리하는 코드베이스가 점점 커지면서 해야 하는 작업의 양도 계속 늘어나고는 했습니다.\n\n이에 프론트엔드 챕터는 JSCodeShift를 도입하여 대부분의 코드 수정 작업을 자동화할 수 있었습니다. 토스팀이 JSCodeShift를 도입하면서 알게 된 점과 노하우를 테크 블로그로 공유합니다.\n\nJSCodeShift란?\nJSCodeShift는 Facebook이 만든 JavaScript/TypeScript 코드 수정 도구입니다. JSCodeShift를 통해 코드를 수정하는 코드를 작성할 수 있습니다.\n\n찾아 바꾸기와의 비교\nJSCodeShift를 도입하기 전, 토스에서는 대량의 코드 수정이 필요할 때면 IDE의 찾아 바꾸기(Find & Replace)를 사용했습니다. 그러나 찾아 바꾸기로는 안전하게 코드를 수정하는 데에 한계가 많았습니다.\n\n예시 1: console.log() 모두 삭제하기\n프로젝트 전체에 있는 console.log() 호출을 모두 제거하고 싶은 상황을 생각해봅시다. 간단한 예제임에도 쉽게 고칠 수 없는 엣지 케이스들이 발생합니다. 우선 console.log 안에 들어가는 인자의 내용이 달라질 수 있습니다. console.log에 여러 인자를 넘겨서 함수 호출이 여러 줄에 걸칠 수도 있습니다.\n\n이것을 정규식을 이용하여 어느 정도 해결할 수도 있습니다. 그러나 다양한 엣지케이스에 대응하기 위해서 정규식이 점점 복잡해지는 경우가 발생했습니다. 또 정규식은 정규 언어이기 때문에 기술적으로 대응할 수 없는 경우도 존재했습니다.\n\n예시 2: default import된 객체의 프로퍼티 수정하기\n아래와 같은 코드가 있었다고 생각해봅시다.\n\n\n어느 순간 A.foo() 함수가 A.bar() 함수로 이름이 변경되었다고 가정해봅시다.\n\nDefault import의 변수 이름은 사용하는 사람마다 임의로 정할 수 있기 때문에, 어떤 사람은 이 라이브러리를 B 라고 하는 이름으로 사용하고 있을 수도 있습니다. 때문에 이 라이브러리를 B.foo() 처럼 사용하고 있던 코드가 있었다면, B.bar() 로 수정해주어야 합니다.\n\n이런 경우는 찾아 바꾸기로 쉽게 대응하기 어렵습니다.\n\nJSCodeShift 기초\nJSCodeShift는 추상 구문 트리(AST, Abstract Syntax Tree)를 이용하여 코드를 수정하는 방법을 제공함으로써 코드 수정 작업을 정확하고 편리하게 할 수 있도록 도와줍니다.\n\n추상 구문 트리 (AST)\n추상 구문 트리는 프로그램의 소스 코드를 쉽게 다룰 수 있도록 도와주는 자료구조입니다.\n\n예를 들어서, 다음 import 문을 추상 구문 트리로 옮기면 이런 모습이 됩니다.\n\n\n\n살펴보면 import 문이 ImportDeclaration 객체로 바뀌었습니다. 또 내부에서 사용되는 Default Import와 Named Import, 라이브러리 이름이 알맞은 객체로 옮겨진 것을 확인할 수 있습니다.\n\nASTExplorer\n\n작성한 코드의 추상 구문 트리를 ASTExplorer로 쉽게 확인할 수 있습니다. 코드만 붙여넣으면 해당하는 구문 트리를 바로 확인할 수 있어 편리합니다. 소스 코드의 특정 부분에 커서를 옮기면 그 부분이 트리의 어떤 부분에 해당하는지 바로 볼 수 있기도 합니다. 😉 추상 구문 트리에 익숙하지 않다면, 사용해보시는 것을 권장합니다.\n\n라이브러리별 추상 구문 트리\n라이브러리마다 사용하는 추상 구문 트리의 모습은 다를 수 있습니다. 예를 들어서 같은 JavaScript를 다루더라도 ESLint가 사용하는 트리와 Babel이 사용하는 트리는 약간 다릅니다. JSCodeShift는 Babel이 사용하는 트리를 사용하고 있습니다.\n\n\nASTExplorer 상단 메뉴에서 사용할 추상 구문 트리를 선택할 수 있습니다. JSCodeShift가 사용하는 트리는 @babel/parser 입니다.\n\nJSCodeShift 사용하기\nJSCodeShift로 코드를 수정하는 과정은 크게 4가지 작업으로 나눌 수 있습니다.\n\nAST로 파싱: 파일의 소스 코드를 AST로 파싱합니다.\n수정할 노드 선택: AST에서 수정할 노드를 선택합니다.\n수정하기: 검색한 노드를 JSCodeShift가 제공하는 유틸리티로 코드를 변경시킵니다.\n소스 코드로 내보내기: 수정된 AST를 JavaScript 소스 코드로 내보냅니다.\n예를 들어, 이런 형식으로 코드를 작성합니다.\n\n\n이후 JSCodeShift CLI를 이용하여 jscodeshift -t transformSomeCode.js <target> 와 같은 명령을 실행하면 <target> 에 있는 소스 코드들이 transformSomeCode.js 에 정의된 규칙에 맞게 수정됩니다.\n\n이제 본격적으로 JSCodeShift에서 자주 사용되는 메서드들을 살펴보겠습니다.\n\n수정할 노드 선택하기: find()\n기본적으로 수정할 노드를 선택하기 위해 find() 함수를 사용합니다.\n\n예를 들어, react 라이브러리의 useMemo 를 가져오는 import 구문들을 선택하기 위해서는 아래와 같이 코드를 작성할 수 있습니다.\n\n\n노드 삭제하기: remove()\n선택한 노드를 삭제하기 위해 remove() 함수를 사용합니다.\n\n예를 들어서, 아래와 같이 코드를 작성함으로써 선택한 node 의 목록을 삭제할 수 있습니다.\n\n\n노드를 다른 노드로 치환하기: replaceWith()\n선택한 노드를 새로운 노드로 치환하려고 할 때 replaceWith() 함수를 사용할 수 있습니다.\n\n예를 들어서, 선택한 node 들을 다른 모습으로 치환하기 위해서는 아래와 같이 코드를 작성할 수 있습니다.\n\n\n새로운 노드 만들기\nreplaceWith() 와 같은 함수에서 사용하기 위해서 새로운 노드를 만들 때는 JSCodeShift에서 제공하는 도우미 함수들을 사용할 수 있습니다.\n\n각 노드를 만드는 방법을 모두 알 필요는 없습니다. TypeScript를 사용하는 경우, 각 함수가 어떤 인자를 받는지 바로 확인할 수 있습니다. JavaScript를 사용하는 경우, ast-types가 정의하는 타입 정보를 참고해주세요.\n변수 참조: foo와 같은 변수에 참조하는 노드를 만들기 위해서 jscodeshift.identifier() 를 사용할 수 있습니다.\n\n\n멤버 접근: 변수 foo의 멤버 bar 에 접근하는 노드를 만들기 위해서 jscodeshift.memberExpression() 을 사용할 수 있습니다.\n\n\nimport 문: import { useMemo } from 'react'; 와 같은 import 문을 만들기 위해서 jscodeshift.importDeclaration() 을 사용할 수 있습니다.\n\n\nJSCodeShift 사용 예시\n토스 프론트엔드 챕터에서는 2020년 import { Adaptive } from '@tossteam/web-development-kits' 와 같은 import 문을 모두 import { adaptive } from '@tossteam/colors' 으로 수정해야 하는 필요성이 있었습니다.\n\n이런 경우는 찾아 바꾸기로 해결하는 데에 어려움이 있었습니다. 코드를 수정하는 규칙이 복잡했기 때문입니다.\n\n@tossteam/web-development-kits 라이브러리로부터 Adaptive 뿐 아니라 다른 변수나 함수를 import 하는 경우가 있었습니다. 그런 경우에는 전체 import 문을 지우는 것이 아닌, Adaptive 를 가져오는 부분만 삭제해야 했습니다.\nAdaptive 를 import하는 부분이 삭제된 경우에만 import { adaptive } from '@tossteam/colors'; 와 같이 새로운 import 문을 파일의 가장 처음에 추가해주어야 했습니다. 아닌 경우, 사용하지 않은 변수로 인해 컴파일 시간에 오류가 발생했습니다.\nAdaptive 를 import하는 부분이 삭제된 경우에만 그 파일에서 사용되는 모든 Adaptive 변수를 adaptive 로 바꿔줘야 했습니다.\n다행히 토스팀에서는 간단히 이 문제를 JSCodeShift로 해결할 수 있었습니다. 저희가 설계한 JSCodeShift 변환 코드의 구조는 다음과 같습니다.\n\n\n이 중에서 removeImportMember 함수와 같은 경우, 아래와 같이 간단히 구현할 수 있었습니다.\n\n\n다른 함수의 경우에도 유사하게 JSCodeShift API를 이용하여 구현할 수 있었습니다.\n\nJSCodeShift 테스트하기\nJSCodeShift는 작성한 변환 코드가 잘 작동하는지 테스트할 수 있도록 testUtils 라고 하는 이름의 테스트 도구를 제공합니다. 테스트 파일의 디렉토리 구조를 JSCodeShift가 요구하는 대로 맞춰야 하지만, 손쉽게 Jest에 테스트를 붙일 수 있어서 편리합니다.\n\n테스트가 잘 붙어 있으면, JSCodeShift 코드의 문제점을 바로바로 찾을 수 있게 됩니다. 개발 속도도 절약되는 만큼, JSCodeShift를 개발할 때는 꼭 테스트와 함께 하는 것을 추천합니다.\n\nJSCodeShift 테스트와 관련된 자세한 내용은 JSCodeShift README에서 확인할 수 있습니다.\n\n토스팀과 JSCodeShift\n토스 프론트엔드 개발팀은 짧은 시간동안 빠르게 개발환경을 개선해오면서 대량의 레거시 코드를 최신 라이브러리와 코드 컨벤션에 맞추도록 수정해주어야 했습니다. 경우에 따라서는 작성된지 2년이 지난 오래된 코드가 수만 줄 이상 존재하기도 했습니다.\n\n이때 JSCodeShift를 사용함으로써 그런 코드도 한번에 최신 코드와 같이 일관성을 맞출 수 있었습니다. 이번 JSCodeShift 가이드가 레거시 시스템을 다루는 다른 프론트엔드 개발자 분들께 도움이 되었으면 합니다.\n\n","isDisplayingFeedback":true},{"id":21007,"updatedTime":"2023-04-12T17:25:55+09:00","createdTime":"2023-04-12T16:01:11+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"웹 서비스 캐시 똑똑하게 다루기","subtitle":"웹 성능을 위해 꼭 필요한 캐시, 제대로 설정하기 쉽지 않습니다. 토스 프론트엔드 챕터에서 올바르게 캐시를 설정하기 위한 노하우를 공유합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/04/techblog-02-webcash.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"웹 서비스 캐시 똑똑하게 다루기"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/04/techblog-02-webcash.png","backgroundColor":null,"isFill":false,"imageAlt":"웹 서비스 캐시 똑똑하게 다루기"},"key":"smart-web-service-cache","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2021-04-29T17:08:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21007,"title":null,"description":"토스 프론트엔드 챕터에서는 웹 성능을 최대한으로 높이기 위해 HTTP 캐시를 적극적으로 사용하고 있습니다. 캐시를 잘못 관리했을 때, 원하는 시점에 캐시가 사라지지 않을 수 있습니다. 필요 이상으로 HTTP 요청이 발생하기도 합니다.HTTP 캐시를 효율적으로 관리하려면 Cache-Con...","urlSlug":"smart-web-service-cache","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"웹 서비스 캐시 똑똑하게 다루기","description":"웹 성능을 위해 꼭 필요한 캐시, 제대로 설정하기 쉽지 않습니다. 토스 프론트엔드 챕터에서 올바르게 캐시를 설정하기 위한 노하우를 공유합니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/tech-blog/og-image:/techblog-02-webcash-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2329,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":556,"name":"박서진","slug":"sojin-park","shortDescription":"Frontend Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/sojin.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":6,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스 프론트엔드 챕터에서는 웹 성능을 최대한으로 높이기 위해 HTTP 캐시를 적극적으로 사용하고 있습니다. 캐시를 잘못 관리했을 때, 원하는 시점에 캐시가 사라지지 않을 수 있습니다. 필요 이상으로 HTTP 요청이 발생하기도 합니다.\n\nHTTP 캐시를 효율적으로 관리하려면 Cache-Control 헤더를 섬세하게 조절해야 합니다. 토스 프론트엔드 챕터에서 다양한 생명 주기를 가지는 캐시를 다루면서 알게 된 노하우를 테크 블로그로 공유합니다.\n\n캐시의 생명 주기\nHTTP에서 리소스(Resource)란 웹 브라우저가 HTTP 요청으로 가져올 수 있는 모든 종류의 파일을 말합니다. 대표적으로 HTML, CSS, JS, 이미지, 비디오 파일 등이 리소스에 해당합니다.\n\n웹 브라우저가 서버에서 지금까지 요청한 적이 없는 리소스를 가져오려고 할 때, 서버와 브라우저는 완전한 HTTP 요청/응답을 주고받습니다. HTTP 요청도 완전하고, 응답도 완전합니다. 이후 HTTP 응답에 포함된 Cache-Control 헤더에 따라 받은 리소스의 생명 주기가 결정됩니다.\n\n캐시의 유효 기간: max-age\n서버의 Cache-Control 헤더의 값으로 max-age=<seconds> 값을 지정하면, 이 리소스의 캐시가 유효한 시간은 <seconds> 초가 됩니다.\n\n캐시의 유효 기간이 지나기 전\n한 번 받아온 리소스의 유효 기간이 지나기 전이라면, 브라우저는 서버에 요청을 보내지 않고 디스크 또는 메모리에서만 캐시를 읽어와 계속 사용합니다.\n\n\n메모리 캐시에서 불러온 HTTP 리소스\n\n예를 들어, 위 개발자 도구 캡처와 같이 어떤 JavaScript 파일을 요청하는 경우를 가정합시다. 이 리소스가 가지는 Cache-Control 헤더 값은 max-age=31536000 이기 때문에, 이 리소스는 1년(31,536,000초)동안 캐시할 수 있습니다.\n\n스크린샷에서는 유효한 캐시가 메모리에 남아 있기 때문에 (from memory cache) 라고 표기된 것을 확인할 수 있습니다.\n\n“서버에 요청을 보내지 않고” 라고 하는 말에 주의합시다. 한번 브라우저에 캐시가 저장되면 만료될 때까지 캐시는 계속 브라우저에 남아 있게 됩니다. 때문에 CDN Invalidation을 포함한 서버의 어떤 작업이 있어도 브라우저의 유효한 캐시를 지우기는 어렵습니다.\n\nNote: Cache-Control max-age 값 대신 Expires 헤더로 캐시 만료 시간을 정확히 지정할 수도 있습니다.\n캐시의 유효 기간이 지난 이후: 재검증\n그렇다면 캐시의 유효 기간이 지나면 캐시가 완전히 사라지게 될까요? 그렇지는 않습니다. 대신 브라우저는 서버에 조건부 요청(Conditional request)을 통해 캐시가 유효한지 재검증(Revalidation)을 수행합니다.\n\n\n재검증 결과 브라우저가 가지고 있는 캐시가 유효하다면, 서버는 [304 Not Modified] 요청을 내려줍니다. [304 Not Modified] 응답은 HTTP 본문을 포함하지 않기 때문에 매우 빠르게 내려받을 수 있습니다. 예를 들어, 위 스크린샷을 살펴보면 59.1KB 리소스의 캐시 검증을 위해 324바이트만의 네트워크 송수신만을 주고받았음을 볼 수 있습니다.\n\n\nIf-None-Match와 If-Modified-Since가 포함된 요청\n\n대표적인 재검증 요청 헤더들로는 아래와 같은 헤더가 있습니다.\n\nIf-None-Match: 캐시된 리소스의 ETag 값과 현재 서버 리소스의 ETag 값이 같은지 확인합니다.\nIf-Modified-Since: 캐시된 리소스의 Last-Modified 값 이후에 서버 리소스가 수정되었는지 확인합니다.\n위의 ETag 와 Last-Modified 값은 기존에 받았던 리소스의 응답 헤더에 있는 값을 사용합니다.\n\n재검증 결과 캐시가 유효하지 않으면, 서버는 [200 OK] 또는 적합한 상태 코드를 본문과 함께 내려줍니다. 추가로 HTTP 요청을 보낼 필요 없이 바로 최신 값을 내려받을 수 있기 때문에 매우 효율적이죠. 😉\n\nmax-age=0 주의보 정의대로라면 max-age=0 값이 Cache-Control 헤더로 설정되었을 때, 매번 리소스를 요청할 때마다 서버에 재검증 요청을 보내야 할 것입니다. 그렇지만 일부 모바일 브라우저의 경우 웹 브라우저를 껐다 켜기 전까지 리소스가 만료되지 않도록 하는 경우가 있습니다. 네트워크 요청을 아끼고 사용자에게 빠른 웹 경험을 제공하기 위해서라고 합니다.\n이 경우에는 웹 브라우저를 껐다 켜거나, 아래에서 소개할 no-store 값을 사용해주세요.\n\nno-cache와 no-store\nCache-Control에서 가장 헷갈리는 두 가지 값이 있다면 바로 no-cache 와 no-store 입니다. 이름은 비슷하지만 두 값의 동작은 매우 다릅니다.\n\nno-cache 값은 대부분의 브라우저에서 max-age=0 과 동일한 뜻을 가집니다. 즉, 캐시는 저장하지만 사용하려고 할 때마다 서버에 재검증 요청을 보내야 합니다.\n\nno-store 값은 캐시를 절대로 해서는 안 되는 리소스일 때 사용합니다. 캐시를 만들어서 저장조차 하지 말라는 가장 강력한 Cache-Control 값입니다. no-store를 사용하면 브라우저는 어떤 경우에도 캐시 저장소에 해당 리소스를 저장하지 않습니다.\n\n캐시의 위치\n\nCDN과 같은 중간 서버를 사용할 때, 캐시는 여러 곳에 생길 수 있습니다. 서버가 가지고 있는 원래 응답을 CDN이 캐시합니다. CDN의 캐시된 응답은 사용자 브라우저가 다시 가져와서 캐시합니다. 이처럼 HTTP 캐시는 여러 레이어에 저장될 수 있기 때문에 세심히 다루어야 합니다.\n\nCDN Invalidation\n일반적으로 캐시를 없애기 위해서 “CDN Invalidation”을 수행한다고 이야기합니다. CDN Invalidation은 위 다이어그램에서 가운데에 위치하는 CDN에 저장되어 있는 캐시를 삭제한다는 뜻입니다. 브라우저의 캐시는 다른 곳에 위치하기 때문에 CDN 캐시를 삭제한다고 해서 브라우저 캐시가 삭제되지는 않습니다.\n\n경우에 따라 중간 서버나 CDN이 여러 개 있는 경우도 발생하는데, 이 경우 전체 캐시를 날리려면 중간 서버 각각에 대해서 캐시를 삭제해야 합니다.\n\n이렇게 한번 저장된 캐시는 지우기 어렵기 때문에 Cache-Control의 max-age 값은 신중히 설정하여야 합니다.\n\nCache-Control: public과 private\nCDN과 같은 중간 서버가 특정 리소스를 캐시할 수 있는지 여부를 지정하기 위해 Cache-Control 헤더 값으로 public 또는 private을 추가할 수 있습니다.\n\npublic은 모든 사람과 중간 서버가 캐시를 저장할 수 있음을 나타내고, private은 가장 끝의 사용자 브라우저만 캐시를 저장할 수 있음을 나타냅니다.\n\n기존과 max-age 값과 조합하려면 Cache-Control: public, max-age=86400 과 같이 콤마로 연결할 수 있습니다.\n\ns-maxage\n중간 서버에서만 적용되는 max-age 값을 설정하기 위해 s-maxage 값을 사용할 수 있습니다.\n\n예를 들어, Cache-Control 값을 s-maxage=31536000, max-age=0 과 같이 설정하면 CDN에서는 1년동안 캐시되지만 브라우저에서는 매번 재검증 요청을 보내도록 설정할 수 있습니다.\n\n토스에서의 Cache-Control\n토스 프론트엔드 챕터는 리소스의 성격에 따라 세심히 Cache-Control 헤더 값을 조절하고 있습니다.\n\nHTML 파일\n일반적으로 https://service.toss.im/toss-card/introduction 과 같은 HTML 리소스는 새로 배포가 이루어질 때마다 값이 바뀔 수 있습니다. 때문에 브라우저는 항상 HTML 파일을 불러올 때 새로운 배포가 있는지 확인해야 합니다.\n\n\n이런 리소스에 대해 토스 프론트엔드 챕터는 Cache-Control 값으로 max-age=0, s-maxage=31536000 을 설정했습니다. 이로써 브라우저는 HTML 파일을 가져올 때마다 서버에 재검증 요청을 보내고, 그 사이에 배포가 있었다면 새로운 HTML 파일을 내려받습니다.\n\nCDN은 계속해서 HTML 파일에 대한 캐시를 가지고 있도록 했습니다. 대신 배포가 이루어질 때마다 CDN Invalidation을 발생시켜 CDN이 서버로부터 새로운 HTML 파일들을 받아오도록 설정했습니다.\n\nJS, CSS 파일\nJavaScript나 CSS 파일은 프론트엔드 웹 서비스를 빌드할 때마다 새로 생깁니다. 토스 프론트엔드 챕터는 임의의 버전 번호를 URL 앞부분에 붙여서 빌드 결과물마다 고유한 URL을 가지도록 설정하고 있습니다.\n\n\n고유 버전 번호가 붙어 있는 JavaScript 파일\n\n이렇게 JS, CSS 파일을 관리했을 때, 같은 URL에 대해 내용이 바뀔 수 있는 경우는 없습니다. 내용이 바뀔 여지가 없으므로 리소스의 캐시가 만료될 일도 없습니다.\n\n이런 리소스에 대해 토스 프론트엔드 챕터는 Cache-Control 값으로 max-age의 최대치인 max-age=31536000 을 설정하고 있습니다. 이로써 새로 배포가 일어나지 않는 한, 브라우저는 캐시에 저장된 JavaScript 파일을 계속 사용합니다.\n\n캐시 설정을 섬세히 제어함으로써 사용자는 더 빠르게 HTTP 리소스를 로드할 수 있고, 개발자는 트래픽 비용을 절감할 수 있습니다. 위에서 Cache-Control와 ETag 헤더를 리소스의 성격에 따라 잘 설정하는 것만으로 캐시를 정확하게 설정할 수 있다는 것을 살펴보았습니다. HTTP 캐시로 고민하고 있는 분들께 도움이 되었기를 기대합니다.","isDisplayingFeedback":true},{"id":21039,"updatedTime":"2023-04-14T12:23:18+09:00","createdTime":"2023-04-12T16:04:46+09:00","category":null,"categories":[{"name":"기술","id":351,"slug":"tech","parentId":null,"iconUrl":null},{"name":"프론트엔드","id":352,"slug":"frontend","parentId":null,"iconUrl":null}],"series":null,"title":"토스 프론트엔드 챕터를 소개합니다!","subtitle":"토스에서 프론트엔드 개발자가 일하는 방법과 맡고 있는 역할에 대해 소개드립니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/04/techblog-01-about-fechapter.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"토스 프론트엔드 챕터를 소개합니다!"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2021/04/techblog-01-about-fechapter.png","backgroundColor":null,"isFill":false,"imageAlt":"토스 프론트엔드 챕터를 소개합니다!"},"key":"toss-frontend-chapter","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2021-04-28T08:00:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21039,"title":null,"description":"안녕하세요. 토스 프론트엔드 챕터 블로그에 오신 것을 환영합니다. 앞으로 토스팀에서 프론트엔드 개발을 하면서 생기는 이야기들을 정리하여 블로그로 전해드리려고 합니다.https://static.toss.im/assets/toss-tech/toss-frontend-chapter-1.jpg토...","urlSlug":"toss-frontend-chapter","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"토스 프론트엔드 챕터를 소개합니다!","description":"토스에서 프론트엔드 개발자가 일하는 방법과 맡고 있는 역할에 대해 소개드립니다.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://og.toss.tech?title=%ED%86%A0%EC%8A%A4%20%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90%0D%0A%EC%98%A4%EC%8B%A0%20%EA%B2%83%EC%9D%84%20%ED%99%98%EC%98%81%ED%95%A9%EB%8B%88%EB%8B%A4%21&imageUrl=https%3A%2F%2Fstatic.toss.im%2Fassets%2Ftech-blog%2Fog-image%3A%2Ftechblog-01-about-fechapter-og.png&v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2328,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":556,"name":"박서진","slug":"sojin-park","shortDescription":"Frontend Developer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/sojin.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":6,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"안녕하세요. 토스 프론트엔드 챕터 블로그에 오신 것을 환영합니다. 앞으로 토스팀에서 프론트엔드 개발을 하면서 생기는 이야기들을 정리하여 블로그로 전해드리려고 합니다.\n\n\n토스 프론트엔드 챕터는?\n토스에서는 같은 일을 하는 사람들을 모아서 챕터라고 합니다. 프론트엔드 챕터는 JavaScript, HTML, CSS를 이용하여 웹 프론트엔드 제품을 만드는 직군을 가리키는 말입니다.\n\n토스의 프론트엔드 개발자들은 ‘사일로’라고 하는 목적 조직에서 각자 독립적으로 일하고 있습니다. 각각의 사일로는 토스에서 하나의 제품을 전담하며, 작은 스타트업처럼 독립적으로 일합니다. 예를 들어, 송금을 담당하는 사일로는 송금 사일로, 결제를 담당하는 사일로는 결제 사일로입니다.\n\n사일로는 기본적으로 프로덕트 오너, 디자이너, 서버 개발자, 프론트엔드 개발자, 데이터 분석가 1명씩으로 구성됩니다. 사일로에서 프론트엔드 개발자는 다른 직군의 동료들과 가까운 자리에서 밀접하게 협업하면서, 주어진 반기별 OKR(목표)를 달성하기 위해 꾸준히 제품 개선에 참여하고 있습니다.\n\n→ 토스의 첫인상을 책임지는 사람들, 프론트엔드 개발자를 만나다\n\n함께 협업하기\n각 사일로에서 독립적으로 일하는 프론트엔드 개발자들이지만, 하나의 팀처럼 같이 협업하고 있습니다. 예를 들어서,\n\n함께 라이브러리를 개발하고 있습니다. UI 컴포넌트, 비동기 처리와 같이 프론트엔드 개발을 하면서 꼭 필요한 것들이 모두 라이브러리화되어 있습니다. 서비스를 개발하다가 적절히 추상화된 코드 조각이 생기면 라이브러리에 꾸준히 반영하고 있습니다.\n서로 코드를 리뷰합니다. 라이브러리 개발과 서비스 개발 모두에서 코드 리뷰가 의무화되어 있습니다. 코드 리뷰를 주고받으면서 더 나은 설계에 대해 토론하고, 새로운 기술 채택에 대해 의견을 나누고 있습니다.\n챕터 위클리에 참여합니다. 주기적으로 모든 프론트엔드 개발자들이 모여서 그동안 있었던 개발 업무를 주제로 이야기합니다. 챕터 위클리에서는 돌아가면서 “Tech Talk” 라고 하는 작은 발표를 열고 있는데, 개발 노하우나 새로운 기술 토픽을 소개합니다.\n그 이외에도 비정기적으로 기술 스터디를 열기도 합니다. 서로 자리가 떨어져 있어도 슬랙 채널이나 각자의 자리에서 활발하게 소통합니다.\n\n프론트엔드 챕터가 사용하는 기술\nReact, TypeScript, Next.js가 토스 프론트엔드 챕터가 다루는 기술의 핵심을 이루고 있습니다.\n\nReact: 토스 웹 페이지는 대부분 React로 구성되어 있습니다. 제품의 성격에 따라 React Suspense와 같은 실험적인 기술을 적극적으로 도입하고는 합니다.\nTypeScript: 토스에서는 모든 코드를 TypeScript로 작성합니다. 사람의 실수를 줄이고, 빌드 시간에 미리 오류를 찾아냄으로써 웹 서비스를 안정적으로 운영하는 데에 큰 도움이 되고 있습니다.\nNext.js: 토스 사용자들에게 더 빠른 웹을 보여주기 위해 적극적으로 SSR와 Static Export를 활용하고 있습니다.\n그 이외에 아래 기술을 보조적으로 사용하고 있어요.\n\nYarn Berry: 토스에서 의존성을 관리하기 위해 사용하는 패키지 매니저입니다. NPM보다 엄격히 package.json을 관리함으로써 개발자의 실수를 더 빨리 발견할 수 있도록 해 줍니다. NPM보다 모듈을 로드하는 속도가 빠릅니다. (홈페이지)\nEmotion: CSS를 다루기 위해 emotion 라이브러리를 사용하고 있습니다. CSS Prop으로 생산적으로 스타일을 다룰 수 있습니다. 서버 사이드 렌더링을 했을 때 첫 렌더에 포함되는 Critical CSS만을 HTML에 포함해줌으로써 더 빠르게 화면을 보여줄 수 있도록 도와주기도 합니다.\nReact Query, SWR: 비동기를 다루는 상황에서 대부분 사용하고 있는 라이브러리입니다. 선언적으로 비동기 자원을 관리하고 캐싱할 수 있습니다.\nTech Talks\n토스에서는 모든 프론트엔드 챕터 구성원이 모이는 챕터 위클리에서 Tech Talk라고 하는 작은 발표를 열고 있습니다. 발표의 주제는 서비스 개발을 할 때의 꿀팁부터 React Suspense 소개까지 다양합니다. 2019년부터 지금까지 총 90개 이상의 크고 작은 발표가 있었습니다.\n\n토스 FE 블로그의 아티클은 위클리에서 있었던 Tech Talk의 내용을 간단히 정리한 것입니다.\n\n기술 블로그에서 공개된 내용보다 더 좋은 발표를 듣고 싶다면, 그리고 저희와 함께 웹 서비스의 문제를 풀어가고 싶다면, 언제든 토스팀에 지원해주세요. 모든 단계에서 최대한 빠르고 솔직하게 피드백을 드리겠습니다.","isDisplayingFeedback":true},{"id":23009,"updatedTime":"2023-11-27T19:55:52+09:00","createdTime":"2023-10-25T14:40:51+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"독이 되는 레퍼런스 활용법","subtitle":"매혹적이지만 독이 될 수 있는 레퍼런스. 어떻게 활용하는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-15-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"독이 든 병"},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-15-og.png","backgroundColor":null,"isFill":true,"imageAlt":"독이 든 병"},"key":"23009","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-11-27T19:00:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":23009,"title":null,"description":"토스에서 킥보드도 빌릴 수 있다는 사실, 알고 계시나요? \n\n킥보드 서비스를 디자인하게 된 제가 제일 먼저 한 일은 무작정 다른 앱을 다운받는 거였어요. 킥보드 앱은 차고 넘쳤고, 10개 정도를 보다 보니 다 비슷하게 생겼더라고요. 그래서 별 의심 없이 화면을 토스답게 바꾸기만 하고 있...","urlSlug":"23009","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"독이 되는 레퍼런스 활용법","description":"매혹적이지만 독이 될 수 있는 레퍼런스. 어떻게 활용하는 것이 좋을까요?","backgroundColor":"#424242","imageAlt":"독이 든 병","imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-15.png","imageType":"직접입력"},"relatedPostConfig":null,"editor":{"id":1273,"name":"장세린","slug":"serin-jang","shortDescription":null,"description":"Product Designer","imageUrl":"https://static.toss.im/assets/toss-tech/serin-jang.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스에서 킥보드도 빌릴 수 있다는 사실, 알고 계시나요? \n\n킥보드 서비스를 디자인하게 된 제가 제일 먼저 한 일은 무작정 다른 앱을 다운받는 거였어요. 킥보드 앱은 차고 넘쳤고, 10개 정도를 보다 보니 다 비슷하게 생겼더라고요. 그래서 별 의심 없이 화면을 토스답게 바꾸기만 하고 있었죠. \n\n‘나 뭐 하고 있는 거지?’ 하는 생각이 들 때쯤 토스의 코어 밸류인 ‘Question Every Assumption’이 뇌리에 스쳤어요. \n\nQuestion Every Assumption \n모든 당연해 보이는 것들에 질문을 던져라\n익숙함에서 벗어나 최상의 경험을 제공하자는 취지\n\n\n돌이켜보니 저는 당연한 것들에 의문을 가지지 않은 채 관습적으로 디자인하고 있더라고요. 그때부터 정신 차리고 모든 기능, 모든 요소에 질문을 던지기 시작했어요.\n\n\n\n\n문제\n킥보드를 빌리기 위해 가장 먼저 마주하는 화면은 지도 화면이에요. 무려 10가지 킥보드 앱을 모아보니, 지도 화면에 기능이 7개 정도 있더라고요.\n\n\n다른 서비스가 제공하는 기능들을 바탕으로 재구성한 화면이에요\n7~8개의 버튼이 흩어져 있고 핀도 빽빽하게 차 있어 화면을 알아보기 어려웠어요. 가장 중요한 정보를 전달하는 지도는 전체 면적의 64%밖에 쓸 수 없었죠.\n\n\n아이콘도 서비스마다 달랐고,\n\n\n\n요소가 너무 많아 정작 중요한 배터리 정보는 잘 보이지도 않았어요.\n\n\n\n\n가설\n처음에는 필요한 기능이니까 있는 거 아닐까? 필요한 건 아니라도 있는 게 낫지 않을까? 하는 생각에 갇혀있었어요. 하지만 10명의 사용자를 만나며 그게 아니라는 걸 깨달았죠.\n\n교통 서비스의 목적은 빠른 이동인데, 부가 기능을 제공하는 건 오히려 목적에 방해가 될 뿐이겠다 싶었어요. \n\n\n해결\n1. 불필요한 기능 빼버리기\n그래서 기능별로 사용하는 사람이 얼마나 되는지부터 파악했어요. 직접 타보기도 하고 인터뷰도 다시 했어요. 그 결과, 부가 기능이 필요한 상황이 매우 적다는 걸 검증할 수 있었고, 대여하기를 뺀 모든 기능을 과감하게 빼버릴 수 있었어요.\n\n\n2. 필요한 상황에 제공하기\n하지만 뺄 수 없는 기능들도 있었어요. 운전 면허 인증이나 고객센터 문의 같은 기능들이었죠. 생각해 보니 그 기능들이 꼭 지도 화면에서 필요한 건 아니더라고요. 오히려 더 자주 찾는 상황이 있었고, 그 상황에서 제공해 주는 게 낫겠다는 생각이 들었어요. \n\n\n그래서 운전 면허 인증은 대여 직전으로 옮기고\n\n\n문의는 반납이 제대로 되지 않았을 때와 반납 후에 이어질 수 있도록 했어요.\n\n\n3. 가장 중요한 정보 강조하기\n이렇게 하나 둘씩 정리하니 가장 중요한 배터리 정보가 잘 안 보인다는 문제가 확실히 느껴졌어요. 그래서 핀 모양도 업체와 배터리가 잘 보이게끔 수정했어요.\n\n\n\n결과\n덕분에 가장 중요한 ‘대여하기’라는 액션을 강조할 수 있었고, 레퍼런스보다 지도를 39% 더 사용할 수 있었어요. \n\n\n\n\nCase 2. 정보 화면에 질문 던지기\n문제\n지도 화면에서 핀을 클릭하면 킥보드 정보를 볼 수 있어요. 여러 서비스를 비교해 보니 평균 10개의 정보를 제공하고 있더라고요.\n\n\n다른 서비스가 제공하는 기능들을 바탕으로 재구성한 화면이에요\n좁은 공간에 모든 정보를 넣으려다 보니 어떤 게 기능이고 정보인지 파악이 어려웠고, 지도는 30% 밖에 보이지 않았어요.\n\n\n\n심지어 정보를 줄이기 위해 설명 없이 아이콘만 있는 기능들도 많더라고요\n\n\n어떤 기능인지 한 번에 이해가 되나요?\n\n가설\n저는 이번에도 모든 것에 질문을 던졌어요. 꼭 필요한 걸까? 가장 중요한 건 뭘까?\n\n킥보드 정보에서 가장 중요한 건 ‘내가 가려는 거리를 갈 수 있을지’ 라고 생각했어요. 가격이나 기기 이름은 그다음 문제라고 생각했죠.\n\n\n해결\n이번에는 킥보드를 빌리는 상황을 가정해서 인터뷰를 진행했어요. \n\n리얼하게 인터뷰를 진행하며 알게 된 사실\n대부분의 사용자는 킥보드 정보를 확인하지 않았어요.\n정보를 확인하는 사람들도 ‘10분 거리를 가려고 하는데 그동안 탈 수 있을까?’만 확인했어요.\n\n1. 가장 중요한 정보 강조하기\n모든 앱에서 기기 코드를 가장 강조해서 보여주고 있었어요. 배터리 아이콘과 퍼센트, 몇 km 이동 가능한지는 코드 아래 작게 보여주고 있었죠.\n\n\n공급자에게 이건 당연한 논리이자 친절한 배려였을 거예요. 기기 이름을 제목으로, 하위 정보인 배터리는 작게 표시하는 게 맞았을 거고, 배터리 관련 정보를 몽땅 주는 게 배려였을 거에요.\n\n\n하지만 사용자에게는 불편함이었어요. 사용자가 궁금한 건 원하는 시간 동안 탈 수 있을지 뿐이었거든요. 그래서 모든 정보를 날리고 몇 분 달릴 수 있는지를 가장 크게, 위에 넣었어요.\n\n\n\n2. 필요한 상황에 제공하기\n어떤 기능인지 알기 어려운 벨 울리기 기능은 ‘소리로 찾기’라는 직관적인 이름으로 바꿨어요. 이 기능은 킥보드와 사용자가 가까울 때만 쓸 수 있는 기능이라, 가까워졌을 때만 보여주기로 했어요.\n\n\n\n기기 코드 복사 기능은 코드를 입력해서 킥보드를 빌릴 때만 필요한 기능이었어요. 그래서 복사할 필요가 없도록, 코드 입력하는 칸을 미리 채워주었죠.\n\n\n\n3. 불필요한 기능 빼버리기\n사용하는 사람이 많지 않은 고장 신고, 여기 없어요 기능은 빼버렸어요. \n\n\n결과\n\n불필요한 정보와 뒤바뀐 위계로 정신없던 화면을 정리하니, 이동 가능 시간이 한 눈에 보였어요. 레퍼런스보다 지도도 46%나 더 볼 수 있었죠. 개선한 화면이 불편할지 싶어 UT를 했는데, 어떤 기능이 없어졌는지 아는 사용자는 없었어요.\n\n\n적용해보기\n기능은 편의가 아니라 비용이다\n다양한 기능을 제공해 주면 좋을 것 같지만, 오히려 사용자에게 방해가 되고 유지 보수 비용이 들어요. 정보도 마찬가지예요. 정보가 많을수록 친절한 것 같지만, 사용자는 이해하기 위해 더 힘을 들여야 하죠. 결국 누구에게도 도움이 되지 않는 거예요.\n\n\n디자이너의 일은 사용자가 목적지에 쉽게 다다를 수 있도록 길을 닦아주는 것이라고 생각해요. 아래 4가지 단계로 ‘Question Every Assumption’ 해보면 사용자에게 목적지로의 지름길을 만들어 줄 수 있을 거예요.\n\nQuestion Every Assupmtion으로 디자인하기\n모든 요소와 스펙에 꼭 필요한지 질문하기, 모르겠다면 유저 만나보기\n화면에 갇히지 말고 화면을 보는 사용자의 상황 상상하기 \n매 순간 가장 중요한 건 뭘지 질문하기\n개선한 화면 꼭 검증하기\n\n\n킥보드 서비스가 궁금하다면?\n전체탭의 교통칸을 확인해주세요!","isDisplayingFeedback":true},{"id":23487,"updatedTime":"2023-11-23T18:30:59+09:00","createdTime":"2023-11-16T13:45:44+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"효율적인 유저 리서치 환경을 만드는 리서치 플랫폼 팀, 들어보셨나요?","subtitle":"토스팀에서 팀원들이 사용자를 더 쉽고, 빠르고, 편하게 만날 수 있도록 고군분투하고 있는 ‘리서치 플랫폼 팀’에 대해 소개해 보려고 해요. ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/illusts/tech-research-platform-og-image.png","videoUrl":null,"backgroundColor":null,"isFill":true,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/illusts/tech-research-platform-og-image.png","backgroundColor":null,"isFill":true,"imageAlt":null},"key":"ux-research-platform","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-11-23T15:14:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":23487,"title":null,"description":"토스팀에서 팀원들이 사용자를 더 쉽고, 빠르고, 편하게 만날 수 있도록 고군분투하고 있는 ‘리서치 플랫폼 팀’에 대해 소개해 보려고 해요.","urlSlug":"ux-research-platform","primaryKeyword":{"id":13989,"content":"리서치 플랫폼 팀","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":13971,"content":"ux리서치","wordType":"SEO_KEYWORD"},{"id":13977,"content":"유저리서치","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"효율적인 유저 리서치 환경을 만드는 리서치 플랫폼팀, 들어보셨나요?","description":"토스팀에서 팀원들이 사용자를 더 쉽고, 빠르고, 편하게 만날 수 있도록 고군분투하고 있는 ‘리서치 플랫폼 팀’에 대해 소개해 보려고 해요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/illusts/tech-research-platform-og-image.png","imageType":"썸네일 이미지"},"relatedPostConfig":null,"editor":{"id":1889,"name":"최정은","slug":"jeongeun-choe","shortDescription":"UX Research Operation Manager","description":"-","imageUrl":"https://static.toss.im/assets/toss-tech/IMG_0932.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"지난 심플리시티23에서 많은 분이 UX리서치, 특히 “사용자를 어떻게 만나는지”에 대해 궁금해하셨더라고요. \n\n💬 Simplicity23 '무엇이든 물어보세요' >\n\n토스팀에서 팀원들이 사용자를 더 쉽고, 빠르고, 편하게 만날 수 있도록 고군분투하고 있는 ‘리서치 플랫폼 팀’에 대해 소개해 보려고 해요. \n\n\nQ. 리서치 플랫폼 팀은 어떤 일을 하나요?\n효율적인 리서치 환경을 구축하는 일을 하고 있어요.\nUX리서처뿐만 아니라 토스에서 제품을 만드는 모든 팀원들이 리서치를 보다 효율적으로 수행할 수 있도록 프로세스를 구축하고, 필요한 리서치 교육이나 프로그램, 리서치 도구 개발 등을 맡고 있어요.  UX리서처 1명, 리서치 오퍼레이터 3명, 그리고 여러 명의 어시스턴트 분들로 구성된 팀이에요.\n\n\n팀 빌딩 당시 작성했던 목표 일부\n\nQ. 리서치 오퍼레이터는 어떤 역할인가요?\n‘리서치 오퍼레이팅 업무’라고 하면 리서치 과정을 단순 운영하는 직군이라고 생각하기 쉬워요. 리서처 대신 리크루팅부터 인터뷰 운영, 사례비 지급에 이르는 반복 업무를 수행함으로써 리서처 업무의 효율을 높여주는 역할이라고 생각하는 거죠. \n\n하지만 토스의 리서치 플랫폼 팀은 이런 비효율 영역의 본질적인 문제를 찾고 해결함으로써 효율적인 리서치 환경을 구축하는 팀이라는 점에서 기존 인식과는 큰 차이가 있다고 봐요. \n\n물론 처음에는 흔히 생각하는 목적으로 유저 리서치 팀에 오퍼레이션을 전담해 주실 분들을 모시고 있었어요. 하지만 팀이 커지고 리서치 수요가 급증하다 보니 오퍼레이션 영역에도 보다 더 효율적인 프로세스나 리서치 도구들이 필요했고, 그렇게 유저 리서치 팀과 분리된 ‘리서치 플랫폼 팀’이 만들어지게 됐어요. \n\n\nQ. 리서치 플랫폼 팀의 필요성에 대해 어떻게 생각하시나요?\nUX리서치 팀에 비해 ‘리서치 플랫폼 팀’은 생소한 것 같아요. 팀 리더이자 UX리서처 개인으로서, 승희님의 생각이 궁금해요.\n\nUX리서치를 하면 할수록 제품이 사용자와 가까워지는데, 사실 모든 조직이 그 조직 규모에서 필요로 하는 만큼의 리서치를 수행할 리서처를 다 뽑을 수는 없거든요. 그렇기 때문에 한정적인 리소스 내에서 더 많은 리서치를 효율적으로 하기 위해선 인프라 구축이 필수적이에요.\n\n특히 저는 UX리서처의 업무 효율화도 중요하지만, 제품을 만드는 팀원분들이 사용자 의견을 직접 들을 수 있는 환경이 잘 조성돼 있을수록 사용자와 더 잘 맞는 제품을 만들 수 있다고 생각해요. 애자일한 조직일수록 더욱 그 필요성와 효용은 크고요. 그래서 팀원들이 사용자를 직접, 자주, 쉽게, 편하게 만날 수 있도록 하는 리서치 환경이 되게 중요하고, 이 기반이 되는 조직 내 리서치 문화 형성이나 리서치 교육 등이 중요해질 수밖에 없죠. \n\n4-5년 전만 해도 ‘UX리서치 팀’을 꾸리고 있는 조직이 몇 안 됐어요. 이름만 들어도 다 아는 IT회사들조차도요. 하지만 지금은 많이 다르죠. 시장이 UX리서치의 효용과 가치를 느낄수록 이 기반을 만드는 리서치 플랫폼 팀에 대한 필요성은 커질 수밖에 없다고 확신하기에, 머지않아 여러 조직에서 저희와 같은 팀을 만나볼 수 있지 않을까 싶어요.\n\n\nQ. 토스 리서치 플랫폼 팀의 특별한 점은 무엇인가요?\n리서치 프로세스 또한 하나의 제품을 만든다는 관점으로 개선한다는 점이에요. \n가설을 기반으로 크고 작은 MVP 실험을 돌리고, 사용자의 의견을 토대로 이터레이션을 거쳐가며 리서치 각 단계들을 고도화시켜가고 있어요. 아래 두 가지 사례로 좀 더 설명해 볼게요.\n\n\nCase1. 논스톱 리쿠르팅 파이프라인\n최대 90분이 걸리던 리크루팅을 최소 15분 만에 끝낼 수 있는 프로세스 구축하기\n\n기존에 리크루팅을 한다고 하면 대상자를 선정해 푸시 발송 후, 문자 전화 카톡 3개의 커뮤니케이션 채널을 거쳐 인터뷰 일정을 확정했어요. 각 채널 별로 세팅이 필요한 업무가 달라서 커뮤니케이션에 들이는 리소스가 많았고 사용자의 응답을 기다리는 시간도 꽤 많이 소요됐죠. \n\n그 과정에서 반복적으로 수행하는 업무들은 템플릿을 만들고 자동화를 시키기도 했지만 지난한 건 마찬가지였어요.\n\n전체 프로세스를 뜯어보면서 가장 효율화 작업이 필요한 단계를 찾아 비효율이 발생하는 문제에 집중했어요. 그러다 보니 인터뷰 의사가 있는 사용자와 인터뷰 동의서를 작성하고 일정 조율하는 과정에서 커뮤니케이션 비용이 크게 발생하는 것을 해결해야 할 문제로 좁힐 수 있었어요.\n\n이를 가설로 MVP 실험을 돌렸고, 한 번의 스크리닝 설문 발송 만으로 일정 조율까지 논스톱으로 인터뷰 확정이 가능한 ‘논스톱 프로세스’를 구축할 수 있었어요. \n\n이 과정에서 주요 문제 해결 수단이 되었던 ‘타 사 일정 조율 플랫폼’을 단순히 도입하는 데서 그치지 않고, 하나의 제품을 만든다는 관점으로 세부 프로세스를 다듬어 갔어요. \n\n\n사용자가 토스앱에서 인터뷰를 신청하는 과정\n퍼널 별 이탈률을 확인하면서 가설을 검증하고 여러 가지 실험들을 진행했는데, 동일한 리크루팅 케이스를 가지고 A/B 테스트를 특히 많이 진행했어요.\n\n유독 이탈률이 높았던 마지막 랜딩 페이지에 대해서는 UX라이팅 팀의 의견도 받아서 문구 하나에도 신경을 많이 썼어요. 작은 부분이라도 사용자 입장에서 허들이라고 느낄 수 있는 부분을 개선하고자 노력했던 것 같아요.\n\n\n결과적으로 최대 90분이 걸리던 리크루팅을 최소 15분 만에 끝낼 수 있는 프로세스를 구축할 수 있었어요. 전사적으로는 리크루팅 프로세스를 효율화시키면서 필요한 리서치가 더 빠르게 진행될 수 있게 된 거죠.\n\n\nCase2. 유저무물데이\n제품을 만드는 팀원이 원할 때, 언제든 사용자를 만나 UT할 수 있게 하기\n\n토스팀 PD분들이 ‘무물 하러 간다’는 얘기를 자주 하시곤 하는데요, 앞서 설명한 ‘논스톱 리크루팅 파이프라인’이 저희 팀 입장에서의 효율화라면, 리플 팀에서 운영하는 ‘유저무물데이’는 제품을 만드는 팀원 입장에서 효율화를 이룬 프로그램이에요. \n\n*유저무물데이란?  랜덤한 토스 사용자를 대상으로, 비대면 UT를 할 수 있는 프로그램\n\n\n디자이너 분들의 유저무물데이 후기\n‘유저무물데이’는 팀원 분들이 사용자를 가볍고 쉽게 만나게 해 주자는 취지에서 만들어졌는데,  PD가 직접 당장 내일이라도 사용자들을 만나 UT 할 수 있는 프로그램의 가치를 주고 있어요. \n\n제품 시안이 어느 정도 완성된 다음에 각 잡고 하는 프로토타입 UT나, 제품 출시 후 사용성을 검증하는 것도 중요하지만 아주 러프한 단계에서부터 조금씩 자주 반복하면서 시안을 발전시켜 나가는 게 훨씬 효율적이고 유용하기도 해요. 초반부터 사용자 눈높이에 맞춰 가면서 제품을 고도화시켜 나갈 수 있는 거죠! \n\n\n시간 단위로 상시 신청 가능한 유저무물데이 신청폼\n그래서 지금은 30분, 15분 단위로 세션이 점점 더 작은 단위로 쪼개서 진행되고 있어요. 페이지 하나, 버튼 하나의 사용성은 짧은 시간 내로도 검증이 가능하거든요. 보다 사용자에게 빠르게 물어보고 개선할 수 있는 환경을 만들기 위해 지금도 열심히 고민하고 있답니다.\n\n\nQ. 그 과정에서 실패한 경험은 없으셨을까요?\n다양한 시도를 하고 있는 만큼 실패도 피할 수 없었을 것 같아요.\n\n유저무물데이만 해도 정말 많았죠. 예를 들어 정해진 시간 동안 사용자가 상주해 있고, 그 동안 팀원 분들이 궁금한 점이 생기면 즉석으로 사용자를 만나 대화할 수 있는 한 끗 다른 버전의 유저무물데이를 만든 적이 있었어요. 이외에도 랜덤 사용자가 아닌 리크루팅이 부득이하게 꼭 필요한 세그먼트의 사용자를 무물데이에서도 만나볼 수 있게 테스트한다든지 다양한 시도를 하고 있어요. \n\n제품을 만들 때도 MVP라는 작은 단위의 프로그램을 만들어 끊임없이 테스트하잖아요. 실패하더라도 빠르게 시도해 보고 레슨런을 만들어서 또다시 시도해 보는 게 저희의 일하는 방식인 것 같아요.\n\n\nQ. 기억에 남는 레슨런을 소개해 주신다면요?\n사용자로부터 당연하게 생각하는 부분들이 사실은 그렇지 않을 때가 많다는 점이에요.\n유저무물데이를 이용하는 팀원이 증가하면서 기존의 운영, 신청 방식을 효율적으로 개선해야 하는 타이밍이 왔다는 생각이 들었고, 팀원 분들을 대상으로 유저무물데이에 관한 설문조사를 받았어요. 설문을 받기 전, 저희는 기존 무물데이의 ‘신청 방식’이 가장 문제라고 예상했는데 아주 의외의 결과가 나왔어요. 저희의 예상과 다르게 신청 방식에 대한 만족도는 8점 이상으로 매우 높은 수준이었던 거죠.\n\n그보다는, 하루에 진행되는 세션 수를 늘려 달라는 의견이 절반 이상이었어요. 세션의 수가 한정되어 있다 보니 원하는 날짜에 예약이 다 차버리면 당장 신청한 시간이 거의 일주일 뒤에나 있다는 거예요. “오늘 신청하면 내일 당장 UT를 할 수 있다”라는 유저무물데이의 가치가 세션 수 부족으로 전혀 작동하지 않고 있었던 거죠. 팀원 모두 헉! 했던 순간이었어요.\n\n이 문제를 해결하기 위해 세션 수를 늘리고, 1시간의 최대 4명의 팀원이 각각 4명의 사용자와 로테이션으로 인터뷰할 수 있는 효율적인 프로세스를 만들어내기도 했답니다.  \n\n\nQ. 토스 팀을 대상으로 리서치를 진행한 거네요? \n사용자 의견을 중요하게 생각하시는 게 이런 부분에서도 잘 드러나는 것 같아요.\n\n리서치 도구로 유저무물데이를 사용한다는 점에서 팀원 분들은 또 다른 사용자이거든요. 유저 리서치를 베이스로 하는 팀이다 보니 늘 타깃 사용자 관점에서 생각해요. \n\n앞서 저희 팀이 리서치 프로세스를 ‘제품을 만드는 관점’에서 개선한다고 말씀드렸는데요. 제품 개선에 사용자 의견을 적극 반영하듯, 유저무물데이라는 제품에도 사용자인 팀원분들의 목소리를 녹인 거예요.\n\nUX리서치를 할 때처럼 설문조사를 하기도 하고, 유저무물데이를 많이 사용하는 분, 사용하다가 더 이상 사용하지 않는 분들을 대상으로 인터뷰를 진행하기도 하는 등 다양한 방식으로 의견을 수집하고 있어요.\n\n\nQ. 제품을 만드는 팀원 분들 외에도 리서치 플랫폼 팀의 사용자가 있나요?\n이야기를 듣다 보니 리서치 플랫폼 팀이 고려해야 하는 사용자가 많은 것 같아요.\n\n맞아요. 리서치를 위해 리크루팅을 요청한 팀원, 리크루팅 한 토스 사용자, 중간 과정에 있는 리서처까지. 고려해야 하는 사용자가 세 그룹이죠.\n\n각 업무들마다 어떤 그룹을 중심에 둘지 타겟팅에 있어 우선순위를 고민하며 균형을 잡는 게 중요해요. 그래서 팀원들끼리 더더욱 우리가 지금 타깃 사용자에 집중하고 있는지 서로 환기하며 일을 해나가고 있어요.\n\n\nQ. 토스 리서치 플랫폼 팀의 다음 목표는 무엇인가요?\n리서치 플랫폼 팀이 만들어 나갈 토스 UX리서치의 미래를 상상하며 일하고 있어요.\n그동안은 리서치와 연관된 모든 이해관계자들을 고려해 최적의 리서치 프로세스를 구축하는 일을 중점적으로 해왔어요. 효율적인 리서치 운영의 초석이 어느 정도 다져진 만큼, 이제는 토스핏한 리서치 교육과 문화를 안착시키는 일과 다양한 리서치 도구들을 개발하는 일에 집중하려고 해요. \n\n\n파일럿으로 진행했던 오픈무물데이 현장 사진\n사무실에 시니어 사용자를 모셔서 팀원 누구나 오가며 사용자의 생생한 의견을 듣도록 시도한 ‘오픈무물데이’ 파일럿 프로그램이나, 정량화된 데이터가 중요한 UT를 모더레이터 공수 없이 효율적으로 수행하게 끔 돕는 ‘무인 UT’ 툴 개발 등이 그 일환이라고 보면 좋을 것 같아요. \n\n올해 여름, 팀 워크숍을 했었는데요. 크게 리서치 전, 중, 후 과정 중에서 그동안 집중한 건 고작 리서치 중간 단계 정도더라고요. (리서치 하고 싶다고 찾아온 시점부터 해당 리서치 프로젝트가 끝나는 시점까지) 아직 갈 길이 멀어서, 내년엔 어떤 영역을 어떤 실험들로 발전시키고 있을지 기대가 돼요. \n\n\n이 콘텐츠는 ✏\n토스 리서치 플랫폼 팀 리더 도승희님, 리서치 오퍼레이터 최정은님, 서소희님, 리쿠르팅 코디네이터 유승민님과 어시스턴트 허인경님의 Q&A 형식으로 작성되었습니다.","isDisplayingFeedback":true},{"id":22690,"updatedTime":"2023-09-14T16:07:48+09:00","createdTime":"2023-09-12T12:10:44+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"완성 없는 이야기, 가입 과정 개선","subtitle":"가입 완료율을 높이기 위해 고민하고 시도했던 것들을 이야기 해요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/simplicity23/graphics/sim23-signup-cover.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/simplicity23/graphics/sim23-signup-cover.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"signup","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":false,"workspaceId":15,"isPublished":true,"publishedTime":"2023-09-12T22:44:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22690,"title":null,"description":"제품 성장 과정에 따라 적절한 UX가 다를 수 있다는 사실, 알고 계셨나요? 토스의 가입 과정은 테크 블로그에 첫 번째로 소개되었을 만큼 잘 만들었다고 자부하고 있었는데, 데이터를 확인해 보니 가입 완료율이 생각보다 낮았어요.토스가 성장하면서 가입하는 주요 연령대가 바뀌었기 때문이에요....","urlSlug":"signup","primaryKeyword":{"id":11715,"content":"토스심플리시티","wordType":"SEO_KEYWORD"},"relatedKeywords":[],"tags":[{"id":5408,"content":"토스디자인","wordType":"TAG"},{"id":12644,"content":"토스디자이너","wordType":"TAG"},{"id":12929,"content":"토스프로덕트디자인","wordType":"TAG"},{"id":12931,"content":"productdesign","wordType":"TAG"}]},"openGraph":{"title":"완성 없는 이야기, 가입 과정 개선","description":"제품 성장 과정에 따라 적절한 UX가 다를 수 있다는 사실, 알고 계셨나요? 토스의 가입 과정은 테크 블로그에 첫 번째로 소개되었을 만큼 잘 만들었다고 자부하고 있었는데, 데이터를 확인해 보니 가입 완료율이 생각보다 낮았어요.토스가 성장하면서 가입하는 주요 연령대가 바뀌었기 때문이에요....","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/simplicity23/graphics/sim23-signup-og.png","imageType":"직접입력"},"relatedPostConfig":null,"editor":{"id":1051,"name":"임경우","slug":"gyeongwoo-lim","shortDescription":null,"description":"-","imageUrl":"https://static.toss.im/photos/임경우.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"제품 성장 과정에 따라 적절한 UX가 다를 수 있다는 사실, 알고 계셨나요? 토스의 가입 과정은 테크 블로그에 첫 번째로 소개되었을 만큼 잘 만들었다고 자부하고 있었는데, 데이터를 확인해 보니 가입 완료율이 생각보다 낮았어요.\n\n토스가 성장하면서 가입하는 주요 연령대가 바뀌었기 때문이에요. 가입 유저의 대부분이 2030이었을 때는 가입 완료율이 높았지만, 시니어 유저들이 주 가입층이 되니 가입 완료율이 낮아졌어요. 이번 글에서는 가입 완료율을 높이기 위해 고민하고 시도했던 것들을 이야기할게요.\n\n요구가 너무 많은가?\nAndroid, ios가 조금씩 다르지만, 토스에 가입하려면 기본적으로는 이런 복잡한 과정을 거쳐요.\n\n인트로 - 시스템 권한 허용 동의 - 휴대폰 점유 인증 - 본인 정보 입력 - 본인 인증\n이 요구들 중에 통과율도 낮고, 확실히 개선의 여지가 있어 보이는 시스템 권한 허용 동의 단계들을 확인해 봤어요. 앱에서 권한을 요구하는 이유는 권한이 없으면 서비스 제공을 원활히 할 수 없기 때문인데요. 안드로이드는 4개, iOS는 2개의 시스템 권한을 시스템 팝업을 통해 연속적으로 요구하고 있었어요.\n\n\n이 과정을 사용자는 상식적으로 느끼지 않을 수도 있다고 생각했어요. 왜 필요한지 충분히 설명하지 않고 권한 동의를 요구하기 때문이에요. 권한 요구 과정을 더 잘 설명할 수 있는 개선안을 고민하던 중에 모든 권한이 필요한 것인지 확인해 보니 연락처 권한은 필수로 받지 않아도 되는 정보였어요.\n\n토스가 현재는 무제한 무료 송금이지만 과거에는 연락처로 송금해야지만 무료로 송금할 수 있었어요. 더 많은 사용자가 무료 송금이라는 가치를 느낄 수 있게 연락처 권한을 필수로 요구했는데 이제는 조건 없이 무료로 송금할 수 있기 때문에 연락처 권한을 필수로 받을 필요가 없는 것이었죠. \n\n각 OS별로 연락처 권한을 없애고 실험을 해봤어요.\n\n기존 안 : 권한 모두 받기 (Android 4개, iOS 2개)\n실험 안 : 필요한 권한만 받기(Android 3개, iOS 1개)\n요구를 줄여 허들을 낮추니 더 많은 사람들이 가입하게 됐을까요? 아쉽게도 기존 안과 실험 안의 가입 전환율은 거의 차이가 없었어요. 가입 의지가 부족한 사람에게는 요구의 개수가 허들이 아니라, 요구 자체가 허들이었던 거죠.\n\n매몰비용을 더 빠르게 만들어볼까\n이번에는 가입 과정 중 가장 많은 이탈이 일어나는 인트로 화면을 개선해 보기로 했어요.\n\n\n왜 사용자들은 앱 설치까지 마치고 난 뒤 [다음] 버튼을 누르지 않을까요? 위 화면은 버튼이 하나밖에 없는 화면이라 간단해 보이지만 어쩌면 가입 과정 중에 가장 사용자의 의지가 약한 곳이기도 해요. 아직 사용자는 아무것도 하지 않았으니까요.\n\n또한, 기존 인트로 화면이 사용자에게 가치를 제공하고 있다고 보기 어려웠어요. 인트로 영상에서 전하는 가치가 이미 앱 스토어, 구글 플레이에 적혀 있기 때문이죠.\n\n앱 설계의 기본 문법을 생각하면, 첫 화면에 인트로가 있는 게 보편적인 경험이라고 볼 수 있지만 가치를 주고 있지 않고 이탈률만 증가시키고 있으니 과감히 인트로를 없애고 사용자에게 이름부터 물어보기로 했어요. (권한은 아예 사라졌어요) 사용자에게 이름을 적어야 한다는 구체적인 액션을 제시하고 빠르게 매몰 비용을 만들어보려는 시도였죠. 결과는 어땠을까요? 이번에도 가입 전환율은 거의 차이가 없었어요.\n\n입력을 더 잘할 수 있게 도와줄까\n권한을 줄여도 보고, 아예 없애도 보고, 인트로를 없애 매몰 비용을 빠르게 만들어 보기도 했지만 가입 과정 완료율을 높이지는 못했어요. 데이터를 확인해 보니 큰 텍스트를 쓰는 시니어 사용자의 전환율이 특히 낮다는 사실을 알게 되었어요. 주 가입층에게 적절한 UX를 제공하고 있지 못하고 있는 게 아닌지 의문이 들어 확인해 보았죠.\n\n예상대로 시니어 사용자에게 적절한 UX를 제공하지 못하고 있었어요. 문제는 크게 2가지였어요.\n\n지금의 화면은 큰 텍스트일 때 최적의 사용 경험을 제공하지 못하고 있다.\n리서치로 알게 된 결과 시니어 사용자들은 정보 제공에 거부감을 느낀다. \n\n큰 텍스트 환경에서도 최적의 사용 경험을 제공하고, 반드시 [확인] 버튼을 눌러야만 넘어갈 수 있게 한다면 전환율이 올라갈 것이라는 가설을 세우고 실험해 봤어요. 거꾸로 입력하는 가입 경험은 여전히 슬릭 했지만, 주요 가입 연령대가 바뀐 지금은 다른 UX가 제공되어야 하는 게 아닐까 하는 생각도 있었고요.\n\n\n아쉽지만 이번에도 가입 전환율의 유의미한 변화는 만들지 못했어요. 그럼에도 정보 입력 과정이 문제는 아니었다는 것은 알게 되었죠.\n\n빠진 맥락을 추가해 볼까 \n이번에는 사용자를 직접 만나 원인을 찾아봤어요. 마침 다른 사일로에서 진행한 UT(Usability Test)에서 시니어 사용자가 본인 정보 입력 과정 중 주민번호에 거부감을 느낀다는 사실도 알게 되었죠. 주민번호를 생년월일로 대신하는 안을 프로토타입으로 만들어 토스를 써본 적 없는 시니어 사용자를 대상으로 UT를 진행했어요. \n\n\nUT를 해보니 예상과 다르게 주민번호, 생년월일이라는 단어는 문제가 아니었어요. 새로운 사실을 알게 되었는데, ios 사용자들은 회원가입 과정이 편해서 좋다는 의견을, 반면에 Android 사용자들은 이름을 적는 것조차 민감한 반응을 보였던 거예요.\n\n\n다른 반응을 보인 이유는 OS별 사용자 특성이 다른 것도 있겠지만, Android와 ios의 첫 화면이 달랐는데 이 점이 원인이라고 생각했어요. ios는 첫 화면에서 본인인증이 필요하다는 맥락을 설명해 주고 있었는데, Android는 왜 입력해야 하는지에 대한 설명 없이 바로 이름을 묻고 있었어요.\n\n맥락 없이 바로 정보를 요구하니 Android 사용자들은 거부감을 느꼈던 거예요. 사용자에게 뒷 과정을 왜 해야 하는지 충분한 맥락을 설명한다면 본인 정보 입력 과정의 이탈이 줄어들 것이라는 가설을 세우고 실험을 진행했어요.\n\n\n결과는 어땠을까요? 큰 차이는 아니지만 처음으로 실험 안의 가입 완료율이 더 높았어요! 앞에서 엄청나게 많은 시도를 했는데 간단하게 왜 해야 하는지 설명하니 가입 완료율이 올라갔어요.\n\n정리\n토스의 가입과정 개선을 위해 수많은 시도를 통해 사용자를 만나서 얻는 인사이트가 얼마나 큰 힘을 가질 수 있는지 배울 수 있었어요. 이 글을 읽는 분들은 저와 같은 실수는 하지 않으셨으면 좋겠어요. 사용자를 잘 알고 있다고 자신하지 말고, 작은 것까지 모두 확인해 보세요. 사용자들의 의견을 들을 때 좋은 경험을 설계할 가능성이 올라가고 실패의 위험은 줄어들 테니까요. \n\n\nSimplicity23 컨퍼런스 기간 중에 남겨주신 질문에 답변드릴게요.\nQ1. 개발팀과의 커뮤니케이션에 어려움은 없었나요?\n개발자와 커뮤니케이션은 언제나 어려워요. 왜 개발해야 하는지 설득하지 못하고 종종 스펙 아웃 되곤 했어요. 왜 그랬을까요? 저는 설득할 수 있는 커뮤니케이션을 위해 입장을 바꿔 생각해 봤어요.\n\n버려질 수도 있는 시안을 만드는데, 안에 들어가는 모든 UI요소를 컴포넌트화 하라고 한다면? 저는 분명 반대할 거예요. 비효율적이니까요. 제 디자인을 가지고 개발하는 것도 마찬가지 아니었을까? 하는 생각이 들었어요. 실험은 가설을 바탕으로 시도하는 것인데, 그렇다면 가설을 검증할 수 있는 최소한의 제품을 디자인해야 했어야 하는 게 아니었을까 하는 생각이요. 그 뒤로는 가설을 검증할 수 있는 최소 스펙의 디자인을 하기 시작했고, 검증된 후에 디자인은 디벨롭 될 것이라고 커뮤니케이션하게 되었고 어려움은 사라지게 되었어요.\n\nQ2. 실패라고 판단되면 진행했던 작업은 제외하고 기존 디자인을 유지하나요? 혹은 전환율 상승에 도달하진 못했지만 유의미한 인사이트와 결과를 냈다고 판단하여 업데이트를 하는지 궁금해요.\n실험 결과 차이가 유의미했는지, 근소했는지에 따라 달라지게 돼요. 기존 안이 유의미한 차이로 이겼다면, 실험 안은 폐기하게 돼요. 폐기된 실험 안을 통해 얻은 인사이트는 다음 실험을 설계하는 중요한 근거로 활용돼요. 기존 안과 실험 안의 차이가 근소할 때는 데이터상 낮은 전환율을 보이는 안이었다 하더라도 사용자에게 보다 더 나은 정성적인 경험을 줄 수 있는 안이 채택될 때도 있어요.\n\n\n<완성 없는 이야기, 가입 과정 개선> 세션은 \nSimplicity23 컨퍼런스에서 더 자세히 확인하실 수 있어요.\n\n홈페이지에서 보기 https://simplicity-23.toss.im/sessions/15\n유튜브 영상으로 보기 https://www.youtube.com/watch?v=6-sr6GmLAkM","isDisplayingFeedback":true},{"id":22605,"updatedTime":"2023-09-07T14:58:40+09:00","createdTime":"2023-09-05T14:55:51+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"인터랙션, 꼭 넣어야 해요?","subtitle":"빠른 속도를 중요시하는 토스에서 어떻게 팀원들을 인터랙션에 공감하게 하고 슬릭한 제품을 만들어나갈 수 있었는지 소개할게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/simplicity23/graphics/sim23-interaction-cover.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/simplicity23/graphics/sim23-interaction-cover.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"interaction","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":false,"workspaceId":15,"isPublished":true,"publishedTime":"2023-09-07T14:27:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22605,"title":null,"description":"제품을 인터랙티브하게 개선하면 경험이 더 좋아진다는 것은 모두 알지만, 인터랙션을 구현하는 비용 때문에 엄두가 나지 않기도 하는데요. 인터랙션 디자이너가 토스팀에 합류했을 때도 마찬가지였어요. 빠른 속도를 중요시하는 토스에서 어떻게 팀원들을 인터랙션에 대해 공감하게 하고 슬릭한 제품을 ...","urlSlug":"interaction","primaryKeyword":{"id":13044,"content":"토스인터랙션","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":11715,"content":"토스심플리시티","wordType":"SEO_KEYWORD"},{"id":11719,"content":"토스디자인","wordType":"SEO_KEYWORD"},{"id":13047,"content":"인터랙션디자이너","wordType":"SEO_KEYWORD"},{"id":13049,"content":"interaction","wordType":"SEO_KEYWORD"},{"id":13050,"content":"토스디자인시스템","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"인터랙션, 꼭 넣어야 해요?","description":"제품을 인터랙티브하게 개선하면 경험이 더 좋아진다는 것은 모두 알지만, 인터랙션을 구현하는 비용 때문에 엄두가 나지 않기도 하는데요. 인터랙션 디자이너가 토스팀에 합류했을 때도 마찬가지였어요. 빠른 속도를 중요시하는 토스에서 어떻게 팀원들을 인터랙션에 대해 공감하게 하고 슬릭한 제품을 ...","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/simplicity23/graphics/sim23-interaction-og.png","imageType":"직접입력"},"relatedPostConfig":null,"editor":{"id":1049,"name":"박연주/김지혜","slug":"yeonju-jihye","shortDescription":"Interaction Designer","description":"-","imageUrl":"https://static.toss.im/photos/jhyj.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"제품을 인터랙티브하게 개선하면 경험이 더 좋아진다는 것은 모두 알지만, 인터랙션을 구현하는 비용 때문에 엄두가 나지 않기도 하는데요. 인터랙션 디자이너가 토스팀에 합류했을 때도 마찬가지였어요. 빠른 속도를 중요시하는 토스에서 어떻게 팀원들을 인터랙션에 대해 공감하게 하고 슬릭한 제품을 만들어나갈 수 있었는지 소개할게요.\n\n인터랙션 팀의 고민\n처음 토스에 인터랙션 팀이 생겼을 때, 인터랙션은 토스팀에게 정말 낯선 개념이었어요. 그전까지 토스 앱에 동적인 화면이 거의 없었기 때문인데요. 토스 사일로에서는 인터랙션에 대해 이런 인식이 많았어요.\n\n“이건 구현하기 어려워요” \n“이번 실험에는 애니메이션 빼고 갈게요“\n“모션이 개발 공수 대비 임팩트가 있을까요?”\n토스팀의 온도를 바꿔나가기 위해 왜 이런 인식이 생기게 되었는지 이유를 생각해 봤는데 크게 2가지로 정리했어요.\n\n첫 번째, 인터랙션을 단순히 예뻐지게 하는 도구라고 생각하는 것\n두 번째, 인터랙션 분야 특성상 개발 공수가 너무 많이 드는 것\n인터랙션을 넣으면 정적인 화면에 비해서 더 예뻐지는 건 사실이지만 심미적인 가치만 강조되는 게 아쉬웠어요. 애플이나 구글의 디자인에서 많이 볼 수 있듯이, 인터랙션은 유저에게 더 명확한 피드백을 줄 수 있고, 유저가 어떤 행동을 해야 되는지 더 직관적으로 보여줄 수도 있고, 화면 안에서 어떤 일이 일어나고 있는지 쉽게 전달할 수도 있거든요. 인터랙션 팀도 토스 앱에 이런 사례를 많이 만들어서, 팀원들의 인식을 변화시키고 싶었어요.\n\n\n두 번째 이유인 인터랙션을 개발하는 공수가 많이 드는 건 어쩔 수 없는 사실이에요. 그래서 실제로 개발 공수가 적어질 수 있도록 해결책을 만들고자 했어요. \n\n인식 변화를 위한 노력\n가장 먼저 ‘인터랙션은 단순히 예뻐지게 하는 역할이다’라는 인식을 바꾸기 위해 인터랙션으로 지표를 개선하는 사례를 많이 만들었어요. 토스 제품 팀은 홈 사일로, 대출 사일로처럼 사일로별로 각 제품을 맡고 있는 구조여서 어떤 화면을 개선하고 싶으면 담당 사일로의 공감대가 필요해요. 그런데 ‘유저의 정성적 경험을 개선한다’, ‘사용성을 개선한다’는 목표로는 설득하기가 쉽지 않았어요. 그래서 사일로에서 가장 중요하게 생각하는 이탈률, 전환율 같은 지표 개선을 할 수 있는 사례를 만들었어요.\n\n*사일로(Silo): 제품을 개발하는 작은 팀\n\n대출 심사 로딩 화면이 그 사례 중 하나인데요. 기존 디자인은 2~30초 동안 로딩 이미지만 보여주는 화면이었어요. 화면의 정보가 가짜 정보라고 생각했던 유저 인터뷰에서 힌트를 얻어, 실시간으로 실제 상품들을 보여주고 신뢰감을 전달한 후 로딩을 기다리는 유저가 늘어나면 대출 실행률도 올라갈 것이라는 가설을 세웠어요. \n\n\n결과적으로 대출 실행률까진 영향을 미치지 못했지만, 화면 이탈률과 결과화면 도달률 지표가 소폭 좋아졌고 정성적으로도 더 좋은 경험이라는 사일로의 공감대가 있어서 전체 배포할 수 있었어요. 이 외에도 카드 추천, 신용점수, 카드 한도 찾기 등 다양한 제품에서 지표가 오른 사례들을 만들었어요. \n\n\n항상 지표가 오르기만 했던 건 아니에요. 전체 탭의 사이드바, 신분증 인식 화면, 카드 발급 화면 등 지표 변화가 없어 전체 배포를 하지 못한 적도 많았어요. 지표 변화가 없더라도 유저에게 더 좋은 경험이라는 공감대가 있으면 전체 배포를 하기도 하지만, 운영 상의 이슈로 배포하지 못하고 디자인을 버리게 되는 경우도 있어요. 디자이너로서 속상하지만 실패가 있어 성공한 사례가 하나씩 만들어질 때마다 더욱 값지게 느껴졌던 것 같아요.\n\n\n두 번째로 앱 전반적으로 인터랙션을 자주 경험할 수 있게 개선했어요. 대출 심사, 카드 추천 등 특정 제품을 개선하는 건 제품을 쓰는 소수의 유저들만 변화를 경험할 수 있으니, 그보다 앱 전반적으로 인터랙션을 더 자주 경험할 수 있게 만들어야겠다고 생각했어요.\n\n그래서 제일 먼저 터치 이펙트를 다듬었어요. 유저가 화면을 누를 때 회색 배경만 나오는 것이 아니라 더욱 눌리는 느낌이 나도록 간단한 모션을 추가했는데요. 공지를 하지 않았는데도 바뀐 모션이 너무 좋다는 토스팀분들 반응이 슬랙에 엄청 올라왔어요. 의도한 대로 유저가 직접 경험하면서 모션의 가치를 느끼신 것 같아 정말 뿌듯하더라고요. 그 후로도 작은 공수로 모션을 쉽게 경험할 수 있는 것들을 계속 찾아 토스 앱 곳곳에 작은 모션들을 하나씩 적용해 나갔어요.\n\n\n\n\n개발 공수를 줄이기 위한 노력\n\n첫 번째, 개발 공수를 줄이기 위해 모션의 눈속임 효과를 많이 사용했어요. 홈 화면에서 계좌를 정리해 주는 기능을 만들었는데요. 처음 개발자분들께 디자인을 보여드렸을 때, 리스트가 촤라락 들어오는 모션이 현재 구조에서는 절대 만들 수 없고, 공수도 가늠이 안된다는 부정적인 반응이셨어요. \n\n그래서 과거에 본 Google Material 가이드를 참고해서 대안을 만들었어요. 실제로 리스트에 모션을 주는 게 아닌 홈 위에 새 레이어를 띄우고 모션으로 마치 한 화면인 것처럼 눈속임 효과를 주는 방식이었죠. 이런 방향이라면 개발자 분들도 충분히 할 수 있을 것 같다는 반응으로 바뀌어서 개발을 진행할 수 있었어요.\n\n\n두 번째, 더 많은 프로덕트 디자이너와 개발자들이 어느 화면에서나 쉽게 인터랙션을 적용할 수 있도록 인터랙션 시스템을 만들었어요. 먼저 PD분들이 쉽게 모션을 만들 수 있도록 미리 정해놓은 몇 가지 모션들을 컴포넌트(Component)로 만들었어요. 무언가가 화면 안에 들어오고 나갈 때, 강조할 때, 글자에 모션을 넣을 때 등 각 상황에 맞는 다양한 컴포넌트들을 만들어서 프로덕트 디자이너분들이 Framer에서 쉽게 사용할 수 있게 했어요.\n\n\n그런데 이 인터랙션 컴포넌트들을 개발하려니까, iOS, Android, Web 각각 모션 스펙 용어나 동작 방식이 너무 다르더라고요. 그래서 저와 각 개발자분들이 모여서 모션을 정의할 수 있는 플랫폼 공통 스펙을 만들기 시작했어요. \n\n우리는 모션의 easing을 bezier랑 spring 두 가지를 사용하자. \n하나의 타겟엔 하나의 모션만 붙일 수 있다는 규칙을 만들자. \n여러 타겟에 모션을 붙일 때 쓸 ‘타임라인’이라는 개념을 만들자. \n이런 식으로 복잡한 모션까지도 표현할 수 있는 플랫폼 공통의 언어를 만들어 나갔어요.\n\n\n이런 논의를 매주 꾸준히 하면서 약 1년 만에 토스만의 인터랙션 개발 라이브러리, Rally가 만들어지게 됐어요. \n\n\n\niOS, Android, Web 3개 플랫폼에서 공통 스펙으로 인터랙션을 개발할 수 있는 랠리\n이제 토스에서는 프로덕트 디자이너분들이 개발자에게 프로토타입(prototype) 영상이나 레퍼런스만 드리고 ‘똑같이 해주세요’, ‘이런 느낌으로 해주세요’처럼 모호하게 말하지 않아요. Framer에서 인터랙션 컴포넌트로 모션을 만들면, 개발자가 인스펙터에서 바로 랠리 코드를 확인할 수 있죠. \n\n\n인스펙터로 랠리 코드가 나오는 인터랙션 컴포넌트 예시\n랠리는 스펙 하나하나 논의하며 만든 플랫폼 공통 언어이기 때문에 어떤 모션이든 개발 가이드를 명확하게 쓸 수 있고 QA할 때도 개발자랑 디자이너 간 소통이 훨씬 쉬워졌어요. 가끔 iOS, Android 개발자분들이 서로 랠리 코드를 공유하면서 논의하시기도 하더라고요. \n\n\n랠리로 쓴 인터랙션 개발 가이드 예시\n인터랙션의 시스템화를 시도해보고 싶으시다면 자주 사용하는 easing 값을 토큰으로 만드는 것부터 추천드려요. 맨 처음에 했던 일은 저희가 자주 쓰던 easing 값을 모두 모아서 bezier.expo, spring.quick처럼 이름을 지어주는 일이었는데요. \n\n\n토스에서 사용중인 인터랙션 easing 토큰들\n개발에서도 토큰을 똑같이 정의해 두면 ‘여기는 spring.quick으로 해주세요’, ‘여기는 좀 빠른 것 같은데 spring.basic으로 바꿀 수 있을까요?’처럼 공통의 언어로 대화할 수 있게 되거든요. easing 토큰화부터 먼저 해본다면 점차 모션도 어떤 식으로 시스템화하는 게 좋을지 아이디어가 떠오르실거예요.\n\n\n시스템 전파를 위한 노력\n사실 시스템은 만들었다고 끝이 아니더라고요. 개발 공수를 훨씬 줄여줄 수 있는 시스템을 만들어놨지만, 사일로분들의 사용이 처음에는 저조했어요. \n\n그래서 #animate-noti 라는 채널을 만들어서 직접 발품을 팔았어요. 회사의 모든 슬랙 채널에서 인터랙션, 모션, 랠리 등 팀과 관련된 단어를 언급하면 자동으로 이 채널에 모아지게 했는데요.\n\n처음엔 채널에 ‘여기 인터랙션 잡아봤는데 공수 많이 들까요?’와 같은 글이 많이 올라왔어요. 그럴 때 스레드에 불쑥 찾아가서 ‘인스펙터에 랠리 코드대로 하시면 바로 적용돼요’라고 답변드렸죠. 많은 분들이 ‘이렇게 쉽게 적용할 수 있는지 몰랐다, 바로 적용해 보겠다’ 말씀해 주시더라고요. \n\n매일 모니터링하고 팀원들과 소통하니 인터랙션 시스템이 빨리 전파되는게 체감됐어요. 점점 #animate-noti 채널에 인터랙션 ‘개발 너무 편해졌다’, ‘랠리 너무 좋다’와 같은 긍정적인 피드백이 자주 올라왔어요. \n\n이런 노력들로 더 많은 토스팀분들이 인터랙션에 스며들 수 있도록 했는데요. 과정이 쉽진 않았지만 인터랙션과 관련된 유저들의 반응도 확인하고 지표도 올라가는 걸 보면서 큰 보람을 느끼고 있어요. 인터랙션 또는 디자인 시스템 전파와 관련된 고민을 가진 디자이너 분들께 도움이 되었길 바랍니다. \n\n\nSimplicity23 컨퍼런스 기간 중에 남겨주신 질문에 답변 드릴게요.\nQ. 인터랙션 디자이너가 되려면 어떤 역량을 갖추어야 하고 무슨 프로그램을  다룰 수 있어야 하나요?\n동적인 디자인만이 낼 수 있는 임팩트를 고민하는 역량이 중요한 것 같아요. 정적인 UI로도 전달할 수 있는 가치라면 인터랙션은 Good to have가 되거든요. 인터랙티브하게 표현했을 때 어떤 임팩트를 낼 수 있는지 설득할 수 있는 능력이 필요해요.\n\n또 인터랙션은 구현이 까다로운 분야인 만큼, 내 디자인이 정확하게 구현될 수 있도록 개발 가이드를 잘 만드는 것도 중요한 역량이에요. 인터랙션 디자이너의 시스템적 사고 역량에 따라 개발 가이드의 퀄리티가 달라지고, 그만큼 개발자의 효율과 구현 퀄리티도 달라진다고 생각해요. \n\n토스는 변수, 햅틱 등의 기능이 꼭 필요해서 Protopie를 주로 사용하는데, 가만히 보기만 하는 영상이 아니라 실제 터치에 반응하는 인터랙션을 만들 수 있는 Hi-Fi 프로토타이핑 툴이면 뭐든 괜찮아요.\n\nQ. 세션에서 PD분들이 언급되는데 인터랙션 디자이너와 PD의 업무 차이는 무엇인가요?\n토스에서 PD분들은 각 사일로에 소속되어 있고, 사일로 제품의 비즈니스 목표를 달성하고 사용성을 수호하기 위해 그래픽, 인터랙션 등을 자유롭게 활용하며 제품 설계를 해요. \n\n인터랙션 디자이너도 동일한 목표를 가지고 있지만 특정 사일로가 아닌 인터랙션팀에 속해있고, 다양한 사일로들과 협업하며 동적인 디자인으로 더 큰 임팩트를 낼 수 있는 문제들을 주로 해결한다는 차이가 있어요.\n\n\n<인터랙션, 꼭 넣어야 해요?> 세션은 \nSimplicity23 컨퍼런스에서 더 자세히 확인하실 수 있어요.\n\n홈페이지에서 보기 https://simplicity-23.toss.im/sessions/21\n유튜브 영상으로 보기 https://www.youtube.com/watch?v=gellvpOMGew","isDisplayingFeedback":true},{"id":22546,"updatedTime":"2023-10-05T14:55:32+09:00","createdTime":"2023-08-30T11:11:01+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"크고 복잡한 제품, 과감하게 갈아엎기","subtitle":"디자이너들도 어떻게 하면 빠른 속도를 내며 전체적인 경험을 맞출 수 있을지 매 순간 고민하고 있어요. ","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/sim23-mydoc-cover.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/sim23-mydoc-cover.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"mydoc","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-09-03T22:58:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22546,"title":null,"description":"장기적으로 진행되는 큰 규모의 사업 제품을 맡은 디자이너라면 한 번쯤 이런 경험이 있을 것 같아요. 빠른 속도를 위해 작은 실험을 중심으로 제품을 출시하고 개선하는 애자일 조직은 어떨까요? 사업과 제품의 끝그림을 처음부터 고려하고 있을까요? 토스는 어느덧 4개의 계열사, 100여 개 이...","urlSlug":"mydoc","primaryKeyword":{"id":12928,"content":"토스프로덕트디자인","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":3543,"content":"토스","wordType":"SEO_KEYWORD"},{"id":11719,"content":"토스디자인","wordType":"SEO_KEYWORD"},{"id":12645,"content":"토스디자이너","wordType":"SEO_KEYWORD"},{"id":12930,"content":"productdesign","wordType":"SEO_KEYWORD"},{"id":12933,"content":"productprinciple","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"크고 복잡한 제품, 과감하게 갈아엎기","description":"장기적으로 진행되는 큰 규모의 사업 제품을 맡은 디자이너라면 한 번쯤 이런 경험이 있을 것 같아요. 빠른 속도를 위해 작은 실험을 중심으로 제품을 출시하고 개선하는 애자일 조직은 어떨까요? 사업과 제품의 끝그림을 처음부터 고려하고 있을까요? 토스는 어느덧 4개의 계열사, 100여 개 이...","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/career-resource/sim23-mydoc-og.png","imageType":"직접입력"},"relatedPostConfig":null,"editor":{"id":1048,"name":"이지윤","slug":"jiyoon-lee","shortDescription":"Product Designer","description":"-","imageUrl":"https://static.toss.im/photos/E01JAGTHP8R-U01JA1049BQ-93561329024d-512.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"장기적으로 진행되는 큰 규모의 사업 제품을 맡은 디자이너라면 한 번쯤 이런 경험이 있을 것 같아요. \n\n디자이너 : 지금 있는 기능을 모으면 이런 모습일 것 같아요. \n팀원 1 : 그런데 이 사업도 지금 진행 중이고, 이 기능이랑 서비스도 곧 붙이게 될 것 같아요. 이것들이 들어갈 곳이 고려되어야 할 것 같은데… \n디자이너 : 네. 그럼 결국 끝그림은 이런 컨셉과 방향이 맞을 것 같네요.\n빠른 속도를 위해 작은 실험을 중심으로 제품을 출시하고 개선하는 애자일 조직은 어떨까요? 사업과 제품의 끝그림을 처음부터 고려하고 있을까요? \n\n토스는 어느덧 4개의 계열사, 100여 개 이상의 제품을 담고 있는 덩치 큰 앱이 되었어요. 한 팀에서 맡는 제품의 규모가 커지고 이해관계자도 점점 복잡해지고 있어요. 수많은 제품 간의 연결성을 이어주며 토스 앱을 구성하는 것이 중요한 일이 된 거죠. 이로 인해 디자이너들도 어떻게 하면 빠른 속도를 내며 전체적인 경험을 맞출 수 있을지 매 순간 고민하고 있어요. \n오늘 제가 들려드릴 이야기는 과거 1년 전쯤 맡았던 ‘내 문서함’이라는 완성된 제품을 다시 쪼개버린 이야기예요. 한창 진행 중인 사업들과 오픈 예정인 서비스들을 뒤로하고 서비스를 갈아엎은 내용이죠. \n\n프로젝트의 배경\n기존 내 문서함 서비스는 사용자가 집으로 받아보는 세상의 모든 종이 서류를 토스에서 모아볼 수 있도록 하자는 목표를 가진 서비스였어요.\n\n\n수도요금/전기세/아파트 관리비와 같은 생활 고지서를 받아보거나, 경찰청의 교통 과태료와 같은 고지서는 물론 주민등록등본/코로나접종증명서와 같은 서류를 직접 발급할 수 있고요. 최종적으로는 받은 고지서를 바로 기관에 제출하거나 납부하여 세상의 모든 종이 서류를 없애는 가슴 뛰는 비전을 가지고 있었어요. \n이런 배경으로 서비스명을 정하게 되었고 토스 전체 탭 내에 이와 같이 구성되어 있었어요. 내 정보, 내 신용점수와 함께 유저 정보를 상단에 묶어서 보여줬죠. 상단에 위치하고 전체탭의 트래픽이 높아서 꽤나 많은 유저들이 내 문서함으로 진입하고 있었어요. \n\n\n하지만 다음과 같은 문제가 있었어요. \n\n내 문서함 서비스명만으로는 어떤 기능인지 직관적으로 이해하기가 어려웠어요. 서비스를 기획하고 만드는 사람 입장에서 바라보면, 세상의 모든 문서를 없애고 모든 서비스가 문서라는 속성이기 때문에 내 문서함이라고 정한 것이죠. 하지만 사용자 입장에서는 사용자마다 문서가 부동산 문서나 내 계좌 서류 등 다양한 종류의 문서로 해석될 수 있기 때문에, 진입하기 전까지는 ‘서비스를 직관적으로 이해하기 어렵지 않을까’라는 문제의식이 있었어요. \n\n\n두 번째는 내 문서함 화면에 여러 서비스가 붙으면서 복잡도가 너무 높아지는 문제가 있었어요. 내 문서함에서 가장 중요한 것은 내가 받은 문서를 확인하는 것인데 새로 신청 가능한 문서 서비스가 늘어날 때마다 서비스를 알리기 위한 구좌가 하나씩 추가되고 있었어요.\n\n사용자는 받은 문서를 가장 먼저 확인하고 싶은데 국민비서 알림 신청도 유도하고 싶고 주민등록등본이 발급 가능하다는 것도 알리고 싶다 보니 화면 내에서 우선순위 정리가 되지 않았던 것이죠. 토스의 Product Principle 중 하나인 One thing per One page를 지키지 못하고 있었어요. \n\n화면의 복잡도 문제는 다른 문제로도 이어졌어요. 유저들이 들어와서도 내 문서함을 이해하지 못했어요. 유저가 본능적으로 제품과 화면을 이해하지 못하니 팀에서는 기능에 대해 설명을 해주고 싶었어요. 토스앱은 사용자가 생각하지 않고 본능적으로 쓸 수 있는 상태인 Simplicity여야 하는데 별도의 화면을 추가해 기능을 소개하고 싶었던 것이죠.\n\n사용자 문제뿐만 아니라 팀 내 운영에서도 문제가 있었는데요. 스펙 구조가 모두 다른 서비스를 한 곳에 끼워 묶다 보니 끼워 맞추기 식의 정책과 로직이 쌓여갔어요. 내 문서함에 보여주는 문서들은 사업 상, 모두 다른 회사나 정부로 받아오는 API를 이용해 제품 개발을 해야 했는데요. 이 제품에는 맞지 않는 스펙이지만 다른 제품과 맞추기 위해 억지로 가능하도록 스펙을 추가했던 것이죠. \n\n\n예를 들어, 내 문서함에는 오래된 → 최신 시간 순으로 받은 문서를 쌓는 방식으로 구성이 되어있었는데요. KT 통신비 납부 기능은 사실 청구서를 받는 것이 아닌 실시간으로 최신 요금을 조회하는 방식의 스펙이었어요. 억지로 과거의 청구서를 생성해서 쌓아두고 있었죠.\n\n엣지 케이스는 작지만 매일 발생했고 방지를 위해 만든 기능과 로직이 또 다른 기능과 로직을 낳게 되어 결국 디자이너와 개발자의 운영 리소스가 많이 쓰이게 되었어요. 사용성은 점점 더 복잡해질 수밖에 없는 상황이었죠. \n\n왜 이런 문제들이 있었던 걸까요? 제가 속해 있던 페이퍼제로 팀(세상의 모든 종이 서류를 없애는 목표를 가진 팀)은 회고를 통해 이 문제들의 원인이 다음 2가지라고 생각했어요. \n\n첫 번째는 조직 구조를 제품에 그대로 반영한 것이었어요. 팀이 맡은 모든 사업과 서비스를 한 곳에 모아 넣고 그대로 하나의 제품, 내 문서함으로 묶어버렸죠. 토스팀 내에서는 ‘사용자가 우리의 조직 구성(사업)을 알게 하지 마라’는 이야기가 있는데요. 토스팀 내에서 효율적으로 생각하는 사업 단위로 팀을 구성했고, 각 애자일 조직이 목표를 향해 달려가다 보니 이를 편하게 하기 위해서 공급자 관점에서 제품을 구성해 버렸어요.\n\n두 번째 문제는 끝그림을 생각하고 제품을 구성한 것인데요. 초기 내 문서함에는 단 2개의 제품만 존재했어요. 하지만 이해관계가 복잡한 사업 특성상 일정이 중구난방이다 보니 우리가 원하는 그림을 원하는 순간에 만들 수가 없었어요. 처음부터 디자인과 개발 구조를 최종적으로 생각하는 방향에 맞추어서 설계할 수밖에 없었어요. 모종의 이유로 제품의 오픈 일정이 밀리게 되거나 스펙이 변경되게 되면, 기존 설계에 맞춰 새 제품의 스펙을 다시 끼워 맞추곤 했죠. 결국 제품과 스펙이 복잡해지고 리소스는 많이 드는 비효율을 야기할 수밖에 없었어요. \n\n하지만 애자일 조직인 토스에서는 한 번에 규모가 큰 제품을 뜯어고쳤던 경험은 거의 없었어요. 이미 완성되어 가고 많은 리소스를 투여한 제품을 완전히 부수는 것에는 굉장한 용기가 필요했죠. 또한 1명의 사용자라도 이미 서비스를 잘 쓰고 있다면, 사용자가 불편함을 느낄뿐더러 다시 처음부터 학습시키는 것은 굉장히 큰 비용을 치러야 하는 일이에요. 이로 인해 개편하는 결정을 내리기까지도 많은 논의와 고민이 있었어요.\n\n하지만 모든 운영 리소스를 한 번에 끊어내는 것이 장기적으로는 더 빠른 속도와 큰 효율을 가져올 것이라고 생각했어요. 우리는 정말 중요하고 임팩트가 큰 일들을 해야 하고 지금 작은 것들을 끊어내야 중요한 것에 집중할 수 있는 환경을 만들 수 있는 것이라고 말이죠.  \n\n\n진행 과정\n팀 내에서 개편 결정 후에도 사실 현재에 오기까지 많은 논의 과정과 고민이 있었어요. 처음에는 복잡한 화면을 정리하기 위해 정보 위계를 가장 먼저 해결하고 싶었어요. 내 문서함 홈의 다양한 안을 그려보면서 어떤 정보가 가장 중요하고 우선순위가 높은지, 어떤 서비스끼리 어떤 속성으로 묶어야 할지 고민했어요.\n\n주민등록등본이나 코로나접종증명서와 같은 문서 발급할 수 있는 ‘증명서 발급’ 탭과 그 외에 조회하거나 납부할 수 있는 ‘조회∙납부’ 탭으로 말이죠. \n\n\n하지만 조회∙납부 탭에 속한 국민비서 서비스는 교통과태료나 건강검진 안내를 사용자의 별도 액션 없이 일방적으로 알림으로 받는 것이고, 아파트 관리비나 통신비 서비스는 본인이 조회를 해야 했기 때문에 같이 묶는 게 어색하지 않냐는 의견이 있었어요. \n\n또한 탭 이름만 보고 어떤 서비스가 있을지 예상하기 어려웠기 때문에 기존 안의 직관성의 문제가 해결되지 않았어요. 게다가 탭 구조의 한계로 인해 첫 번째 탭인 증명서 발급 탭이 더 강조될 수밖에 없었고, 팀원들은 두 번째 탭의 주목도가 떨어져서 두 번째 탭에 속한 서비스들의 액티베이션 비율이 떨어질 것 같다는 우려가 있었죠. \n\n이런 우려를 보완하기 위해 두 번째는 스크롤로 구성해 보았어요. \n\n언제든 등본을 발급받을 수 있도록 최상단에 위치하고 그 아래 내가 신청한 문서들이 도착하면 확인할 수 있게, 하단에는 아직 신청하지 않은 문서 서비스들을 보여주고 신청할 수 있게끔요. 하지만 스크롤을 너무 내리지 않도록 하기 위해 받은 문서를 모두 보여줄 수가 없었고, 더보기를 넣어 불필요한 뎁스와 몇 개의 문서를 어떤 우선순위로 보여줄지 등의 정책이 생길 수밖에 없었어요. 기존에 우릴 괴롭히던 정책과 로직의 지옥, Less Policy를 지킬 수 없게 된 거죠. \n\n\n화면 안에서 정보 배치, 컴포넌트 수정, 워딩 바꾸기를 한 50번쯤 했을까요. 굉장한 현타와 함께 ‘내가 길을 잃었구나’라는 생각이 들었어요. 해결하고자 했던 문제와 점점 멀어지고 있었어요. 저는 여전히 기존의 내 문서함과 문서에 갇혀있었던 거예요. 근본적인 문제는 화면 안에, 문구 안에 있는 것이 아니었는데 말이죠.\n\n\n유저 행동에 맞게 제품 쪼개기\n\n잠시 프레이머에서 벗어나보기로 했어요. 유저 행동과 가치에 집중해 유저의 행동에 맞게 제품을 잘게 쪼개보았어요. \n\n사용자가 생활에서 해당 서류를 접했을 때 어떤 행동을 먼저 떠올릴지, 각 제품에서 유저가 행할 메인 액션 (Clear CTA)는 무엇인지를 고민했어요. \n발급하기: 등본 떼기\n납부하기: 수도요금, 통신비, 지방세\n알림/통지받는 것: 백신 접종 안내, 민방위 훈련 통지서, 보험 미납 안내\n\n\n\n\n기존에는 문서 속성 안에서 ‘받은 문서’와 ‘새로 문서 받기’로 나뉘어있던 것을 모든 제품을 펼쳐두고 유저의 행동별로 다시 그루핑을 하고 제품으로 구성한 것이죠.\n\n또한 서비스 중에는 한번 신청만 해두면 사용자가 굳이 별다른 액션 없이 안내만 받아도 되는 서비스가 있었어요. 보험 통지서의 경우 삼성화재에 가입된 고객만 이 서비스를 신청할 수 있고, 신청만 하면 받아만 보면 되는 것이었죠. 사용자가 굳이 기능을 다시 찾아 들어올 이유가 없었어요. 과감하게 전체탭 메뉴에서 고정 진입점을 제거하고 토스의 알림탭으로만 받을 수 있도록 하였어요. \n\n\n욕심 버리도록 설득하기\n\n가장 어려웠던 일은 나 자신과 팀원들을 설득하는 일이었어요. 내 문서함은 전체탭에서도 상단에 위치했기 때문에 좋은 트래픽을 받고 있었어요. 하지만 위처럼 제품을 모두 쪼개니 더 이상 하나의 진입점에 다 넣을 수 없었어요. 그렇다면 다시 이들을 묶을 새로운 개념과 뎁스가 생겨야 했고 직관적이지 않은 기존 네이밍 문제를 해결할 수 없었기 때문이죠.\n\n저는 팀원들에게 위 기준으로 쪼갠 제품을 맞는 카테고리 메뉴에 넣어야 하고, 상단에서 내려올 수밖에 없다고 했어요. 하지만 우리 제품을 알리는 PO 입장에서는 이 ‘황금 땅’을 벗어나기가 싫었던 거죠. 게다가 PO는 ‘이 서비스를 쓰기 위해 들어왔다가 → 우연찮게 이 서비스를 보게 될 것이고 전이된다, 즉 cross activation 효과’를 포기할 수 없었죠. \n\n저는 계속 질문을 던졌어요. \n당신이 유저라면, 토스에서 증명서를 발급하기 위해 어디로 찾아갈 것 같은가요?\n만보기는 오랜 기간 전체탭 하단에 위치했는데 잘 찾아오지 않나요?\n현재도 대부분의 트래픽은 알림으로 올리고 있지 않나요? 유저 분들이 다시 이 서비스를 찾아들어올 수 있을까요?\n\n황금땅을 유지하는 것은 일시적인 유입을 늘릴 수는 있겠지만, 사용자가 강한 동인 없이 그 제품을 마주했다면 제품의 진짜 가치를 알기 어렵고 다시 찾기도 힘들 거예요. 기존 내 문서함 화면은 들어온다 하더라도 너무 다양한 맥락의 제품이 뒤섞여있어서 사용자가 이해를 할 수도 없었고요. 디자이너라면 모두 공감할 거예요. 비즈니스 목표를 달성하면서도 사용자의 경험을 최상으로 유지하는 것은 매우 어렵고 큰 용기를 필요로 한다는 것을요. 단기적인 지표 달성보다는 사용자 가치를 중심으로 생각하면 장기적인 제품 성장에 도움이 될 것이라는 믿음을 가지는 게 중요했죠. \n\n\n우리를 괴롭히는 운영 리소스 최소화하기\n\n제품 별 운영 리소스를 최소화하는 일도 해결할 중요한 문제 중 하나였어요. 운영 리소스를 최소화해야 우리가 정말 달성하고 싶은 목표에 집중을 할 수 있으니까요. \n\n기존 내 문서함에서는 행정안전부 API에서 내려오는 에러 문구가 있었어요. 하지만 API에서 내려주는 문구는 토스의 라이팅과는 맞지 않았기 때문에 에러가 추가되거나 발견될 때마다 서버 개발자가 디자이너에게 알려주면 디자이너가 일일이 수정하고 있었어요.\n\n매번 새로운 종류의 알림이 추가될 때마다 에러가 몇 백개씩 추가되었기 때문에 리소스를 해결하기 위해 과감하게 라이팅을 맞추는 것을 포기하고 서버에서 받는 그대로 보여주기로 결정했어요. 대신 이상한 기호들이 포함되어 있으면 공통적으로 들어가 있는 이상한 문구들을 정리하여 제거해 달라고 요청드렸어요. \n\n\n캐쥬얼하지만 직관적인 컨셉\n\n내 문서함 중 주요 기능 중 하나는 주민등록등본, 코로나접종증명서 등의 개인 민원문서를 발급받을 수 있는 것이었는데요. 주민센터나 정부 24 홈페이지가 아닌 타 앱에서 등본을 뗀다는 것은 너무 혁신적인 경험이었기 때문에 사람들이 이 기능을 예상하거나 이해하기가 어려웠어요. \n\n\n저는 사용자가 바로 제목만 보고 이해할 수 있으면서도 너무 어렵게 느끼지 않았으면 했어요. 사람들이 가장 많이 받는 증명서인 주민등록등본인 것을 고려해 ‘등본 떼기’로 서비스 명을 바꾸었죠. 하지만 성적증명서나 자격증명서 등도 뗄 수 있었기 때문에 등본 외의 증명서를 찾는 사람들은 오히려 서비스를 찾지 못하는 문제가 있었어요. \n\n직관적으로 이름을 정하자니 너무 지엽적이고, 제너럴하게 쓰자니 ‘내 문서함’과 같은 네이밍이 될 수가 있었어요. 마치 화려하지만 심플한 것처럼 어려운 문제였죠. \n\n\n저희는 상위 카테고리 명을 활용하였어요. 등본 → 증명서로 제너럴하게 바꾸되, 보통 등본은 주민센터에서 떼니 여기서 착안해 주민센터-증명서 떼기로 민원 증명서를 의미함을 내포했죠. 등본 발급 하면 바로 주민센터를 떠올리기 때문에, 이 멘탈 모델을 활용해 이 서비스를 사용자에게 각인시키기도 수월할 것으로 생각했어요. 덕분에 외부로부터도 칭찬받고 사용자도 무리 없이 받아들이고 있다는 점도 확인할 수 있었어요. \n\n정리\n약 2달간 여러 가지 방법의 설득과 고민 과정을 통해 다른 형태와 모습으로 서비스를 정리할 수 있었어요. 간편 송금만 가능했던 토스가 커져가는 것처럼, 저도 작은 제품을 개선하다가 크고 복잡한 제품을 개선하는 과정에서 배운 것이 많았어요. \n\n결국 전체 앱 관점을 바라보고, 제시할 수 있는 사람은 디자이너뿐이라는 것이죠. 사일로 구조와 애자일 조직에서는 본인 팀의 사업과 제품 목표 달성만을 위해 달려가기 때문에, 전체 사용 흐름과 앱 구조를 보기가 어려워요. 하지만 유일하게 봐줄 사람은 사용자를 대표하는 디자이너라는 거예요.\n\n여러분 혹시 디자인이 잘 안 풀릴 때가 있나요? 그렇다면 분명 그 답은 화면에 있지 않을 거예요. 과감하게 작업하던 화면을 닫고 사용자 가치를 중심으로 다시 제품을 바라보세요. 그럼 지금 눈앞의 컴포넌트나 라이팅이 해결책이 아닌 다른 해결책이 보일 거예요. \n\n\nSimplicity23 컨퍼런스 기간 중에 남겨주신 질문에 답변 드릴게요.\nQ. 토스의 Product Principle은 어떤 것이 있는지 궁금해요.\nProduct Principle은 토스 제품의 winning strategy 를 담고 있는, 기준이 되는 제품 디자인의 원칙이에요.\n\n\nSimplicity\n단순함은 토스 제품의 core principle 입니다.\n단순함이란, 사용자가 토스 제품을 사용하기 위해 특별히 ‘알아야 할 것’, ‘배워야 할 것’이 없으며, 본능적으로 이해할 수 있음을 의미합니다.\n\n\nSimplicity를 만드는 방법 \n이 본능적인 사용을 가능하게 하려면 우리가 고려해야할 세가지 비용이 있습니다.\n바로 인지 비용, 심리 비용, 노동 비용이 바로 그것입니다.\n\n\n1초만에 이해되게 만들기 (인지적 비용 줄이기) \nCasual Concept \n어려운 금융의 개념을 친숙하고 이해하기 쉽게 만들었는가?\nOne thing per One page\n하나의 화면에 하나의 명확한 목표가 들어가는가?\nClear Call to Action \n과업을 완료하기 위한 CTA가 명확하게 드러나는가?\nLess Policy\n고객이 사용을 위해 ‘알아야 할’ 것을 없앨 수 있는가?\nEasy to Answer\n과업 완료까지의 모든 질문은 3초 안에 대답할 수 있는 것들인가?\nMinimum Features\n이 기능 없이는 절대 목표를 달성할 수 없나?\n하고 싶게 만들기 \nExplain Why\n왜 이 과업을 완료해야하는지 고객에게 충분히 설명했는가?\nNo Ads Patterns\n습관적으로 광고 문법으로 소구하고 있지는 않은가?\nValue First\n뭐가 좋은지도 모르는데 정보 입력을 요구하거나 비용을 이야기하진 않는가?\nPersonalize\n고객에게 맞춤 경험을 제공했는가?\nContext Based \n앞 뒤 상황의 맥락이 이어지는가?\n하기 쉽게 만들기 \nSleek Experience\n전체 Flow가 물 흐르듯이 진행되는가?\nLow-cost action \n노동 비용이 더 적게 드는 경험을 만들었는가?\nNo more loading\n핵심 Flow 에서 기다림을 완전히 없앴는가?\n\nQ. 지표를 달성해야 하는 환경에서 의사결정권자를 설득하는 것은 어려운 것 같아요. 지윤님께서 말씀하신 것과 같은 논리가 통할 수 있는 것은 조직문화에서 비롯된 것인가요? \n토스에서도 지표 달성을 위해 모든 팀원이 노력해요. 저 역시도 누구보다도 그 목표를 달성하고 싶은 팀원이고요. 하지만 이러한 사용자 중심의 해결책, 지속 가능한 해결책을 끊임없이 내고, 이를 시도해 보는 것이 토스의 문화인 것 같아요. 이 근본적인 해결이 결국 우리 모두에게 성공과 성과로 돌아올 것이라는 믿음을 갖고 사례를 많이 쌓는 것이 중요한 것 같아요. 이 사례들이 모여 모두가 이 방법이 가능하다는 것을 알게 되고 더 전파되게 되고요. \n\n작은 것이라도 포기하지 말고 근본적인 문제를 해결하기 위한 방법을 끊임없이 시도해 보는 것이 중요하다고 말씀드리고 싶어요!","isDisplayingFeedback":true},{"id":22486,"updatedTime":"2023-08-31T13:49:51+09:00","createdTime":"2023-08-23T15:23:35+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"30대 디자이너가 10대 전용 카드를 만든다면?","subtitle":"'요즘 10대는 어떤 카드를 좋아할까?', '30대인 내가 10대 친구들이 좋아하는 디자인을 할 수 있을까?' 청소년 전용 카드를 만들며 맞닥뜨렸던 혹독한 진실과, 그 과정에서 얻은 인사이트를 공유하고 싶어요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/sim23-uss.png","videoUrl":null,"backgroundColor":null,"isFill":true,"imageAlt":"토스 10대 전용카드 유스카드"},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/sim23-uss.png","backgroundColor":null,"isFill":false,"imageAlt":"토스 10대 전용카드 유스카드"},"key":"uss-card","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-23T15:25:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22486,"title":null,"description":"토스에는 어린이, 청소년 전용 카드가 있다는 거 알고 계셨나요? 출시된 지 1년 반도 지나지 않아 벌써 130만 장 넘게 발급되었어요. 토스 유스카드 (USS)라는 이름으로 세상에 나온 이 카드는 토스의 유저 중 틴즈 타겟, 즉 만 7세부터 만 16세까지만 이용이 가능한 충전식 선불카드...","urlSlug":"uss-card","primaryKeyword":{"id":8246,"content":"청소년","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":7561,"content":"유스카드","wordType":"SEO_KEYWORD"},{"id":7571,"content":"토스 청소년","wordType":"SEO_KEYWORD"},{"id":8675,"content":"청소년 체크카드","wordType":"SEO_KEYWORD"},{"id":12731,"content":"토스 브랜딩","wordType":"SEO_KEYWORD"}],"tags":[{"id":7560,"content":"유스카드","wordType":"TAG"}]},"openGraph":{"title":"30대 디자이너가 10대 전용 카드를 만든다면?","description":"토스에는 어린이, 청소년 전용 카드가 있다는 거 알고 계셨나요? 출시된 지 1년 반도 지나지 않아 벌써 130만 장 넘게 발급되었어요. 토스 유스카드 (USS)라는 이름으로 세상에 나온 이 카드는 토스의 유저 중 틴즈 타겟, 즉 만 7세부터 만 16세까지만 이용이 가능한 충전식 선불카드...","backgroundColor":"#424242","imageAlt":"토스 청소년 전용카드 유스카드","imageUrl":"https://static.toss.im/assets/toss-tech/sim23-uss-og.png","imageType":"직접입력"},"relatedPostConfig":null,"editor":{"id":1043,"name":"심석용","slug":"sqd","shortDescription":"Brand Designer","description":"Brand Designer","imageUrl":"https://static.toss.im/simplicity23/21-uss/speaker-seokyong.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"누구에게나 특별한 ‘생애 첫 카드’\n토스에는 어린이, 청소년 전용 카드가 있다는 거 알고 계셨나요? 출시된 지 1년 반도 지나지 않아 벌써 130만 장 넘게 발급되었어요. 토스 유스카드 (USS)라는 이름으로 세상에 나온 이 카드는 토스의 유저 중 틴즈 타겟, 즉 만 7세부터 만 16세까지만 이용이 가능한 충전식 선불카드인데요. \n\n\n\n10대는 엄마 카드나 아빠 카드가 아닌, 본인의 이름이 새겨진 생애 최초의 카드 발급 경험이 대다수예요. 카드를 발급하고 사용하는 경험이 훨씬 특별하고 새롭게 다가올 유저인 거죠. \n\n이런 모습을 상상하며 기획하고 디자인하는 과정들과, ‘30대 직장인인 내가 10대 친구들을 어떻게 이해할 수 있을까?’ 고민한 부분들에 대해 공유드릴게요.\n\n유저의 취향을 디깅해보자\n인사이트를 얻기 위해 해당 연령층을 타겟으로 한 인기 많은 브랜드와 이벤트, 웹소설, 10대를 다룬 인터뷰와 다큐멘터리 필름, 트위터 등 다양한 커뮤니티에서 주고받는 이들의 용돈 및 경제 관련 대화들을 한참 디깅(digging)했어요. \n\n이 과정에서 찾은 인사이트는 그들은 충분히 독립적이고 주체적이다는 느낌이었어요. 흔히 말하는 틴즈 타겟 마케팅이나 상품에서 귀여움을 어필하는 포인트는 어쩌면 어른의 시선에서 바라보고 일컫는 ‘어린이와 청소년’의 모습이 아닐까 생각했어요. 정작 이 카드를 사용하는 유저들은 본인들은 스스로 작고, 어리다고 말하고 싶을까? 생각이 들더라고요.\n\n우리의 추측 즉, ‘공급자의 시각으로 잠정 고객이 왠지 좋아할 것 같은 카드가 아니라, 진짜 이 카드를 사용할 유저들이 좋아할만한 디자인을 해야한다.’의 관점을 최대한 담기로 했어요. 카드 디자인을 하면서 기존에 출시된 성인들을 위한 토스 카드와도 차별점이 있어야 한다고 생각했죠.\n\n정말 내가 생각했던 가설이 맞을까\n굉장히 다양한 스타일로 열심히 기획을 해보고 디자인에 몰두하고 있는데, 갑자기 어떤 생각이 들더라고요. ‘그런데 어린이& 10대 청소년들이 원했던 게, 사실은 귀여움이면 어떡하지?’ 그렇다면 가설이 모두 무너지는 것이 잖아요. 만약 이점이 부정된다면 모든 것을 다시 돌아가야 하는 상황이었어요.\n\n제 안에 두 자아가 대립하더라고요.\n\n\n😈 : 컨셉 관련해서는 정량적으로 알기도 어렵고 자신 있으니 그냥 진행하자! \n이런 악마의 속삭임이 있었고,\n👼🏻 : 아니야. 그래도 그 가정 자체가 아닐 수도 있잖아! 더 늦어지기 전에 확인해 보자!\n라고 말해주는 천사의 목소리도 있었어요.\n\n컨셉에 대한 가정을 이미 세우고 확신을 얻는 과정이 제게는 낯설고 어쩌면 힘든 과정이었어요. 제가 세운 것들에 대한 부정을 받았을 때 디자이너로서 신뢰를 잃으면 어떡하지라는 걱정이 들었어요. 하지만 팀원들과 이야기를 해보며 자신감을 얻고 천사의 안내를 따라갔습니다.\n\n유저 인터뷰를 진행했어요. 인터뷰 때 나왔던 공통된 보이스는 ‘나의 주체적인 소비와 용돈관리를 하고 싶다’와, 이  맥락과 이어지는 부분으로 ‘형 누나들처럼 어른스러운 카드를 갖고 싶다’는 점이었죠. \n\n10대 친구들은 돈을 쓸 때 카드를 내미는 행위가 10대에게는 어른스러운 행위라는 것을 캐치했어요. 용돈을 계좌나 카드로 관리하는 행위에도 ‘부모님이 아닌 내가 직접 용돈을 관리하고 싶다’는 의지를 내비쳤고요.\n\n다행히 제가 생각한 방향성이 맞았고, 귀여운 느낌의 브랜딩보다는 심플하고 세련된 느낌의 디자인이 맞겠다는 걸 좀 더 확신해서 진행할 수 있었어요. 그래서 이름도  ‘우리가 바라보는 우리의 젊고 어림’이라는 뉘앙스가 담긴 ‘유스카드 (USS)’로 잡았어요.\n\n\n서베이를 해보자, 잔인할지언정! \n디자인 디벨롭 및 최종안을 결정하는 단계에서 마지막 큰 고민에 봉착했어요.\n\n10대 유저들에게 한 해 한 해는 엄청난 차이잖아요. 1년만 지나도 금세 취향이 바뀌어버리는 초등학생부터 중학생, 심지어 고등학생까지 모두가 공감할 수 있는 디자인이 있을지 고민되었어요. \n\n앞서 말씀드린 고민처럼 대중을 타겟으로 하는 것도 아니고 뾰족한 성향을 가진 페르소나가 존재하는 것이 아닌, 나이라는 공통분모로만 묶이는 유스 유저들의 성향이 모두 담을 수 있는 디자인이 과연 존재할까 싶었어요. 각자 개인적인 경험에서 오는 취향이 굉장히 뚜렷하여 ‘좋아하는 디자인의 포인트’가 너무 다르고 주관적인 거죠.\n\n그때, UX 리서처 승희님이 디자인 초기 시안들도 객관식처럼 가볍게 선호도 서베이를 하면 어떻겠냐고 먼저 제안을 주셨어요. 처음에는 무섭기도 하고 망설여지더라구요. 내부도 아니고 유저들에게 직접 투표를 받아보다니? 디자이너인 제 자신에게 너무 가혹하다는 생각도 사실 들었어요. 하지만 이번 케이스에서는 유저와의 거리가 너무 멀기에 거리감을 좁히는 ‘솔직한 수단’이 필요하기에 기꺼이 진행을 해보았습니다. \n\n‘싫어할 거야, 좋아할거야’라는 가정이나 상상이 아닌, ‘이걸 좋아하네?’ 또는 ‘이걸 싫어하네?’라는 솔직한 팩트가 필요했어요. 왜냐하면 우리 팀원 중에는 그 누구도 10대가 없으니까요!\n\n\n세 가지 소결론들을 내리고 이에 맞춰 최종안들을 결정했어요. 결론적으로 유저 보이스를 듣고 반영한 것은 너무나 잘한 선택이었어요. 고민할 필요가 없다는 확신을 얻은 부분도 있었고, 수정이 필요하다고 판단하여 최종 디벨롭 된 부분도 있었죠. 덕분에 토스하면 떠오르는 이미지와 다를지언정, 제 보이스에 대한 확신이 생겼었죠. \n\n\n\n\n마지막 작업들을 거치며, 5개의 각기 다른 유스카드 디자인들이 세상으로 나왔어요. 각각의 다른 페르소나가 가지고 있는 모습을 상상한 결과물이에요.\n\n나이라는 거리감이 있는 유저들을 상상하는 방법이 저에게도 굉장히 특별한 경험이었어요. 그 경험 중 가장 임팩트 있으면서도 고민이 많았던 점은 ‘10대들에게 투표를 받아보기’로 결정한 액션이었어요. 저도 서베이를 하며 잠재 고객의 보이스를 듣는 것이 제 안의 틀을 깨는 용기이자 큰 시도였어요. 외면하고 싶은 순간을 피하지 않고 기꺼이 맞이했을 때 새로운 확신과 결과물이 도출되지 않나 싶어요. 과거의 솔직한 고민들이 여러분들에게 작지만 확실한 용기로 닿기를 바라며, 이만 아티클 마무리 할게요!\n\n\n\nSimplicity23 컨퍼런스 기간 중에 남겨주신 질문에 답변 드릴게요.\nQ. 디자인에 대한 검증에 대한 지표는 어떻게 잡으셨나요?\n서베이를 통해 위에 보여드린 시안보다 다양한 시안들의 투표를 진행했어요. A를 선택할 때 A1, A2, A3를 보여주고, A3를 고르면 그중에서 A3-1, A3-2를 보여주는 방식으로요. 이런 식으로 유저의 취향을 좁혀 나갔어요. 선호도 로직에 대해서는 당시 Product Designer 소연님과 리서처 승희님이 많이 도와주셨어요. \n\n마지막에 주관식으로 ‘어떤 카드가 어떤 이유로 좋았냐’는 물음을 넣었는데, 이 문답이 굉장히 유효했어요. 10대 친구들의 개인적인 경험에 의거한 취향(예를 들어, 나는 축구를 좋아해서 축구팀처럼 보이는 지구본 디자인이 좋다, BTS를 좋아하니 보라색 카드가 좋다 등)의 대답은 조금 후순위로 미루고, 물성, 컬러, 그래픽에 대하여 보편적이고 일반적인 보이스를 내는 친구들의 공통적인 감도를 캐치하려 노력하였어요. \n\n\nQ. 만약 유저의 보이스가 예상했던 부분과 매우 다르게 나왔다면 디벨롭 방향성 설정에도 큰 영향을 미쳤을 것 같나요?\n네, 그랬을 것 같아요. 귀여운 카드에 대한 니즈가 많았다면 지속가능한 토스만의 귀여운 어셋을 고민했을 것 같아요. 후반부의 투표 서베이는 제가 생각한 것보다는 조금 다르긴 했어요. 예상한 수치보다 모노톤을 좋아한다는 대답이 더 많았고, 컬러가 들어간다면 반투명하거나 홀로그램 등 물성 자체에 대한 새로움까지 곁들여지는 것을 선호한다는 러닝이 있었어요. 실제로 예상과는 다른 대답들이 최종안 결정 과정에 굉장히 유효하였습니다.","isDisplayingFeedback":true},{"id":22439,"updatedTime":"2023-08-17T18:13:36+09:00","createdTime":"2023-08-17T17:29:52+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"슬랙봇 디자인 101","subtitle":"슬랙봇 디자인을 잘 하려면 무엇을 알아야하는지 알려드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/slackbot101.png","videoUrl":null,"backgroundColor":null,"isFill":true,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/slackbot101.png","backgroundColor":null,"isFill":true,"imageAlt":null},"key":"22439","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-17T17:38:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22439,"title":null,"description":"그동안 토스팀에서 꽤 많은 슬랙봇을 만들었어요. 그러면서 좋은 슬랙봇 디자인에 대해서도 치열하게 고민했어요. 이 고민의 흔적을 나누면 업계 커뮤니티에도 도움이 될 거로 생각해서 이렇게 글을 써봅니다.제가 그동안 만들었던 봇 중 일부인데요. 업무 시간 중에 커피를 빠르게 주문하도록 슬랙에...","urlSlug":"22439","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"슬랙봇 디자인 101","description":"그동안 토스팀에서 꽤 많은 슬랙봇을 만들었어요. 그러면서 좋은 슬랙봇 디자인에 대해서도 치열하게 고민했어요. 이 고민의 흔적을 나누면 업계 커뮤니티에도 도움이 될 거로 생각해서 이렇게 글을 써봅니다.제가 그동안 만들었던 봇 중 일부인데요. 업무 시간 중에 커피를 빠르게 주문하도록 슬랙에...","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/career-resource/slackbot101_og.png","imageType":"직접입력"},"relatedPostConfig":null,"editor":{"id":570,"name":"강영화","slug":"younghwa-kang","shortDescription":"Product Designer(Tools)","description":"_","imageUrl":"https://static.toss.im/illusts/profile-younghwa.jpeg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":4,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"그동안 토스팀에서 꽤 많은 슬랙봇을 만들었어요. 그러면서 좋은 슬랙봇 디자인에 대해서도 치열하게 고민했어요. 이 고민의 흔적을 나누면 업계 커뮤니티에도 도움이 될 거로 생각해서 이렇게 글을 써봅니다.\n\n\n제가 그동안 만들었던 봇 중 일부인데요. 업무 시간 중에 커피를 빠르게 주문하도록 슬랙에서 주문하는 토스팀 사이렌오더 커싸봇 부터, Jira에 접속하지 않고도 이슈를 생성하고 관리하는 이슈봇 등 수많은 슬랙봇이 있지요.\n\n\n\n커피 사일로에 주문하는 사이렌오더 커싸봇\n\n\nJira에 접속하지 않고도 간편하게 이슈를 관리하는 이슈봇\n\n이슈봇 활용하는 모습\n\n슬랙봇은 메이커 입장에서도, 사용자 입장에서도 좋은 도구랍니다. 메이커 입장에서는 싸게 만들 수 있어서 편리하고요. 유저 입장에서는 업무 맥락에서 다른 페이지로 이동할 필요없이 바로 사용해서 편리하죠. \n\n위에 언급한 JIRA 티켓을 만드는 이슈봇을 예로 들어볼게요. \n\n과거 이슈봇이 없던 시절에는 다음과 같은 워크플로우로 업무를 처리했는데요.\n\n슬랙으로 이슈를 제보받으면, 브라우저를 열고 지라에 접속해서 이슈 생성\n이슈봇이 나오고 나서는 다음과 같이 간편해졌어요.\n\n이슈봇을 통해 언제 어디서나 슬랙 내에서 즉시 이슈 생성 / 수정 / 완료\n이슈봇을 통해서 각 이슈를 생성하는 시간을 45초, 업데이트 하는 시간을 15초 절약했는데요. 2021년에 계산한 바로는 이슈봇이 토스팀원의 업무시간을 1,076시간 절약했는데, 지금까지는 더 많은 시간이 절약됐겠죠. 1,076시간은 209시간 기준 한명이 5개월동안 풀타임으로 일한 시간이라고 해요. 실제로 퇴사하신 분 중에 이슈봇을 그리워 해서 재입사 하고 싶다는 팀원도 있다는 소식을 들을 정도였는데요. 팀원들에게 편리하고 유용한 봇들을 만들어왔어요.\n\n\n좋은 슬랙봇이란 무엇일까요? 채팅 앱에서 업무를 ‘가장 빠르게 처리하도록 돕는’ 봇입니다. 왜 슬랙봇을 사용하는지 이해하면 이 답변에 공감하기 쉬우실 거예요. 우리는 업무시간에 “대화”를 가장 많이 합니다. 구두로 하는 대화를 제외하면 거의 서면 대화죠. 그중에서도 압도적으로 채팅을 많이 하곤 해요. 이 글을 읽는 여러분들도 업무 중엔 채팅으로 가장 많이 이야기 나눈다는 걸 금방 알아차리실 거예요. 슬랙봇은 해야 하는 태스크를 “업무 대화' 맥락에 위치시켜 빠르게 처리하게 돕기 위해서 사용해요. \n\n\n그동안 도움이 됐던 꼭지는 다음 주제들이에요. \n\n1) 슬랙이라는 플랫폼에 대한 이해\n\n2) 타사, 자사 레퍼런스 찾기\n\n3) 심플한 인터페이스 설계\n\n4) 사용자 맥락 이해\n\n\n하나씩 살펴볼게요!\n\n\n슬랙이라는 플랫폼\n먼저, 플랫폼의 특이한 구현 제약사항을 이해해야 해요. 처음 슬랙봇 디자인하는 디자이너들이 온보딩에 가장 어려움을 겪는 부분이기도 하지요. 슬랙 위에서 디자인하는 건 디자인 툴 위에서 그림을 그리는 우리 멘탈 모델과 달라서 시안을 가져가면 문제가 생기는 경우가 많았어요.\n\n가장 다른 점은 HTML 등 웹 문서 마크업 하는 방식이 아니라 슬랙에서 정의한 “블록'이라는 개념으로 이루어져 있다는 점이에요. \n\n\n슬랙의 블록킷 예시 (출처 : Slack 공식 홈페이지)\n\n그렇기 때문에 아래와 같은 제약 사항이 생기곤 했어요.\n\nUI 커스텀이 불가능해요. 슬랙에서 블록으로 정의한 UI인 블록킷으로만 써야해요.\n블록 갯수가 제한되어있어 긴 메시지를 만들려면 필수로 일부 메시지를 숨김처리해야해요.\n버튼에 들어가는 글자 수가 한정되어 있어요.\n웹과 달리 링크 텍스트를 눌렀을 때 페이지 전환이 안 되고 무조건 버튼을 사용해야 해요.\n\n이런 내용들을 이해해야 좀 더 고도화된 UX를 만들 수 있어요. 어떻게 할지 엔지니어분과 긴밀하게 얘기했던 기억이 나요. 가령, 모바일에서 보면 블록킷으로 제공된 버튼이 너무 약하게 보이는데 바꾸지 못했어요. 모달 안에서 리치한 경험을 주고 싶을 때도 제약이 있었어요. 그래서 가능한 부분들을 엔지니어분께서 다른 방법으로 제안 주시고, 디자이너로서 받아들일지 보고 결정하는 워크플로우로 업무를 하기도 했답니다. 제약 사항을 피해 가는 꼼수를 많이 썼죠.\n\n\n타사, 자사 레퍼런스 찾아보기\n이런 플랫폼 제약 위에서 잘 디자인하려면 이미 잘 돌아가고 있는 제품을 확인해야 해요. Producthunt나, 슬랙 앱 목록 화면에서 다양한 봇의 모양을 살펴봤어요. 토스팀 내에 있는 사람을 칭찬하는 봇을 만들 때는 HeyTaco를, 온보딩 져니 설계를 위한 봇을 만들 때는 Donut 을 참고했지요.\n\n\n\nHeytaco 앱 일부 (출처 : Producthunt)\n\n\n\n\nDonut for onboarding 앱 일부 (출처 : Producthunt)\n\n여러 가지 참고했는데요. \n\n어떤 식으로 제약 조건을 우회했는지\n어떤 모양으로 만들면 최적의 설계인지\n사용자와 커뮤니케이션은 어떻게 하는지\n마케팅은 어떻게 하는지\n이러 내용을 참고하면서 만들었어요.\n\n\n그 외에도 다른 디자이너분들이나 엔지니어분들이 만든 반응이 좋았던 슬랙봇 모양도 참고했어요. \n\n\n여러 순위나 숫자를 캐주얼하게 보여주는 재밌는 슬랙봇을 팀원들이 좋아하셨고요.\n\n\n말투가 귀엽고 엉뚱한 봇도 반응이 좋았어요. PR 리뷰 등 업무를 독려하는 커뮤니케이션을 위해 위트가 섞인 봇을 만든 것을 참고했었죠.\n\n\n\n작은 포인트지만 다른 레퍼런스를 참고해서 팀원들이 업무에서 만나는 봇의 껍데기, 캐릭터도 최대한 귀엽게 만들었어요. 귀여울수록 말 걸고 싶고 팀원들에게 잘 각인되는 효과가 있더라고요. 피곤한 업무시간 중에 잠깐의 휴식을 주기도 해요.\n\n\n\n실제로 봇으로 만든 캐릭터 상품을 굿즈샵에서 판매했는데, 팀원분들이 정말 좋아하셨어요.\n\n\n\n\n\n심플한 인터페이스 설계\n여러 슬랙봇들을 살펴보았을 때 더 단순하고 심플해야 빠르게 태스크를 수행하겠더라고요. 너무 많은 버튼을 노출한다거나, 설명과 버튼 간 거리가 너무 멀다거나 하는 복잡한 인터페이스는 지양해야 해요. 사용자들은 뭘 눌러야 할지 혼란을 느껴요. \n\n심플한 인터페이스를 설계하려 할 때 PP 리뷰와 UT(사용성 테스트)의 도움을 받았어요. PP 리뷰는 저희 디자인 챕터 내에서 매주 PP(Product Principle)를 잘 지켜서 디자인했는지 서로서로 피드백해 주는 미팅이에요. 내부 제품이다 보니 사용성 테스트도 사용자를 만나기 너무 쉽기 때문에 바로바로 가서 진행하곤 했지요.\n\n\n예를 들어볼게요. 이전에 만들었던 리서치봇의 모양인데요. 왼쪽의 화면을 오른쪽의 화면으로 바꿀 때 PP 리뷰에 들고 가서 피드백을 주고받았었어요. \n\n  \n\n\n\n버튼과 설명이 너무 멀고, 요소가 많다는 피드백을 들었어요. 그래서 아예 버튼에 설명을 넣어서 버튼의 라벨 길이가 조금 길더라도 직관적으로 인지하도록 수정했어요. 당시에 PP 리뷰에서 블록킷 빌더를 켜서 바로 수정한 다음에 이야기 나눴던 기억이 나요. 그리고 바로 사용자분들께 피드백을 들었을 때 더 잘 이해된다고 이야기해주셨어요.\n\n\n직관적인 봇을 만들때 설명적이고 복잡한 라벨을 인지가 쉽게 만들거나 UI를 더 잘 구성하는 방법은 슬랙 이모지를 추가하는 것이기도 해요. 저는 저희 슬랙 워크스페이스에 이모지를 추가해서 UI 구성의 옵션을 블록킷에서 제공하는 것보다 더 다채롭게 구성하기도 했답니다. 설명이 직관적으로 잘 되기도 하고요!\n\n\n슬랙 워크스페이스에 추가한 이모지 일부\n\n이를 활용한 슬랙 메시지 예시\n\n\n사용자 맥락 이해\n어떤 업무 맥락에서 쓰는지도 중요하더라고요. 봇은 용도와 맥락에 따라 디자인되어야 해요. 이를 구분하는 구분자는 “단순 열람인지, 아닌지” 인데요. 이런 구분자에 따라 가독성만 따지면 될지, 버튼과 화면 전환 등 인터랙션이 많이 들어가게 만들어야 할지 등 전반적인 컨셉을 정하게 돼요.\n\n\n\n인터랙션이 많은 봇 제품의 플로우\n\n그리고 업무 맥락과 관련해서 봇을 설정하는 UX를 어떤 환경에 위치시켜야 할지 항상 고민이 되더라고요. 고민하다가 슬랙봇의 상세 세팅은 조금 더 자유도가 높은 웹페이지로 구현했었어요. 복잡한 슬랙봇 설정은 슬랙에서 세팅하게 만드는 것 보다 웹으로 빼는 게 사용자에게 편리하다는 배움이 있었거든요. 구독이나 ON, OFF를 설정하는 단순한 세팅은 봇에서 설정하도록 하지만 그것보다 복잡한건 웹페이지 안에서 설정하도록 했어요.\n\n\n\n\n바깥 고리\n마지막으로 다른 글도 몇 개 첨부합니다. 저는 슬랙 봇을 만들 때 다음 글을 참고했어요.\n\n5 expert hacks to improve your Slackbot UI\n슬랙봇 어디까지 만들어 봤니?\n\n\n\n슬랙봇을 만들기 전에 다음 할 일 리스트를 꼭 해보세요. 더 쉽게 디자인하실 수 있을 거예요.\n\n✅ 슬랙 블록에 대해 이해하고 배운점 내 언어로 정리하기\n\n✅ 슬랙에서 제공하는 블록킷 빌더 써보기\n\n✅ Producthunt나, 슬랙 앱 목록 화면에서 다양한 봇의 모양을 살펴보고 조사하기\n\n✅ 인터페이스 설계하고나면 고객이나 팀원 대상으로 UT 해보기\n\n✅ 사용자 맥락을 이해하고 디자인했는지 한 번 더 점검하기\n\n\n봇은 늘 단순한 UI지만 봇을 만들어가는데 생각보다 고민할 게 많았다는 사실을 새삼스럽게 느끼네요. 이 글은 슬랙에 대해서만 다뤘지만 다른 플랫폼에서 봇을 만들때도 참고해보세요. 디스코드나 팀즈나 봇을 만들 때 구성이나 참고할 부분이 비슷할거로 생각해요. 이 글이 봇을 만들어 가는 여러분들께 조금이나마 도움이 되시길 바라요! ","isDisplayingFeedback":true},{"id":22403,"updatedTime":"2023-08-24T03:13:03+09:00","createdTime":"2023-08-10T17:50:54+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"프로덕트 브랜딩, 어떻게 시작해야할까?","subtitle":"처음 프로덕트 브랜딩 팀이 만들어졌을 때, 어떻게 팀의 정체성을 찾아나갔는지 공유할게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/cover-1st-product-brand-designer.png","videoUrl":null,"backgroundColor":null,"isFill":true,"imageAlt":"프로덕트 브랜딩"},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/cover-1st-product-brand-designer.png","backgroundColor":null,"isFill":true,"imageAlt":"프로덕트 브랜딩"},"key":"product-branding-team","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-08-10T18:15:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22403,"title":null,"description":"처음 프로덕트 브랜딩 팀이 만들어졌을 때, 어떻게 팀의 정체성을 찾아나갔는지 공유할게요.","urlSlug":"product-branding-team","primaryKeyword":{"id":12728,"content":"프로덕트 브랜딩","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":3697,"content":"브랜드 디자이너","wordType":"SEO_KEYWORD"},{"id":12728,"content":"프로덕트 브랜딩","wordType":"SEO_KEYWORD"},{"id":12729,"content":"제품 브랜딩","wordType":"SEO_KEYWORD"},{"id":12731,"content":"토스 브랜딩","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"프로덕트 브랜딩, 어떻게 시작해야할까?","description":"처음 프로덕트 브랜딩 팀이 만들어졌을 때, 어떻게 팀의 정체성을 찾아나갔는지 공유할게요.","backgroundColor":"#424242","imageAlt":"프로덕트 브랜딩","imageUrl":"https://static.toss.im/assets/toss-tech/og-1st-product-brand-designer.png","imageType":"직접입력"},"relatedPostConfig":null,"editor":{"id":1021,"name":"김지윤","slug":"jiyoon-kim","shortDescription":"Product Branding Team Leader","description":"Product Branding Team Leader","imageUrl":"https://static.toss.im/simplicity23/16-logo/jiyoon.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"처음 프로덕트 브랜딩 팀이 만들어졌을 때, 뭐하는 팀인지 스스로도 혼란스러운 시간이 길었어요. 어떻게 팀의 정체성을 만들어나갔는지, 어떤 방황이 있었는지 공유해보려고 해요.\n\n\nQ. 토스 Product Brand Designer는 어떤 일을 하나요?\nBrand Designer와 어떻게 다른가요?\n\n\n제품 ‘안’의 브랜드 경험을 담당하고 있어요.\n토스에는 브랜드 디자이너와 프로덕트 브랜드 디자이너가 있어요. (브랜드 디자이너 인터뷰) 이렇게 분리되기 전에는, 브랜드 디자이너가 맡은 업무 범위가 정말 넓었는데요, 토스 팀원들을 대상으로 하는 인터널 브랜딩, ‘토스’라는 회사를 다루는 기업 브랜딩, 그 외에도 콘텐츠 브랜딩, 채용 브랜딩 등 너무 다양했어요.\n\n\n3년 전 브랜드 디자이너가 해온 일\n업무 범위가 너무 넓다보니 토스 앱에 대한 브랜딩만 몰입해서 다루기가 어려웠어요. 그래서 작년 2월, 토스 앱 안에서의 브랜드 경험만 집중적으로 다루는 프로덕트 브랜딩 팀이 생기게 됐어요.\n\n프로덕트 브랜딩 팀은 토스 앱을 사용하는 분들이 토스를 사랑하고 신뢰할 수 있도록 끈끈한 유대관계를 만드는 일을 해요. 프로덕트 디자이너 분들이 최고의 사용성을 만들고 있다면, 프로덕트 브랜드 디자이너는 제품에 긍정적인 인상과 감정을 만들어내는 역할을 하고 있어요.\n\n\n\nQ. Product Brand Designer의 업무 범위는 어떻게 정하게 됐나요?\n잘 정착되지 않은 직군이다보니 다른 직군처럼 ‘일반적으로 해야 하는 일’이 없잖아요. 어떤 일을 어디까지 해야 하는지도 새로 정해야 했을 것 같아요. 팀에서 무슨 업무를 할지 어떻게 정하셨어요?\n\n브랜드 디자인 팀이 분리될 때 명확하게 업무 범위가 분리 됐어요. 프로덕트 브랜드 디자이너는 제품 안의 모든 것, 브랜드 디자이너는 제품 밖의 모든 것으로 업무 범위가 정해졌거든요. 하지만 워낙 생소한 분야고 레퍼런스가 없다보니 어디서부터 어떻게 시작해야할지 전혀 감을 잡지 못했어요.\n\n\n그래서 브랜드 디자이너가 직접 제품을 만들었어요\n그래픽 디자인, 인터랙션 디자인, UX 라이팅 등은 해당 직군 분들의 노력 끝에 잘 자리잡게 돼서, 팀원 분들이 업무 요청을 원활하게 하고 있는 상황이었어요. “아! 여기 그래픽 필요하니까 그래픽 디자인 팀에 가야겠다!”하는 흐름이 자연스럽게 생긴 거죠.\n\n그런데 저희 팀은 “프로덕트 브랜딩? 인상과 감정을 만든다고? 그게 무슨 소리지?” 이런 낯선 상태니까 요청 해주시는 분들도, 요청 받는 저도 이게 맞나? 싶었어요. 그래서 직접 저희가 생각하는 제품을 만들어보기로 했어요. 브랜드 디자이너로써 UI 디자인을 해오긴 했지만, 진짜 제품을 만들어본 적은 없었거든요.\n\n당시에 토스는 새로운 걸 많이 만들어서 실험적인 이미지는 가지고 있었지만, 세심한 인상을 주려고 노력하진 않았던 것 같아요. 새로운 서비스가 나오면 그냥 푸시 알림으로 알려주는 정도였죠. 그래서 새로운 기능이 만들어지면 이걸 자세하게 설명해주는 기능을 만들어보기로 했어요. 의견 남기기 창구도 만들어서 ‘소통하고 있다’는 인상도 주고, 실제로 많은 사용자 분들이 질문한 것은 답변해드리고요.\n\n\n2022년 4월 새소식 제품 모습\n\n처음엔 정말 많이 헤맸어요. 푸시를 어떻게 보내는지도 몰랐고, 개인정보가 처리되는 서비스를 만들때 동의문을 만들어야한다는 것도, 구독 기능을 만들려면 구독 해지 기능을 만들어야한다는 것도 몰랐죠. 거의 2주 동안은 프로덕트 오너 분들을 만나서 말도 안되는 질문들을 해가면서 성장했던 것 같아요.\n\n\n혼자 공부하던 기록\n제품을 직접 만들고 운영해보니까, 제품을 만들 때 누구에게 어떤 도움을 요청해야하는지 알게 됐어요. UX Writer, 데이터 분석가, 프론트엔드 개발자와 적극적으로 협업하게 된 계기가 되기도 했죠. 제품이 태어나고 성장하는 과정을 겪으면서 전반적인 제품 사이클을 알게 됐고 PO, 프로덕트 디자이너 분들이 어느 시점에 브랜딩이 필요하겠다, 하는 감을 잡을 수 있었어요. 가장 많이 배운 부분은 이미 만들어진 기능에 브랜딩을 입히는 것이 아니라 처음부터 제품을 만들면서 브랜딩을 고려하고, 성장하는 시점에 따라 어떻게 개선해야하는지 판단할 수 있었다는 점이에요.\n\n새소식은 “꼼꼼하게 업데이트 소식을 알려드리면 부지런하고 섬세한 인상을 줄 수 있을 것”이라 생각하고 시작했던 서비스인데요, 서비스를 운영한지 3개월이 지났을 때 의도 했던 반응들이 나오더라고요. 월 평균 1,000개 넘게 사용자 분들이 의견을 보내주셔서 사용자 반응을 확인하고 바로바로 서비스에 반영하기도 했어요.\n\n\n새소식 사용자 의견\n\n새소식 제품의 성장에는 페르소나도 한몫 했어요. 새소식을 소개하는 병아리로 출발했지만 많은 사용자 분들이 좋아해주셔서 이름짓기 이벤트도 열고, 생일파티도 하고, 감사카드를 보냈어요. 프로덕트 브랜딩의 가장 큰 장점은, 정성적으로, 정량적으로 사용자의 반응을 직접 알 수 있다는 점이었어요.\n\n\n새소식 감사카드 / 생일파티 / 이름짓기 이벤트\n\n\n새소식 서비스를 만들면서 생일 축하 기능을 개선해보았고, 같은 팀 유라님과 함께 다양한 제품을 직접 만들어나가기 시작했어요. 특히 시즈널 이벤트 제품들을 다양하게 시도해보고 있어요. \n\n\n2022년 5월 개선했던 생일 축하 기능\n\n이렇게 직접 제품을 만들어보니 어떤 시점에 브랜딩이 필요한지, 제품을 만들 때 어떤 고민이 필요한지 조금 더 뾰족하게 정의할 수 있었어요. 브랜드 디자이너의 관점 보다는 제품 메이커로써의 관점을 가지게 된 것 같아요. 그리고 우리 팀이 집중해야하는 것은 비지니스나 사용성을 넘어서 “사용자가 느끼는 인상과 감정이다” 라는 것을 확신할 수 있었고요. 구체적인 예시가 생기니까 더 많은 사일로에서 협업 요청을 해주셨어요.\n\n\n\n\n\nQ. 첫 3개월 동안 가장 힘들었던 점은 무엇이었나요?\n처음 생긴 직군으로서, 참고할만한 레퍼런스도 없고 함께 일할 팀원도 없어서 힘들었던 점들이 있을 것 같아요.\n\n유라님과 함께 뭐가 제품 브랜딩일지, 우리가 생각하는 좋은 레퍼런스를 토스 안, 토스 밖에서 무작정 찾아서 나열해보기도 했어요. 그냥 이 일을 ‘정의’하는 것 자체가 너무 어려웠던 것 같아요. 그래서 시도했던 것이 책과 논문을 읽는 거였어요. 당연히 그 지식을 100% 실무에 적용하는 건 불가능하지만 책을 읽어서 더 수월하게 정의된 부분도 있어요.\n\n이를테면 <라포>라는 책을 읽고 상반기 목표를 “사용자와 라포쌓기”로 잡은 적이 있어요. 라포(Rapport)는 마음을 기꺼이 열 수 있을 정도의 교감을 의미하는데요, 처음 보는 사람과 가까워지기 위한 전략이 나와있는 책을 읽었어요. 인간관계에 대입하면 너무 당연한 말이잖아요, 오늘 토스라는 사람을 처음 봤는데 이 사람이 계좌 만들라고 하면 의심부터 하게되겠죠. 그래서 사용자와 먼저 가까워지는 게 중요하다고 생각했어요.\n\n\n서로 공유한 자료를 나누고 같이 공부했던 노션\n\n이후에 심리학에 관련된 책과 논문들을 읽고 적극적으로 공유하기 시작했어요. 그러다보니 자연스럽게 저희가 공부한 내용들이 팀원들이 가설을 설정할 때 스며들더라고요.\n\n\n\n\n\nQ. 3개월 동안 했던 일 중에 제일 비효율적인 일은 무엇이었나요?\n처음엔 너무 요청이 없어서 여기저기 팀이 생겼다는 걸 소문냈어요. 그랬더니 다들 찾아와주시긴 했는데, 아직 프로덕트 브랜딩이 정의되지 않은 상태에서 받은 요청 업무는 대부분 관련된 업무가 아니어서 거절하게 됐어요. 새로운 분야의 일은 완벽하진 않더라도 어느 정도 정의된 다음에 알려야한다는 것을 깨달았죠. 팀을 만들고 6개월이 지난 후에는 프로덕트 브랜딩 팀이 하는 일을 디자인 챕터에 자주 알리기 시작했어요. 발표를 참 많이 했던 것 같아요😄\n\n\n\n\n\nQ. 당시의 나에게 해주고 싶은 조언이 있다면요?\n다른 팀원들의 요청이나 협업을 기다리기보다 더 빨리 스스로 제품을 만들어보라고 말해주고 싶어요. 어차피 새로운 분야이기 때문에 아무도 뭐가 정답인지 모르거든요. 제품을 직접 만들면서 배우는 게 훨씬 많았어요. 제가 제품을 만들겠다고 했을 때 그게 ‘사용자를 위한’ 제품이었기 때문에 아무도 뭐라고 하지 않았거든요. 더 용기 있게 도전해봤으면 하는 아쉬움이 있어요.\n\n그리고 책으로 배운 것들도 충분히 실무에 도움이 된다는 것도 말해주고 싶어요. 처음엔 “논문 읽고 온 걸로 실무에 적용하는 게 가능한가?” 하는 스스로에 대한 의심이 있었어요. 근데 이미 수많은 연구자들이 미리 연구해놓은 것들이 많고, 일이 되게 하기 위해서라면 그게 귀납적이든 연역적이든, 책이든 실무이든 상관 없거든요. 수단과 방법을 가리지 말고 자유롭게 방향을 탐색했을 때 더 빨리 답을 찾을 수 있었어요. 지금은 팀의 방향에 힌트가 되는 채널이 정말 다양해요. 책과 논문, 유저 인터뷰, 유저 피드백, 팀내 인터뷰 등 넓게 펼쳐 놓고 방향을 탐색하고 있어요.","isDisplayingFeedback":true},{"id":22205,"updatedTime":"2023-11-15T13:45:55+09:00","createdTime":"2023-07-17T09:26:25+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"토스의 이모지 폰트, 토스페이스 제작기","subtitle":"세계적인 IT 기업에서나 만드는 이모지 폰트를 어떻게 한국 금융 플랫폼 토스에서 만들게 됐을까? 토스의 이모지 폰트, 토스페이스 제작의 모든 것을 공개합니다.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/3d/tossface-part-thumbnail.png","videoUrl":null,"backgroundColor":null,"isFill":true,"imageAlt":"3D 이모지들이 나열된 공간"},"thumbnailConfig":{"imageUrl":"https://static.toss.im/3d/tossface-part-thumbnail.png","backgroundColor":null,"isFill":true,"imageAlt":"3D 이모지들이 나열된 공간"},"key":"22205","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-07-17T12:00:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":22205,"title":null,"description":"세계적인 IT 기업에서나 만드는 이모지 폰트를 어떻게 한국 금융 플랫폼 토스에서 만들게 됐을까? 토스의 이모지 폰트, 토스페이스 제작의 모든 것을 공개합니다.토스페이스는 토스의 그래픽 스타일로 디자인한 이모지 폰트입니다. 이모지 폰트는 문자가 아닌 그림으로 이루어진 독특한 폰트예요. 하...","urlSlug":"22205","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"토스의 이모지 폰트, 토스페이스 제작기","description":"세계적인 IT 기업에서나 만드는 이모지 폰트를 어떻게 한국 금융 플랫폼 토스에서 만들게 됐을까? 토스의 이모지 폰트, 토스페이스 제작의 모든 것을 공개합니다.토스페이스는 토스의 그래픽 스타일로 디자인한 이모지 폰트입니다. 이모지 폰트는 문자가 아닌 그림으로 이루어진 독특한 폰트예요. 하...","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/3d/tossface-part-thumbnail.png","imageType":"썸네일 이미지"},"relatedPostConfig":null,"editor":{"id":590,"name":"고현선","slug":"kohyunsun","shortDescription":"Graphic Designer","description":"토스의 그래픽 디자이너입니다. 토스의 모든 시각 자산을 기획하고 제작합니다.","imageUrl":"https://static.toss.im/assets/toss-tech/koh.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":2,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스는 왜 이모지 폰트를 만들었을까?\n\n토스페이스는 토스의 그래픽 스타일로 디자인한 이모지 폰트입니다. 이모지 폰트는 문자가 아닌 그림 🖼️ 으로 이루어진 독특한 폰트예요. 하나의 유니코드마다 사회적으로 약속된 의미를 표현하고, ttf 형식으로 키보드에서 한 자씩 찍어 사용한다는 점에서 폰트의 형식과 동일하다고 할 수 있습니다. 주로 구글이나 애플같은 세계적인 IT 기업에서 각자의 OS 키보드에 내장하기 위해서 만들고 있죠. 그런 이모지 폰트를 왜 금융 🪙 브랜드인 토스에서 만들게 되었을까요?\n\n\n일관된 시각 경험을 만들기 위해\n\n가장 중요한 이유는 토스 앱에서의 일관된 시각 경험을 위해서예요. 당시 토스 앱에서는 어려운 금융 맥락을 최대한 쉽고 캐주얼하게 보여주기 위해서 제품에 이모지를 자주 활용하고 있었어요. 그런데 모바일 기기의 OS마다 이모지의 보여지는 모습이 다르답니다. iOS에서는 애플 이모지, 안드로이드에서는 삼성 혹은 구글 이모지가 보이기 때문에 디자인의 차이가 생기는 거예요.\n\n\n왼쪽 : 애플 폭죽 이모지, 오른쪽 : 삼성 폭죽 이모지\n🎉 폭죽 이모지를 예시로 들어볼게요. 왼쪽은 애플, 오른쪽은 삼성 이모지인데 똑같은 폭죽 이모지가 OS에 따라 다른 모양으로 보인답니다. 사용자가 어떤 OS를 사용하든 토스 앱 안에서는 같은 시각적 일관성을 경험할 수 있어야 하는데 그렇지 못했어요. 게다가 토스의 UI는 심플한 디자인을 지향하는 반면, OS 이모지는 비교적 설명적이고 볼륨감있는 모습이다보니 이에 따른 이질감도 컸어요.\n\n\n타사 이모지 폰트와 토스페이스의 디자인 비교\n그 밖에 사용자가 OS 업데이트를 자주 하지 않으면 최신 이모지들은 아예 출력이 안 되거나 ❎ 로 뜨는 현상도 발생했어요. 이런 현상은 기기의 업데이트 여부로 발생하는 문제다보니 저희가 직접 해결할 수 있는 부분이 없었죠. 이 것 때문에 폰트가 아닌 이미지로 사용하자니 OS 이모지의 저작권을 침해하는 행위가 되기 때문에 이 역시 근본적인 해결책이 될 수 없었어요.\n\n위와 같은 여러가지 문제를 원천적으로 해결하는 단 하나의 방법은 토스 스타일의 이모지 폰트를 만들어 모든 OS 공통으로 사용한다 였어요. 이 방법이라면 토스 앱 안에서 이모지를 포함한 모든 그래픽 요소를 시각적으로 일관된 경험을 줄 수 있고, 폰트 파일의 업데이트와 적용을 우리 스스로 할 수 있으며 저작권 문제도 없을테니까요. 그렇게 토스에서 3600개 이모지를 만드는 프로젝트를 시작하게 됐어요.\n\n\n3600개 이모지 제작 프로세스\n이모지 스타일 결정하기\n\n하나의 이모지 폰트는 약 3600개의 글립으로 이루어져 있어요. 작업을 시작하기에 앞서 모든 이모지가 하나의 톤으로 보일 수 있도록 전체를 관통하는 기준을 정해야 했어요. 그래야 앞으로 하나 하나 그려나갈 방향을 결정할 수 있기 때문이었죠.\n\n저희는 그 톤에 대한 해답을 이미 우리가 가지고 있는 그래픽 자산에서 찾았어요. 토스 앱 전체에서 그래픽의 90% 이상은 아이콘이 차지하는데요, 토스 아이콘은 기본 도형을 바탕으로 가장 단순한 형태의 솔리드 타입으로 제작돼요. 보통 문자처럼 작게 사용하고, 문자의 직관성을 보조하며, 토스 UI 화면에 조화로운 컬러나 형태로 만든다는 점에서 이모지와 유사한 사용성을 가집니다. 토스의 아이콘 톤을 그대로 계승하면서 3600개의 새로운 메타포가 추가된다면, 강력한 시각적 통일성을 가진 방대한 그래픽 자산이 완성될 수 있겠다는 생각이 들었어요. \n\n\n토스의 아이콘 스타일\n그렇게 기본 도형과 최소한의 묘사를 사용해서 약 100여 개의 Smileys 이모지부터 만들어 나갔어요. 기본 얼굴에서 눈의 크기, 간격, 모서리 라운드, 얼굴 여백의 정도를 변형해가며 어떤 인상이 가장 단순하면서도 호감형인지, 또 제품에 잘 어울리는지 얹어보고 결정한 뒤 같은 방향으로 이어나갔습니다.\n\n\n\n\n모듈 구조로 효율적으로 제작하기\n\n3600개 이모지의 50%를 차지하는 가장 큰 요소는 인물 이모지예요. 인물 이모지의 대부분은 기본이 되는 하나의 얼굴에서 성별, 피부색, 머리카락 등에 변화를 주는 형태로 이루어져 있었어요. 따라서 기본형 얼굴을 먼저 만들고, 다른 요소를 추가하거나 변형하는 형식으로 만든다면 매 번 처음부터 만드는 것보다 훨씬 효율적으로 제작할 수 있겠다는 판단이 되었죠.\n\n얼굴뿐 아니라 몸통이 있는 상반신과 전신 이모지도 같은 방식으로 제작했어요. 기본형 상반신과 전신을 하나씩 만들고 여러 가지 옷과 아이템을 조립해서 전체 인물 이모지를 완성해 나갔어요. 이 모듈 방식은 효율적인 작업을 위해서 선택한 방법이지만, 전체 이모지의 통일성을 지키는 데에도 도움이 되었습니다.\n\n\n\n시각적 통일성 만들기\n\n\n토스페이스는 폰트이므로 시각적 통일성이 매우 중요해요. 그리고 형태적으로 그 노력이 가장 많이 반영된 곳은 바로 ✋ 손 이모지예요.\n\n하나의 이모지 폰트에 약 200개의 손 동작이 있는데, 이 모든 동작이 마치 하나의 손으로부터 만들어진 것처럼 보여야 통일성이 지켜질 수 있겠다고 생각했어요. 손은 형태가 조금만 틀려도 어색해보이기 쉬운 사물이에요. 먼저 손의 형태를 기본 도형만 가지고 그려서 가장 단순하면서도 완성도 높은 형태를 만들어보려고 했어요. 손바닥과 손가락뿐 아니라 접히는 부분과 그림자까지도요. 그리고 나서 나머지 동작들도 손가락과 손바닥의 비율, 두께, 그리고 전체 볼륨과 위치를 계속해서 눈으로 👀 맞춰가며 디자인을 완성해 나갔어요.\n\n\n\n또, 통일성을 위해 신경쓴 부분 중 하나는 이모지가 바라보는 방향이에요. 애플 이모지를 보면 이모지의 시선 방향이 어떤 것은 왼쪽, 어떤 것은 오른쪽으로 되어 있는데 토스페이스는 방향이 있는 이모지는 전부 왼쪽에서 ➡️ 오른쪽을 바라보도록 통일했어요. 그래서 글씨와 이모지가 함께 쓰여 있을 때도 시선이 좌우로 끊기지 않고 한 방향으로 이어지도록 만든 거죠. \n\n\n\n방향을 맞춘 것처럼 각도도 통일했어요. 각도가 있는 사물은 모두 오른쪽 45도 📐 각도를 맞춰서 기울였죠.\n\n\n\n또, 음식 🥘 과 같이 내용물을 보여주기 위해 입체적인 표현이 필요한 이모지도 있는데요, 이 경우에도 모두 동일한 높이에서 바라본 모습으로 제작해서 일관성을 주었어요.\n\n\n\n토스페이스의 모든 이모지는 하나의 컬러 팔레트만 사용해서 만들었는데, 이 컬러팔레트는 흰 배경 ⬜️, 검은 배경 ⬛️ 둘 다 잘 보일 수 있도록 제작되어 디지털 📱 환경에서의 사용성을 최대한으로 높였어요.\n\n\n\n이렇게 완성된 토스페이스는 지금 보시는 이 페이지에 적용되어 있어요. 🥳 토스 앱과 홈페이지에서도 직접 써 보실 수 있습니다.\n\n\n폰트에서 그래픽 유니버스로\n토스페이스의 탄생으로 토스 앱 안에서의 이모지는 어떤 OS든 토스페이스로 보이기 때문에 시각적 일관성을 지킬 수 있을뿐 아니라, OS 이모지의 저작권 문제나 기기 업데이트 여부에 따른 오류 🐛 도 없어졌어요. 이에 더불어, 3600개라는 방대한 양의 그래픽 메타포들이 탄생했어요. 이제 토스에서 어떤 종류의 그래픽을 만들더라도 맨 땅부터 시작하지 않을 수 있게 된 거예요. 즉 토스페이스는 토스 그래픽 디자인의 원석 💎 이라고 할 수 있어요.\n\n\n\n토스페이스는 3D 그래픽으로도 적극적으로 활용되고 있어요. 이모지 폰트인 토스페이스는 디지털 환경에서 작게 사용하는 걸 기준으로 만들었는데, 3D로 만들게 되면 볼륨감과 재질 표현이 가능하기 때문에 핵심적인 화면에 비주얼 임팩트 💫 를 더해줄 수 있어요.\n\n토스뱅크 모임통장이 좋은 예시일 것 같아요. 모임통장은 하나의 계좌를 여러 개의 카드로 여러 명이 공유하는 통장인데요, 이 서비스의 키 비주얼을 3D로 여러 이모지가 모여있는 비주얼로 제작해서 토스 앱, 보도자료, 각종 SNS에 홍보용 그래픽으로 사용했어요. 아래 키 비주얼 제작에는 하루도 걸리지 않았는데, 3D 비주얼을 이렇게 빠르게 만들 수 있는 건 이미 디자인이 완성되어있어 가능했어요. 3D로 만들 때 가장 시간이 오래 걸리는 부분이 형태(모델링)인데 형태에 대한 고민이 폰트화 과정에서 이미 끝났기 때문이에요.\n\n토스페이스가 적용된 토스 화면들\n토스페이스 티저 홈페이지에서도 아래 3D 애니메이션을 키 비주얼로 활용했는데, 카메라와 빛의 움직임까지 더해진 비주얼 임팩트 덕분에 예상보다 훨씬 더 많은 관심과 기대감을 불러일으킬 수 있었어요.\n\n토스페이스 티저 홈페이지 키 비주얼\n처음에는 여러 문제를 해결하기 위한 수단으로 토스페이스를 만들었지만, 이제 폰트를 넘어 토스 그래픽 유니버스 🪐 의 기준으로 자리잡았어요. 그리고 여기에 디자이너들의 상상력 🧚 이 더해지면서, 그 영향력이 무한대로 확장되고 있다는 생각이 들어요.\n\n\n\n\n\n\n앞으로의 토스페이스 \n토스페이스는 오픈소스로 공개되어 있고, 이 글을 보시는 여러분도 무료로 다운받아서 쓸 수 있어요. Github에서 ttf 와 svg 파일로 제공되고 있고, 사용자의 의견을 받아 계속해서 업데이트해나가고 있어요.\n\n이 폰트 파일의 사용자 개인 영역(PUA)에는 저희의 가치관이 담긴 이모지가 몇 가지 추가되어 있어요. 토스는 🇰🇷 한국을 기반으로 하는 앱이기 때문에 소주, 김밥, 붕어빵처럼 한국인에게 정말 친숙한 사물들을 추가해서 우리가 필요할 때 사용할 수 있도록 넣어두었어요. 뿐만 아니라 드론이나 클라우드와 같이, 과거에는 없었던 개념이지만 지금부터 앞으로 범용적으로 사용될 사물이나 개념들도 추가해 두었어요. 토스의 미래지향적 가치관이 담긴 이모지라고 할 수 있어요.\n\n\n저희는 토스라는 브랜드의 시각 경험을 위해서 토스 스타일의 이모지 폰트를 만들었어요. 보통 특정 브랜드를 위한 폰트는 이 측면에서 제작하고 저희도 이미 그 목적은 달성했다고 생각해요. 하지만 더 나아가 오픈 소스로 공개함으로서 좋은 디자인을 더 많은 사람들이 쓸 수 있게 하고, 더 나은 디자인 생태계 🌏 를 만드는 노력으로 이어나가려고 해요. 앞으로 더 많은 사용자들의 피드백을 통해 발전해 나갈 토스페이스를 기대해 주세요! 🚀","isDisplayingFeedback":true},{"id":21962,"updatedTime":"2023-06-20T16:58:07+09:00","createdTime":"2023-06-16T16:00:35+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"토스 최초의 Product Designer(Tools)의 일하는 방식","subtitle":"토스팀에서 첫 Product Designer (Tools) 직무로 일하기 시작하면서 어떤 걸 배웠는지 알려드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/illusts/tools-designer-cover.jpg","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/illusts/tools-designer-cover.jpg","backgroundColor":null,"isFill":true,"imageAlt":null},"key":"1st-product-designer-tools","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-06-20T16:35:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21962,"title":null,"description":"저는 2020년 초부터 토스팀 최초의 Product Designer(Tools)로 일하기 시작했어요. 새 직무를 만들어 가면서 배운 점을 들려드릴게요.Product Designer(Tools)라는 직무가 생소하실 텐데요. 토스에서 기존에 Internal Product Designer라는...","urlSlug":"1st-product-designer-tools","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"토스 최초의 Product Designer(Tools)의 일하는 방식","description":"토스팀에서 첫 Product Designer (Tools) 직무로 일하기 시작하면서 어떤 걸 배웠는지 알려드릴게요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/illusts/1st-product-designer-tools.png","imageType":"직접입력"},"relatedPostConfig":null,"editor":{"id":570,"name":"강영화","slug":"younghwa-kang","shortDescription":"Product Designer(Tools)","description":"_","imageUrl":"https://static.toss.im/illusts/profile-younghwa.jpeg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":4,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"저는 2020년 초부터 토스팀 최초의 Product Designer(Tools)로 일하기 시작했어요. 새 직무를 만들어 가면서 배운 점을 들려드릴게요.\n\n\nProduct Designer(Tools) 직무가 뭐예요?\nProduct Designer(Tools)라는 직무가 생소하실 텐데요. 토스에서 기존에 Internal Product Designer라는 직무명으로 알려져 있어요. 제품 경험을 책임지는 Product Designer 중에서도 업무용 툴을 만드는 일에 집중하고 있어요. 토스 팀원이나 저희 고객들이 업무시간 동안 많은 일을 정확하고 빠르게, 효율적으로 할 수 있도록 돕는 역할이지요. 저희가 만드는 도구를 이용해 업무시간에 하는 불필요한 일을 최대한 줄이고 더 중요한 일에 집중하도록 돕고 있어요. 반복되는 일을 자동화하거나 더 효율적인 워크플로우를 제공해서 사용자가 더 중요한 일에 집중하도록 만드는 것이 이 직무로 일하면서 얻는 보람이에요. ChatGPT 같은 생성 AI의 등장 때문에 업무 효율화에 대해서 공감대가 생겨서 반가운 요즘이에요.\n\n\n저희 직무 팀원들의 자세한 얘기를 보고 싶으시면 Simplicity 23, Simplicity 21의 스토리를 봐주세요.\n\n\n\n\n\n\n사용자의 공감 얻으면서 제품 뜯어고치기 (오지은 님)\n100가지 문제를 한번에 해결하는 방법 (하승주 님)\n3,250개의 요구사항을 해결한 1개의 제품 (윤종구 님)\n우리가 효율적으로 일할 수 있는 이유 (강영화 님)\n\n\n처음 시작한 이야기를 들려주세요.\n‘아, 여기 디자이너 없어서 진짜 큰일났네’\n2020년 초 업무 생산성 담당하는 팀에서 일하면 어떻겠냐는 제안을 받았어요. 최초의 디자이너로 일하는 거죠. 솔직히 매우 빡셀 것 같아서 고민이 되기도 했어요. 하지만 임팩트의 크기가 클 거라고 생각해서 가기로 결정했어요. 제가 낼 수 있는 임팩트의 크기가 0 to 1 단계, 그러니까 아무것도 없는 시작하는 단계에서 극대화될거라고 생각했죠.\n\n팀을 옮기고 처음 일을 시작했는데, 최초의 디자이너로 일하는 일은 생각보다 더 힘들었어요. 일단… PC 환경에서 쓰는 TDS(토스에서 쓰는 디자인 시스템)도 없다시피 하고, 디자이너 1명에 10명의 풀스택 엔지니어가 있는 등, 생각보다도 더 열악한 환경이었어요. 그래서 어떻게 일할지를 정의하는 일을 먼저 했어요. 그러면서 배운 점이 정말 많았어요. 일하는 방식에 대해서 관심을 많이 가지면서 배움이 극대화됐고요.\n\n\n크게는 세 가지를 배웠어요.\n\n기초공사의 중요성\n팀 구성에서 디자이너의 역할\n어떻게 일하는 게 잘 일하는 걸까\n\n기초 공사의 중요성\nTDS를 활용할 수 없는 거의 없다시피한 환경이었어요. TDS 없이 디자인한다는걸 토스 디자이너는 상상조차 하기 어려운데요. 초반에는 디자이너가 없고, 심지어 PC 제품 디자인하는 사람도 전사에 저 혼자였기 때문에 힘들었어요. 디자인 QA도(UI 디자인이 잘 구현됐는지 점검하는 일) 해야 했으니 업무 시간은 부족하고 이걸 왜 해야 하나 현타도 왔어요. 저는 모바일 TDS를 썼던 경험이 있으니, 그것과 자꾸 비교되더라고요. TDS PC의 기초공사를 하는 과정에 참여했어요. \n\n\n\n\n\n그래서 당시 플랫폼 디자이너였던 강수영 님을 찾아갔어요. 수영 님과 원래 있던 없다시피했던 PC 디자인 시스템의 초안을 가지고 어떤 걸 자주 쓰는지, 컴포넌트별로의 최소 요구사항을 정의하고 시스템에 적용하고 제품에 구현하는 걸 시간 내서 진행했어요.\n\n이렇게 기초공사를 한 벌 끝내고 나니까 당연하게도 업무 효율이 늘어났어요. 효율을 높이기 위해는 가장 작은 단위로 쪼개고 그것부터 점검하고 처리해야한다는 걸 적용해 본 시간이었어요. 시스템의 힘을 체감하기도 했고요!\n\n\n\nTDS로 단축한 워크플로우\n\n팀 구성에서 디자이너의 역할\n또, 한 개의 팀이 어떤 구성을 갖춰야 하는지에 대해서도 배웠어요. 업무용 툴도 디자이너의 역할이 매우 중요해요. 보통 회사에서 백앤드만 있는 어드민 제품은 디자이너 없이 PM이나 PO와 엔지니어분들끼리 착수하잖아요? 디자이너 없이 하면 더 빨리 할거로 생각하는 의사결정인 거죠. 그런데 디자이너가 없으면 쉽게 갈 길을 더 돌아가게 되더라고요. \n\n\n디자이너 없이 만든 제품의 모양이 이렇다면,\n\n\n\n디자이너가 처음부터 투입되기 시작하면 이런 도표로 그릴 수 있어요. \n\n\n제가 팀에 합류하기 전 엔지니어분들이 디자이너 없이 만들어 두신 제품과, 디자이너가 투입되고 처음부터 만드는 제품의 걸린 시간을 비교하면 극적으로 달라졌어요. 고객에게 잘 닿으면서도 빨리 만들어냈어요. 사용자에 대한 이해도가 높은 상태로 디자인을 하기 때문에 점점 불필요한 일을 줄이고 사용자들도 만족하는 제품을 내보냈고요. 저와 인터널 팀의 시행착오가 전사에 큰 도움이 된 것 같아요.\n\n\n\n어떻게 일하는 게 잘 일하는 걸까\n시간이 흘러 같은 일을 하는 사람이 두 명이 되면서 2020년 하반기에 직무가 분화된 것으로 기억해요. 직무 자체를 만들어 가는 일, 면접에 참여하는 과정을 통해서도 어떻게 잘 일해야 하는지 배웠어요. 채용 과정에 참여하는 건 면접관에게도 도움이 되는 시간이에요. 우리가 어떤 사람이며, 어떻게 일하며, 어떤 사람과 일하고 싶은지 자꾸 보고 학습하거든요. 혹시 내가 그렇게 일하고 있지 않다면 점검하는 시간이 되기도 하고요. JD(직무 설명)를 여러 번 바꾸면서 어떻게 일해야 하는지 진지하게 고민해보고, 면접 과정에서 그 기준을 다시 생각하며 반복학습 했어요.\n\n\n\n\n\n이 모든 과정은 토스 앱을 만드는 PD 분들이 아닌 우리 직무에 핏한 분을 뽑을 수 있는 채용의 스펙트럼을 만드는 과정이었죠. 확장하고 넓히고, 더 포텐셜을 발견할 수 있는 질문을 넣었어요. 토론하면서 정말 많은 이야기를 나눴던 기억이 생생해요. 이렇게 스펙트럼을 넓히는 설계를 하면서 역설적으로 인재상이 뾰족해지기도 했답니다. \n\n이 과정을 통해 더 많은 분들을 모실 수 있었어요. PD가 인터뷰를 볼 때보다 저희 직무가 직접 인터뷰했을 때 더 깊은 이해도로 채용할 수 있었거든요. \n\n저 한 명이었던 직무는 이제 챕터로 발전했어요. 15명이 넘도록 많아졌기 때문에 더 자주 양질의 배움을 공유하고 있어요. 우리는 도구를 만드는 일을 하는 사람들이잖아요. 그만큼 도구에 대해서 이야기를 많이 나눠요. 서두에도 썼지만 생성 AI가 등장하고 업계 전반에서 일하는 방식에 대해서 이야기를 나누는 트렌드가 생겼는데요. 요새 함께 나눌 이야기 거리가 정말 많아져서 즐거워요. 산업 전반에 정말 많은 변화가 있을 텐데 앞으로 우리에게 어떤 배움이 있을지 기대 되기도 해요.\n\n\n\n당시의 나에게 해주고 싶은 조언이 있다면요?\n“더 자주 물어보고 피드백을 받으면 좋겠어요.”\n제가 처음 몇 개월 동안 가장 실수했던 건 피드백 받는 걸 두려워했던 거예요. \n3년 전으로 돌아간다면 더 자주 피드백 받았을 거에요. 피드백을 자주 받고 빠르게 방향을 수정해서 더 시행착오를 줄이면 좋았겠다는 아쉬움이 있거든요. 피드백 루프가 길어지는 것의 또 다른 단점은 내가 잘하고 있는 점에 대해 피드백 받을 기회도 적어진다는 거예요. 그러면 자기효능감 느낄 기회가 적어져요. 결과적으로 실제 내가 할 수 있는 것보다 퍼포먼스를 못 냈던 것 같아 아쉬워요.\n\n직무든, 프로젝트든 뭐든 처음 하는 건 쉽지 않아요. 근데 처음 하는 일은 “잘”하기 더 어려워요. 하지만 도움을 받기 시작하면 잘하는 상태까지 빠르게 만들 수 있어요. 그리고 예상보다 도움을 주고 싶어 하는 사람들은 많더라고요. 도움을 적극적으로 받기 시작하면서 점점 피드백에 대한 두려움도 없어졌어요.\n\n모르는 길을 헤쳐 나가는 데 두려움이 있으신가요? 동료들과 함께 두려움을 이겨내고 조금씩 앞으로 가면서 성장하는 과정을 함께 밟아가면 좋겠어요. 그러면 그 시간을 커리어에서 잊을 수 없는 날들, 빛나는 순간으로 기억할거예요. 제가 그랬던 것처럼요.\n\n","isDisplayingFeedback":true},{"id":21762,"updatedTime":"2023-05-16T21:08:00+09:00","createdTime":"2023-05-16T21:03:17+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"Simplicity23, 오늘도 문제를 해결하고 있을 모든 디자이너에게","subtitle":"토스 디자인 컨퍼런스 사전 신청 오픈 (5.15~5.21)","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/career-resource/article-cover.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/career-resource/thumnail_simplicity_techblog.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"simplicity23","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-05-15T12:00:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21762,"title":null,"description":"토스 디자인 컨퍼런스가 2년 만에 돌아왔어요. 이번 <Simplicity 23>은 5가지 카테고리로 구성되어 총 23개 세션으로 디자이너 분들을 찾아갈 예정이에요. 토스팀이 어떤 마음으로 이번 컨퍼런스를 준비했는지 들려드릴게요. 사전신청 바로가기(링크)<Simplicity 23>는 멋진...","urlSlug":"simplicity23","primaryKeyword":{"id":11719,"content":"토스디자인","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":11715,"content":"토스심플리시티","wordType":"SEO_KEYWORD"},{"id":11717,"content":"토스디자인컨퍼런스","wordType":"SEO_KEYWORD"},{"id":11720,"content":"simplicity23","wordType":"SEO_KEYWORD"},{"id":11722,"content":"토스simplicity","wordType":"SEO_KEYWORD"},{"id":11763,"content":"토스컨퍼런스","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"Simplicity23, 오늘도 문제를 해결하고 있을 모든 디자이너에게","description":"토스 디자인 컨퍼런스가 2년 만에 돌아왔어요. 이번 <Simplicity 23>은 5가지 카테고리로 구성되어 총 23개 세션으로 디자이너 분들을 찾아갈 예정이에요. 토스팀이 어떤 마음으로 이번 컨퍼런스를 준비했는지 들려드릴게요. 사전신청 바로가기(링크)<Simplicity 23>는 멋진...","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/career-resource/article-cover.png","imageType":"커버 이미지"},"relatedPostConfig":null,"editor":{"id":566,"name":"정희연","slug":"heeyeun-jung","shortDescription":"Head of UX","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/heeyeun-jung.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":2,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스 디자인 컨퍼런스가 2년 만에 돌아왔어요. 이번 <Simplicity 23>은 5가지 카테고리로 구성되어 총 23개 세션으로 디자이너 분들을 찾아갈 예정이에요. 토스팀이 어떤 마음으로 이번 컨퍼런스를 준비했는지 들려드릴게요. 사전신청 바로가기(링크)\n\n멋진 성과가 아니라 과정 중심의 이야기\n<Simplicity 23>는 멋진 디자인 결과물, 뛰어난 성취를 다루지 않아요. 문제를 해결하며 겪었던 지난하고 힘든 과정 자체를 담았거든요.  지난 <Simplicity21>에서는 디자인의 구체적인 과정과 소통에 대해 더 들어보고 싶다는 의견이 있었어요. 이번 컨퍼런스는 디자이너 개인 혹은 대단한 성과 보다는 우리가 어떻게 생각했고 문제를 해결해나가는지 보여드리고자 해요.\n\n디자이너가 들려주는 솔직한 이야기\n지난 심플리시티와 다르게 이번 컨퍼런스는 담백하게 디자이너 분들과 이야기를 나누는 과정을 그대로 담았어요. 멋진 화면 대신 목소리와 이야기에 집중할 수 있도록 말이죠. 카메라에 보이는 모습에 신경 쓰기 보다는 디자이너 분들과 더 친숙하고 친밀하게 다가가는 지점에 신경을 썼어요. \n\n디자이너라면 공감할 만한 문제 상황\n토스팀의 디자이너가 겪는 문제는 대단하고 특별한 게 아니에요. 디자이너 분들이 겪는 상황을 토스팀도 겪고 있죠. 보편적인 문제 해결법, 간단한 사고의 전환, 태도의 전환으로 이뤄낼 수 있는 방법들을 담았어요.\n\n23개의 세션에는 UX 리서처, UX 라이터, 인터렉션 디자이너, 브랜드 디자이너, 프로덕트 디자이너, 하드웨어 디자이너가 참여했고 5가지 문제 상황으로 구성되어 있어요. 세션 자세히 보기(링크)\n\n🌒 미지의 영역에 도전할 때\n어디서 실마리를 찾아야 할지 도저히 알 수 없는 문제를 만난 적이 있나요?\n아무도 가보지 않은 길을 걸을 때 어떻게 앞으로 나아갔는지 알려드릴게요.\n\n\n❤️ 가치에 공감하게 만드는 방법\n팀원들이 중요한 가치를 공감해주지 않을 때 어떻게 해야 할까요?\n가치를 설득하고 문화를 만들어나가는 방법에 대해 알려드릴게요.\n\n\n🔎 사용자에게 더 가까이\n디자이너는 사용자 경험을 만드는 사람들이지만 막상 사용자를 이해하기 어려울 때가 있지 않나요?\n사용자에게 더 가까이 다가가 문제를 해결하는 방법에 대해 알려드릴게요.\n\n\n🧶 꼬인 매듭 풀기\n너무 많은 이해관계자와 레거시 때문에 해결책으로 나아가기 버거울 때가 있어요.\n꼬인 매듭을 풀어내고 솔루션에 가까워지는 법을 알려드릴게요.\n\n\n⏳ 수많은 시도가 필요할 때\n최선의 결과물을 내기까지 수많은 실험이 반복되죠. \n실패를 통해 배우는 과정, 빠르게 이터레이션 하는 과정을 알려드릴게요.\n\n\n\n토스 디자인 챕터의 현재\n토스 디자인 조직은 프로덕트 디자이너, UX 플랫폼 트라이브에 소속된 디자이너로 나뉘어 있어요. 프로덕트 디자이너는 각 사일로에 소속돼요. UX 플랫폼 트라이브는 그래픽 디자인 팀, 프로덕트 브랜딩 팀, 인터렉션 팀, 모바일 플랫폼 팀, UX 라이팅 팀 등 다양한 팀이 포함되어 있고요. UX 플랫폼 트라이브는 프로덕트 디자이너가 최고의 퍼포먼스로 일할 수 있도록 지원하고, 프로덕트 디자이너는 제품의 최전선에서 사용자 경험을 만들어나가는 역할을 하고 있어요.\n\n\n프로덕트 디자이너는 오직 ‘사용자의 문제를 해결하는 것’에만 집중할 수 있는 환경이 조성되어 있어요. 반면 UX 플랫폼 트라이브는 자신의 전문 영역에 대해서만 고민할 수 있다는 게 장점이에요. 예를 들어 그래픽 디자이너라면 ‘가장 매력적이고 효과적인 그래픽은 무엇일까?’는 관점에서 고민하고, 인터렉션 디자이너는 ‘어떻게 인터렉션을 제품 안에 탁월하게 구현할 수 있을까?’와 같은 고민에 몰입할 수 있죠.\n\n각자의 전문성을 고도화하고 있기 때문에 함께 일하고 성장하는 환경 안에 있어요.\n\n함께 헤매고, 함께 앞으로 나아가기 위해\n디자인 업계의 성장은 토스 디자인 챕터의 성장과 별개의 문제가 아니에요. 전체 디자이너의 토양이 성장해야 토스의 디자이너도 성장할 수 있고, 토스 디자이너 성장이 IT업계의 성장에 도움이 될 수 있다고 생각해요. 서로의 배움을 공유하는 선순환 구조를 만들고 싶어요. 토스팀 디자이너가 헤매면서 깨달은 것과 실패하며 쌓은 업무 노하우를 공유하는 시간이 되었으면 좋겠어요. \n\n오늘도 문제를 해결하고 있을 디자이너 분들을 위해 ‘내 고민 말하기‘를 기획했어요. 요즘 가장 고민하고 있는 게 뭔지 선택하면, 여러분의 상황에 맞는 공감과 응원을 드리고 싶었어요. 디자이너라면 연차와 직무에 따라 고민이 달라질텐데요, 토스팀의 디자이너들은 어떤 고민을 했고, 어떻게 헤쳐나갔는지 여러분의 고민에 가까운 Simplicity 세션을 추천해드려요. ‘내 고민 말하기’를 통해 토스 디자이너들이 답을 향해 나아가는 길을 엿보실 수 있을 거예요.\n\n오늘도 문제를 해결하고 있을 여러분의 고민은 무엇인가요? 함께 고민하고, 함께 성장해요. 내 고민 말하기(링크)\n\n\n모든 디자이너에게 영감과 응원이 되기를\n많은 디자이너 분들이 ‘이걸 어떻게 풀어야 할까?’ 고민에 빠져있잖아요. 이럴 때 보통 기발한 아이디어, 대단한 발견을 기대하는 것 같아요. 창의적인 어떤 답이 하늘에서 갑자기 떨어지기를. 근데 그런 일은 잘 없고 결국 평범하고 당연한 해결책이 정답일 때가 많죠. \n\n답을 찾아가는 여정에서 고민의 시간이 얼마나 길었는지, 고민의 깊이는 얼마나 깊었는지 중요하지 않아요. 고민에 대한 답을 빨리 찾게 하는 원동력은 그 문제를 풀 수 있는 힘이 나에게 있다는 믿음이라고 생각해요.\n\n‘이건 내가 해결 못해’, ‘너무 오래 붙잡고 있었어’, ‘이건 원래 안 되는 거야’라고 생각하면 진짜 안되거든요. 좌절의 눈이 아니라 호기심의 눈으로 바라봤을 때 의외로 쉽게 풀려서 너무 허무할 때도 있을 거예요. 답은 언젠가 찾게 되고 답은 굉장히 평범한 것일 수 있어요. ‘답이 어디에 있을까?’라는 호기심의 관점으로 문제를 바라봐주세요.\n\n평범한 답에서 만들어지는 변화\n어떻게 보면 <Simplicity23>은 평범한 내용일 수 있어요. 듣다 보면 ‘이렇게 기발한 생각을 하는 디자이너가 있다고?’와 같은 기대감을 채우지 못할 수도 있어요. 그럼에도 답을 찾을 수 있다는 믿음으로 결국 답을 찾아낸 과정을 들려드릴게요. 부디 마음껏 즐겨주세요. 사전신청 바로가기(링크)\n\n\nWriter 정희연 김지윤 Edit 김이서","isDisplayingFeedback":true},{"id":21555,"updatedTime":"2023-05-04T10:49:01+09:00","createdTime":"2023-05-04T00:40:59+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"첫 인터랙션 디자이너가 문제를 해결하는 법","subtitle":"처음 입사했을 때 인터랙션 디자이너의 역할에 대해 막연하게 느꼈을 때가 있었어요. 하지만 제품의 문제를 하나씩 해결하면서 저의 역할을 정의해나갈 수 있었어요. 어떤 시행착오가 있었는지 공유해 드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/cover-1st-interactiondesigner.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/cover-1st-interactiondesigner.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"1st_interaction_designer","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-05-04T19:48:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21555,"title":null,"description":"처음 입사했을 때 인터랙션 디자이너의 역할에 대해 막연하게 느꼈을 때가 있었어요. 하지만 제품의 문제를 하나씩 해결하면서 저의 역할을 정의해나갈 수 있었어요. 어떤 시행착오가 있었는지 공유해 드릴게요.","urlSlug":"1st_interaction_designer","primaryKeyword":{"id":11637,"content":"인터랙션 디자인","wordType":"SEO_KEYWORD"},"relatedKeywords":[],"tags":[]},"openGraph":{"title":"첫 인터랙션 디자이너가 문제를 해결하는 법","description":"처음 입사했을 때 인터랙션 디자이너의 역할에 대해 막연하게 느꼈을 때가 있었어요. 하지만 제품의 문제를 하나씩 해결하면서 저의 역할을 정의해나갈 수 있었어요. 어떤 시행착오가 있었는지 공유해 드릴게요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/toss-tech/thumnail-1st-interactiondesigner.png","imageType":"직접입력"},"relatedPostConfig":{"id":2716,"relatedPosts":[{"id":21013,"updatedTime":"2023-04-14T11:58:27+09:00","createdTime":"2023-04-12T16:02:08+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"직접 만지고, 돌리는 토스뱅크카드 인터랙션","subtitle":"토스뱅크카드의 중요한 디자인 컨셉은 앞면과 뒷면의 색상이 다르다는 것인데요. 지금까지는 이 정보를 표현하기 위해서 이미지를 두 장 쓰거나, 영상을 만들었죠. 하지만 그걸로는 부족했어요. 저는 모바일 화면에서도 실물 카드를 보는 것과 똑같은 경험을 만들고 싶었어요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/11/DesignTech-0-img.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/11/DesignTech-0-img.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"touch-and-turn-tossbankcard","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-11-24T19:16:25+09:00","commentBoard":null,"disclaimer":null}],"title":"연관 콘텐츠"},"editor":{"id":565,"name":"김지혜","slug":"jihye-kim","shortDescription":"Interaction Designer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/jihye-kim.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":2,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스 Interaction Designer는 어떤 일을 하나요?\n다른 회사의 Interaction Designer와 어떻게 다른지, 토스 팀만의 강점이 궁금해요.\n\n\n토스 제품의 인터랙션을 담당하고 있어요.\n사용자들이 앱을 더 편리하게 사용할 수 있도록 화면을 개선하는 일을 해요. 전반적으로 인터랙션의 퀄리티가 높아질 수 있도록 시스템을 만드는 일도 하고요.\n\n저희 팀의 강점은 인터랙션 디자이너가 직접 제품의 문제를 찾아 개선할 수 있다는 점이에요. 보통 회사에서는 인터랙션 디자이너가 프로젝트 후반에 참여해서 모션 작업을 주로 맡게 되는데요. 저희는 플로우 단위로 제품을 개선할 수 있다 보니 역할 성장의 기회가 많다고 생각해요. 그리고 팀 내에 개발자들이 소속되어있어서 디자이너가 연구한 인터랙션을 바로 구현까지 해볼 수 있죠.\n\n\n\n\n\nInteraction Designer의 업무 범위는 어떻게 정하게 됐나요?\n잘 정착되지 않은 직군이다보니 다른 직군처럼 ‘일반적으로 해야 하는 일’이 없잖아요. 어떤 일을 어디까지 해야 하는지도 새로 정해야 했을 것 같아요. 팀에서 무슨 업무를 할지 어떻게 정하셨어요? \n\n\nInteraction Designer직군이 토스 앱을 만드는 여러 직군과 접점이 많다 보니 업무 범위를 구분 짓기까지 오랜 시간이 걸렸던 것 같아요. 저는 이 부분을 스스로 정의하기 위해서 2가지 시도했었는데요.\n\n인터랙션으로 사용성 문제를 해결하는 사례를 만들었어요.\n먼저, 토스 앱에서 인터랙션으로 해결해보면 좋을 화면들을 찾아 개선했어요. 그리고 AB 테스트를 통해 실제로 지표의 변화를 만들어내는지 검증했고, 수많은 실패와 성공 사례를 쌓았어요.\n\n그 사례로 대출 가심사의 로딩 화면을 개선했던 프로젝트를 설명해 드리면 좋을 것 같은데요. 기존에는 2~30초의 심사 시간 동안 실제 정보와 상관없는 이미지가 반복되어 나오는 화면이었어요. ‘로딩 화면에서 실제 정보를 보여줘서 이탈을 줄이면, 더 많은 사용자가 대출 실행을 하게 될 것이다’라는 가설을 세웠고 실시간으로 심사 완료된 정보가 화면에 보이도록 개선했어요. 이러한 인터랙션의 개선을 통해, 이탈률을 소폭 개선하는 효과를 만들었죠. \n\n\n대출 가심사를 받을 때 로딩 화면 - 기존안(왼)과 개선안(오)\n\n\n심미성이 중요한 화면을 만들었어요.\n그다음으로, 유저에게 즐거움을 줘야 할 때, 시각적인 완성도를 높여야 할 때 인터랙션 디자인이 필요하다는 것에 대해서는 팀원들의 공감대가 있었어요. 그래서 자연스럽게 심미적인 가치를 높여줘야 하는 업무는 제가 맡아서 진행하게 되었어요.\n\n예를 들어, 추석 편지를 보내는 이벤트에서 편지를 보냈다는 심상을 강조하기 위해 편지가 날아가는 모션을 추가했어요. 장애인의 날 이벤트에서는 모바일에서 점자를 눌러보는 경험을 극대화하기 위해 사용자가 클릭하면 모션으로 피드백을 주고, 화면이 밝아지는 시각 효과 등을 주었죠. 이런 부분을 언급하는 사용자도 점점 생기고 있는 걸 보면 이런 영역들이 인터랙션의 중요한 가치 중 하나라고 느껴져요.\n\n\n추석 편지 이벤트, 크리스마스 이벤트, 장애인의날 이벤트 중 일부\n\n장애인의날 이벤트를 경험하신 사용자 분들의 소중한 의견\n\n\n\n\n첫 3개월 동안 가장 힘들었던 점은 무엇이었나요?\n처음 생긴 직군으로서, 참고할만한 레퍼런스도 없고 함께 일할 팀원도 없어서 힘들었던 점들이 있을 것 같아요. \n\n\n방금 말했던 것처럼 저의 업무 범위를 정하는 것이 가장 힘들었어요. \n처음엔 그래픽 디자이너, 리서치, 라이터처럼 요청 채널을 만들었는데요. 당시에는 나를 찾아오신 분들이니 무조건 최선을 다해보자! 는 태도로 디자이너분들이 요청하신 업무를 했어요.\n\n그러다가 이 일을 내가 하는 것이 맞을까? 내가 잘할 수 있는 일일까? 싶은 순간이 있었는데요. \n\n예를 들어 인터랙션 요청 중에 로띠 애니메이션이나 그래픽으로 제작해 해결할 수 있는 경우가 많았어요. 간단한 2D 모션은 제가 만들곤 했지만, 그래픽 자산의 일관성과 퀄리티 측면에서 제가 부분적으로 만드는 것보다 그래픽 디자이너분들에게 요청 드리는 게 좋겠다고 생각하게 됐어요. 이후에 관련 업무가 들어오면 더는 제가 맡지 않게 되었어요.\n\n\n2021년 당시 만든 로딩 애니메이션\n\n2021년 당시 개편된 홈을 소개하는 화면\n경태님과 협업했던 작업\n\n\n\n\n첫 3개월 동안 했던 가장 큰 실수는 무엇이었나요?\n물론 그런 일들이 있었기 때문에 지금도 있는 것이겠지만, 돌이켜봤을 때 ‘정말 바보 같았다’는 생각이 드는 일이 있나요? 새롭게 첫 직군을 시작하는 분들께 좋은 조언이 될 수도 있을 것 같아요. \n\n\n사일로의 상황을 고려하지 않고 작업했던 거예요.\n토스 팀은 빠른 속도로 제품을 개선하다 보니 공수를 줄이거나 디자인 스펙을 줄이는 게 필수적인데요. 입사 초반에는 이런 상황을 몰라서 ‘나를 증명해야 해, 최대한 창의적으로 그려보자’라는 생각으로 풀스펙으로 디자인하거나, 지금 구조에서 구현하기 어려운 방식의 디자인을 했어요.\n\n열심히 만든 디자인의 퀄리티를 낮춰야 하는 경우도 있었고, 개발자분들에게 당황스러움을 선사하고는 했어요. \n\n만약 과거로 돌아간다면, 사일로와 실험의 가설에 대해 충분히 협의한 뒤 최소한의 리소스로 디자인을 했을 것 같아요. 그리고 개발자와 사전에 이런 방식의 아이디어를 구현할 수 있는지, 현재의 일정과 상황에서 구현할 수 있는 범위에 대해 여쭤본 뒤 디자인을 했을 것 같아요.\n\n\n\n\n\n3개월 동안 했던 일 중 가장 비효율적인 일이 있다면 무엇인가요?\n첫 직군이다 보니 처음부터 지금처럼 체계가 잘 갖춰져있지는 않았을 것 같거든요. 당연히 처음에는 비효율적으로 일하기도 했을 것 같은데 ‘나 이것까지 해봤다’하는 비효율 사례가 있을까요?\n\n\n노션에 멋지게 정리하기\n인터랙션 디자인의 사례를 모아 쇼케이스를 만들었던 일이 가장 비효율적이었던 것 같아요. Mobbin에서 리서치를 하듯이 토스의 인터랙션 사례들을 모아두면 저를 알리는 데에 도움이 될거라고 생각했어요. 인터랙션 101이라는 이름으로 101개의 사례를 모으는 걸 목표로 노션에 태그도 달면서 열심히 정리했는데요. 6개월 정도 했나…고작 20개밖에 못 채운 걸 알고 현실을 깨닫게 됐어요.\n\n숫자를 다 채우려면 너무 오래 걸리고, 접근성도 떨어지다 보니 저도 잘 안 보게 되더라고요. 노션으로 멋지게 정리하는 것 대신 저의 작업물을 짧게 정리해서 슬랙에 공유하게 되었고 이런 식의 공유가 훨씬 도달이 잘 되는 걸 느꼈어요.\n\n\n과거에 만들었던 인터랙션 101 노션\n\n\n\n\n처음 입사한 당시의 나에게 해주고 싶은 조언이 있다면요?\n\n불안함을 건강한 동기부여로 받아들이기\n처음 입사했을 때 이 직군이 토스 팀에 처음 생겼고, 업계에 많지 않다 보니까 미지의 영역이라고 막연하게만 느꼈어요. 어디까지가 나의 역할인지, 나의 강점은 무엇인지 찾기까지 제법 오랜 시간이 걸렸는데요.\n\n불안함에 힘든 시간도 많았던 것 같은데, 돌아와서 보니 제가 성장할 수 있도록 동기부여가 가득한 환경이었다는 생각이 들더라고요. 토스 제품에 없던 가치를 만들 수 있고 개선할 것들이 너무나 많았으니까요.\n\n그래서 저에게 미지의 영역을 좋은 동기부여로 받아들이고, 도전해보라고 말해주고 싶어요.","isDisplayingFeedback":true},{"id":21480,"updatedTime":"2023-04-27T20:28:04+09:00","createdTime":"2023-04-27T11:50:53+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"리서치를 하고 싶어하는 사람을 리서치하세요","subtitle":"입사하자마자 사용자가 아닌 동료들부터 인터뷰했던 이유. 토스의 첫 UX 리서처로 자리잡아 갔던 과정을 소개할게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/research_main.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/research_main.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"1st_ux_research","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-04-27T20:25:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21480,"title":null,"description":"입사하자마자 사용자가 아닌 동료들부터 인터뷰했던 이유. 토스의 첫 UX 리서처로 자리잡아 갔던 과정을 소개할게요.","urlSlug":"1st_ux_research","primaryKeyword":{"id":4054,"content":"UX 리서처","wordType":"SEO_KEYWORD"},"relatedKeywords":[],"tags":[]},"openGraph":{"title":"리서치를 하고 싶어하는 사람을 리서치하세요","description":"입사하자마자 사용자가 아닌 동료들부터 인터뷰했던 이유. 토스의 첫 UX 리서처로 자리잡아 갔던 과정을 소개할게요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/toss-tech/research_og.png","imageType":"직접입력"},"relatedPostConfig":null,"editor":{"id":594,"name":"김서연","slug":null,"shortDescription":"UX Researcher","description":null,"imageUrl":"https://static.toss.im/photos/seyonkim.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스 UX Researcher는 어떤 일을 하나요?\n제품을 만드는 모든 팀에서 사용자에 대한 고민이 생기면 고민을 같이 풀어나가는 일을 해요. \n예를 들어, “잘 쓸 줄 알고 열심히 만들었는데, 사람들이 왜 안 쓸까요?” 같은 질문이기도 하고요. “사장님의 불편을 해소하는 제품을 만들고 싶은데, 어디서부터 시작해야 할까요?” 같은 질문이기도 해요. \n\n제품 팀이 가지고 있는 사용자에 대한 막연한 고민을 초반부터 같이 싱크해나가면서, 고민에 대한 답이 되는 인사이트를 도출할 수 있도록 그에 맞는 리서치 방향을 제시하고 진행하는 일을 해요.\n\n\nUX Researcher의 업무 범위는 어떻게 정하게 됐나요?\n혼자서 다 하기보다는 팀원들을 자연스럽게 참여시켰어요.\n초반엔 제가 유일한 리서처로 입사했으니 ‘리서치의 A-Z까지 다 끝낸 뒤에 결과만 공유해야지’라는 생각이 있었어요. 그래서 혼자 인터뷰를 진행하고 정리하고 있었는데, 어떤 분이 지나가면서 진행되고 있는 리서치는 어디서 볼 수 있냐고 물어보시더라고요. \n\n그래서 진행 상황도 궁금하겠구나 싶어 일단 슬랙 채널을 만들어서 진행 중인 인터뷰의 내용을 요약해서 올려보았죠. 그랬더니 웬걸, 스레드에서 많은 질문과 대화가 일어나기 시작했어요.\n\n\n“이 유저분은 왜 이렇게 말씀하셨을까요?” \n“이 부분을 오해하신 거라면 우리가 고쳐봐야겠네요” \n“이렇게 토스에 신뢰가 아직 없는 분은 어떻게 모셔 올 수 있을까요?”\n\n \n\n이렇게 스레드에 달리는 대화가 곧 팀원들의 피드백이자 인풋이었던 것 같아요. 또, 인터뷰 하다가 나온 앱의 개선점을 따로 정리해서 전달하지 않아도 채널에 캐주얼하게 올리면 즉각적으로 대응해 주시는 것을 보고 감동하기도 했었어요.\n\n\n\n\n활발한 슬랙 스레드\n\n\n토스앱에 첫 가입하는 순간인데 이벤트 성공 문자메시지로 가입환영 메시지가 가려진 상황\n\n올린 그날 바로 이슈 해결\n\n사실 토스에 입사하기 전에는 이렇게 유저 한분한분의 상세한 내용을 공유한 적은 없었어요. 주로 여러 유저 인터뷰가 끝난 후 분석하고 정리해서 결과만 공유했었죠. 그러다가 토스에서 다들 유저 리서치에 관심이 많아서 디테일한 내용을 채널에 공유하고 의견 교류하기 시작했는데, 이때 유저 리서치는 리서처만의 업무라는 성역 같은 인식보다는 유저 리서치에 당연하게 참여하는 문화가 만들어진 것 같아요. \n\n저에게도 큰 소득이었던 게, 초반에 이렇게 스레드에서 활발히 의견 교류하는 문화를 통해 팀원들이 유저에 대해 갖고 있는 컨센선스를 빠르게 파악할 수 있었어요. 이 이후로 모든 UT나 인터뷰에 그 제품 메이커는 거의 당연히 참여하고, 의견을 주고받고, 같이 방향을 설정하며 협업하고 있어요. \n\n\n토스팀에 입사하자마자 무작정 승건님을 포함한 여러 동료분을 인터뷰했어요. \n에이전시에서 일했을 때 프로젝트를 하나 시작하면 그 프로젝트에서 기대하는 바를 듣는 자리가 있는데, 이 자리를 이해관계자 인터뷰(Stakeholder Interview)라고 해요. 이걸 하고 안 하고에 따라 프로젝트 이해도의 차이가 크게 날 수 있거든요. \n\n그래서 리서처를 채용한 기대치를 파악하기 위한 목적으로 당시 제가 속했던 디자인 플랫폼팀, 사일로 팀원분들, 승건님을 가장 먼저 인터뷰했어요. 이분들이 리서처의 업무 범위를 알려줄 순 없었지만, 적어도 현재 토스팀에서 궁금해하는 것들, 유저에 대해 모른다고 느끼는 영역들, 사일로에서 가지고 있는 고민을 파악할 수 있었어요. 이런 고민에 대해 부딪혀 보면서 업무 범위를 파악해 가야겠다고 생각했어요.\n\n예를 들면 승건님 인터뷰를 통해서는 당시 토스팀에서 ‘3040’ 사용자에 관심이 많다는 것을 알게 되어 그 사용자분들을 무작정 만나본 적이 있어요. 당시 토스를 사용하는 가장 많은 연령층이 20대였는데요. 연령대가 높아질수록 가입자 비율이 낮아지는 현상을 보였죠. 그래서 몇몇 분들을 만나 인터뷰를 해보고 주요한 유저들의 목소리를 팀에 공유했는데, 한 사용자분의 사례에서 팀원들의 충격이 엄청났어요. \n\n그분은 아예 토스에서 송금이 된다는 사실조차 모르고 계셨던 거예요. \n\n이제 막 토스에 입사한 저에게는 그렇게까지 충격은 아니었는데, 간편송금을 시작으로 열심히 제품을 만들어 나가던 토스 팀원들에게는 큰 충격이었죠. 전혀 몰랐던 사용자의 시각을 알게 되는 계기가 되었던 것 같아요. \n\n특히 저는 토스팀은 정량적인 분석을 많이 하는 조직이라서 정량적으로 의미 있는 숫자에만 반응할 거라고 막연히 생각했었는데, 한두 사용자의 의견이더라도 임팩트를 줄 수 있다는 것을 깨닫게 됐어요. 그 후부터 리서처에게 자연히 “제공자 관점에서 놓치고 있는 유저의 시각과 페인포인트를 전파하는”역할을 기대하게 되었던 것 같아요. \n\n\n\n첫 3개월 동안 가장 힘들었던 점은 무엇이었나요?\n말을 많이 하는 직업인데, 말을 아껴야 했어요.\n리서처는 사실 할 말이 되게 많은 직군이에요. 유저에 대한 맥락부터 디테일, 그 안에서 중요한 사항이 뭔지, 왜 이걸 중요하게 봐야 하는지 등등 결론에 이르기까지 전달해야 할 정보가 되게 많아요. 그래서 저는 보고자료 만드는 게 익숙한 사람이었어요.\n\n그런데 토스팀은 보고도 없고 메일도 없고 슬랙으로 빠르게 티키타카 하며 커뮤니케이션하는 팀인 거예요. 유저 리서치를 마치고 결론을 정리하려는데, 이전에 하던 대로 중요하다고 생각하는 내용을 전부 썼다간 스크롤 압박이 될 게 뻔했어요. \n\n특히 위에서 소개한 3040 유저 인터뷰 내용을 공유할 때인데요. 이때도 이전에 하던 대로 20장이 넘는 장표를 일단 작성했어요. 그리고 뭔가 허전한 것 같아서 장표 초반에 이목을 끌고자 유저분이 말씀하신 영상의 일부분을 편집해서(그것이 알고 싶다 같은 컨셉) 팀원들 앞에서 틀고 그 이후부터 장표 발표를 시작했는데요. 모두 영상밖에 기억하지 못하는 거예요. \n\n이때는 혹시 너무 자극적인 voc에 집중하게 만든 게 아닌가 싶기도 했었는데, 지나고 생각해 보니 내가 전달하고자 하는 사람들에게 어떻게 해야 내용이 잘 전달될지 고민하는 것은 당연한 것이더라고요. 인사이트를 잘 도출해내는 것도 중요하지만, 인사이트를 잘 수용할 수 있는 방식으로 전달하는 것도 리서처의 중요한 역량이라는 것을 깨달았어요.\n\n\n\n\n\n\n첫 3개월 동안 했던 가장 큰 실수는 무엇이었나요?\n아무도 안 볼 리서치 가이드라인을 열심히 만들었어요.\n토스도 UX 리서처가 처음이었지만 저도 UX 리서처는 처음이어서, 일반적으로 인하우스의 리서처가 어디까지 업무하는지 사실 잘 몰랐어요. \n\n그 당시 JD에 “토스팀에 리서치를 교육하고 전파해야 한다”는 내용이 있었던 게 기억나요. 그래서 그 기억으로 일단 입사하자마자 리서치를 어떻게 해야 하는지 리서치 가이드라인이 필요하겠다고 생각하고 마구 노션에 써 내려갔어요. \n\n기존의 에이전시에서 리서치를 해봤던 경험이 있으니, 가이드라인에 필요한 건 비슷하겠거니 생각하고 뭐라도 빨리 뽑아서 성과를 내고 싶었던 마음이 컸었나 봐요. \n\n\n(아무도 인터뷰 하겠다고 안 찾아왔는데 허겁지겁 만든) 인터뷰 가이드라인\n지금 생각해 보면 정말 쓸데없던 일이었던 게, 리서치를 하겠다고 저한테 문의하는 사람이 아무도 없는데 가이드라인을 열심히 작성한 거예요. \n\n사실 UX 리서치가 당시 꽤 생소한 분야고, UX 리서처를 채용했다는 사실을 다 알지조차 못했을 거예요. 그래서 이 생소한 분야를 가이드라인으로 내가 알려야겠다! 라고 생각했는데, 토스팀에서 조금만 지내보고 나니 말도 안 되는 생각이었다는 걸 알게 됐죠. 문서 먼저 읽어보라고 하면 아무도 안 읽을 것이라는 걸요. \n\n유저를 알고 싶어 하는 사일로를 찾아가서 같이 유저를 만나보고, 리서치를 통해 뭘 얻을 수 있는지를 보여주고 체감하게 하는 게 먼저라는 생각이 들었어요. 그렇게 한두 팀과 리서치를 하고 결과를 팀에 공유하기 시작하니 자연스럽게 저를 찾아오는 분들이 많아졌어요. 그렇게 작성하던 가이드라인은 지금까지도 몇 년간 꺼내볼 일이 없었답니다… \n\n\n그래도 초반에 문서화 한 것들이 전부 쓸모없진 않았던 게, 아직도 팀원분들이 많이 들어와 보는 노션이 이거에요. UT는 5명이면 충분하다는 노션이요. 매번 팀원들이 “UT 몇 명 정도 해보는 게 적당해요?” “한 20명 해봐야 정확하지 않을까요?”라고 많이들 물어보시는데요. \n\n이 짧은 노션 하나로 이후 아무도 묻지 않게 되었던 것 같아요. 5명인지 10명인지 숫자가 중요한 것이 아니라 적은 유저로도 인사이트를 발견할 수 있으며 그것으로 Iteration하는 것이 핵심이라는 메시지를 전달하고 싶었는데 잘 전달된 것 같아요. \n\n\n\n처음 입사한 당시의 나에게 해주고 싶은 조언이 있다면\n리서치를 하고 싶어 하는 사람들을 리서치하라고 말해주고 싶어요.\n그들이 나의 유저라고 생각하고, 이들의 맥락과 이들의 수용도를 전부 파헤쳐 보는 거예요. 어떤 상황에서 리서처를 찾게 되었는지, 제품에서 가장 문제라고 생각하는 부분이 뭔지, 그들이 생각하는 그들의 유저는 누구인지… 심지어 어떤 타이밍에 어떻게 인사이트를 전달해야 가장 수용이 잘 되는지도 고민해 봐야 해요. \n\n사실 너무 당연한 말인데, 팀에 처음 적응하는 과정에서 하기가 쉽지 않아요. 같이 일하는 동료들에게 정말 많은 질문을 해야 하거든요. 인터뷰로 세팅된 자리에서 사용자분께 질문하는 건 쉽지만, 제가 인사이트를 가져와야 하는 입장에서는 질문이 생겨도 선뜻 나서기 어려워요. \n\n특히 처음 입사해서 팀에서 사용하는 용어나 축약어를 모를 땐 기본적인 내용도 이해하기 쉽지 않아서 이해 못 했는데 이해한 척하기도 했어요. 그리고 나중에 자리로 와서 검색해 보기도 했죠. AMPU가 뭐지..? 하면서요. 하지만 이해한 척 할수록 점점 더 놓치는 게 많아질 뿐이더라고요.\n\n사용자뿐만 아니라 동료들에게 두려움 없이 질문하고, 질문하는 것에 익숙해져야 해요. 그리고 질문이 많아질수록 더 풍부한 리서치가 될 수 있다는 사실을 경험하게 해야 해요. 질문에 대한 답을 얻어가면서 더 그 팀에 맞는 리서치를 할 수 있어요.","isDisplayingFeedback":true},{"id":21341,"updatedTime":"2023-04-27T15:42:17+09:00","createdTime":"2023-04-19T17:09:01+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"첫 그래픽 디자이너가 했던 가장 비효율적인 일","subtitle":"첫 번째 그래픽 디자이너로 입사해서 자리잡기까지의 여정과, 그래픽 디자이너만의 노하우를 알려드려요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/00074-3438188018.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/00074-3438188018.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"1st-graphic-designer","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-04-20T12:00:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21341,"title":null,"description":"저는 당시 유일한 그래픽 디자이너로서, “토스 그래픽은 어떤 느낌이야!” 라는 것을 빠르게 정의해야 한다는 생각이 강했던 것 같아요.","urlSlug":"1st-graphic-designer","primaryKeyword":{"id":3854,"content":"토스 그래픽 디자인","wordType":"SEO_KEYWORD"},"relatedKeywords":[],"tags":[]},"openGraph":{"title":"첫 그래픽 디자이너가 했던 가장 비효율적인 일","description":"저는 당시 유일한 그래픽 디자이너로서, “토스 그래픽은 어떤 느낌이야!” 라는 것을 빠르게 정의해야 한다는 생각이 강했던 것 같아요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/toss-tech/gd_og.png","imageType":"직접입력"},"relatedPostConfig":null,"editor":{"id":590,"name":"고현선","slug":"kohyunsun","shortDescription":"Graphic Designer","description":"토스의 그래픽 디자이너입니다. 토스의 모든 시각 자산을 기획하고 제작합니다.","imageUrl":"https://static.toss.im/assets/toss-tech/koh.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":2,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스 그래픽 디자이너는 어떤 일을 하나요?\n\n토스의 그래픽 디자이너는 토스 제품의 시각 경험을 책임지는 사람들이에요.\n제품에 사용되는 아이콘, 3D, 애니메이션 등의 디지털 그래픽을 기획하고 제작하는 일을 합니다. 화면 맥락에 맞는 좋은 그래픽을 통해 사용자가 제품을 쉽고 재밌게 쓸 수 있도록 만들어요.\n\n그래픽 디자인 팀 인터뷰 >\n\n\n\n\n\n\n\n그래픽 디자이너의 업무 범위는 어떻게 정하게 됐나요?\n\n가장 문제라고 생각하는 것을 찾으니 전부 제가 해결할 수 있는 문제였어요.\n그래픽 디자이너는 토스에서는 첫 직군이긴 하지만, 타사에서는 이미 그 역할이 잘 알려져 있어요. 주로 아이콘이나 일러스트같은, 제품에서 UI와 텍스트를 제외한 시각 요소를 만드는데요. \n\n제가 봤을 때 당시 토스는 다른 디자인 영역에 비해서 그래픽은 황무지 상태라고 생각됐어요. 왜냐면 당시 토스의 UI는 TDS라는 훌륭한 디자인 시스템이 있었고, 완성도 높은 로고와 시스템 폰트도 있었고, 컬러까지도 가이드라인이 있는데 그래픽은 가이드라인은 커녕 자산조차도 많지 않은 상황이었거든요. 그래서 빠르게 퀄리티 높은 그래픽을 만들어서 이 문제를 해결해야 한다는 생각이 들었고, 동료들도 공감해주었기 때문에 업무 범위가 금세 명확해졌어요.\n\n\n2020년 당시 토스 그래픽 자산 일부\n\n2023년 현재 토스 홈페이지 키비주얼\n\n\n\n\n\n\n혼자서 전체 제품 퀄리티를 챙기기 위해서 어떤 시도들을 하셨나요?\n\n유저의 90% 이상이 볼 수밖에 없는 화면에 집중했어요.\n혼자서는 토스의 모든 서비스 그래픽을 다 챙길 수 없기 때문에, 특정 부분에 집중해야 임팩트를 낼 수 있을거라고 생각했어요. 그랬을 때 홈, 내소비, 전체탭처럼 앱을 열자마자 보이거나 한 번의 클릭만으로 마주치는 화면을 개선하면 효과적이겠다는 생각이 들더라구요.\n\n그럼 그 화면에서 어떤 그래픽을 사용하고 있는지 살펴봤더니 90% 이상이 아이콘이었어요. 이 걸 보니 아이콘 한 세트만 잘 만들어도 토스 제품 그래픽의 90% 이상을 커버할 수 있다고 생각했고, 나머지 3D나 애니메이션도 아이콘을 기준으로 쉽게 확대 재생산할 수 있겠다는 생각이 들었죠. \n\n그래서 가장 먼저 토스의 전체 아이콘을 다듬었어요. 전체 아이콘의 밸런스를 균일하게 맞추고, 컬러도 TDS (토스 디자인 시스템)에서 사용하는 컬러만 사용해서 UI 디자인과 찰떡궁합이 되도록 만들었어요.\n\n\n\n또, 당시 내소비 탭에서는 회색 아이콘을 사용하고 있었는데 색상이 없다보니 물체를 바로 인식하기 어려웠어요. 그래서 모든 회색 아이콘을 컬러 아이콘으로 바꾸어 가시성을 높게 만들었어요.\n\n\n\n이렇게 모든 아이콘을 개선하고 제품에 바로 적용하다보니 한 달 뒤에는 거의 모든 아이콘이 제가 다듬은 것들로 바뀌어 있었어요. 한 달이라는 짧은 시간동안 큰 효율을 만들어 낸 사례였다고 생각해요.\n\n\n\n\n3개월 동안 했던 일 중 가장 비효율적인 일이 있다면 무엇인가요?\n\n“절대불변의 법칙”처럼 그래픽 가이드라인 만든 것이요.\n저는 당시 유일한 그래픽 디자이너로서, “토스 그래픽은 어떤 느낌이야!” 라는 것을 빠르게 정의해야 한다는 생각이 강했던 것 같아요. 큰 방향을 정해야 앞으로 그 방향에 맞춰서 그래픽을 그려나갈 수 있겠다는 생각이 들었거든요. 그래서 일단 그래픽보다 앞서서 문서부터 만들었어요. 좋은 키워드 뽑고, 컬러팔레트 만들고, 꽤 그럴싸하게 완성했는데 생각해보니까 이걸 보고 따를 사람이 나 한명 뿐이네 싶은 마음 반, 언제 이 가이드라인에 맞춰서 다 그리지? 하는 마음 반 들더라고요.\n\n\n가이드라인 문서의 일부\n\n심지어 제가 만든 문서에 저 혼자 갇힌 적도 있어요. 예를 들면 가이드라인에서 “귀여움”을 지양하면서, 아이콘이 너무 귀여운 인상을 주지 않도록 라운드를 전부 없앴는데 너무 뾰족해서 제품에 잘 안 어울렸거든요. 근데 혼자서 ‘라운드는 너무 귀여워 보여서 가이드라인에 어긋날 텐데…’ 라는 생각에 쉽게 바꾸지 못 했죠. 기준을 만들었어도 실제 상황에 적합하지 않다면 빠르게 수정해야 하는데, 가이드라인은 함부로 바꾸면 안 된다는 생각이 머리를 지배했던 것 같아요. \n\n\n초반에 만든 뾰족한 아이콘\n다시 그때로 돌아간다면 가이드라인 만들기 이전에 여러 방향으로 많이 그려보고, 제품에 빨리 적용해 볼 것 같아요. 그러면서 어떻게 하면 좋고 어떻게 하면 이상하구나, 라는 러닝을 최소 10개쯤 쌓았을 때 비로소 가이드라인을 만들었을 것 같아요. 또 만들고 나서도 언제든 수정할 수 있다는 가벼운 마음가짐으로 접근할 것 같아요. \n\n\n\n\n\n\n\n첫 3개월 동안 힘들었던 점이 있다면요?\n\n제가 한 번도 안 해본 영역에서 DRI를 쟁취하는게 쉽지 않았어요.\n*DRI : Directly Responsible Individual' 직접 책임질 수 있는 개인의 줄임말로, '직접 책임자'를 의미합니다\n\n\n제가 없었을 때는 브랜드 디자이너 지윤님, 플랫폼 디자이너 수영님이 제 역할을 일부 하고 있었어요. 두 분이 토스에서 3D와 모션을 제품에 적용하기 시작했고, 몇 번의 실험으로 그 위력이 증명되기 시작한 무렵이에요. 근데 당시 저는 한 번도 3D나 모션을 제작해본 경험이 없었어요. 하지만 누가 봐도 3D나 모션은 그래픽 디자이너의 역할이기 때문에, 두 분에게서 DRI를 가져오는게 토스에서 그래픽 디자이너로 자리잡는 첫 걸음이구나 싶었죠. \n\n일단은 툴부터 배우기 시작했어요. 출근길에 유튜브로 공부하고, 낮에는 업무, 밤에는 3D 스터디 하면서 시간을 보냈죠. 처음에는 대체 언제 익숙해지려나, 했는데 계속 익숙하지 않은 환경에서 시간을 보냈더니 어느새 적응하게 되더라구요. 그러다 처음으로 아래 애니메이션을 제품에 적용했는데 그 때 정말 뿌듯했어요. 지금 돌이켜보면 소소한 성장통이었다고 생각해요.\n\n\n\n\n\n\n처음 입사한 당시의 나에게 해주고 싶은 조언이 있다면요?\n\n어처구니없는 시도와 실패를 더 많이 해보라고 하고 싶어요.\n제가 처음 입사했을 때는 팀과 동료들에게 빠르게 인정받고 싶은 마음에 최대한 안전한 방향으로 디자인했던 것 같아요. 대다수에게 호불호가 없는 스타일의 그래픽 위주로 만들었거든요. 물론 그 때 그런 선택을 했기 때문에 빠르고 효율적으로 토스 그래픽 톤을 잘 구축해왔다고 생각하긴 하지만, 지금은 회사도 10배 가까이 커졌고, 그래픽 양은 1000배 이상 늘어났기 때문에 새로운 무언가를 시도할 때 과거에 비해 리스크가 훨씬 크다고 느껴져요. \n\n그래서 제 분야가 황무지같은 시절에만 할 수 있는 새롭고 어처구니없는 시도와 실패를 더 많이 해보라고 조언해주고 싶어요. 순탄했던 것은 별로 생각 안 나지만, 힘들고 헤맨 기억은 쌓여서 결과적으로 성장의 밑거름이 되는 것 같아요.","isDisplayingFeedback":true},{"id":21260,"updatedTime":"2023-04-19T08:09:02+09:00","createdTime":"2023-04-14T12:21:48+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"첫 UX writer는 무슨 일을 해야 할까","subtitle":"이게 정말 UX writer만 할 수 있는 일일까? 내가 해야 하는 일이 이것일까? 생각했을 때 확신이 없었어요. 일단은 모든 업무를 가리지 않고 다 받아서 무작정 열심히 처리했었죠.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://static.toss.im/assets/toss-tech/cover_1st_uxwriter.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://static.toss.im/assets/toss-tech/webthumbnail.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"1st_uxwriter","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-04-14T12:23:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21260,"title":null,"description":"이게 정말 UX writer만 할 수 있는 일일까? 내가 해야 하는 일이 이것일까? 생각했을 때 확신이 없었어요. 일단은 모든 업무를 가리지 않고 다 받아서 무작정 열심히 처리했었죠.","urlSlug":"1st_uxwriter","primaryKeyword":{"id":3956,"content":"UX Writing","wordType":"SEO_KEYWORD"},"relatedKeywords":[{"id":3876,"content":"토스 디자인 컨퍼런스","wordType":"SEO_KEYWORD"},{"id":3956,"content":"UX Writing","wordType":"SEO_KEYWORD"},{"id":4123,"content":"토스 디자인","wordType":"SEO_KEYWORD"}],"tags":[]},"openGraph":{"title":"첫 UX writer는 무슨 일을 해야 할까","description":"이게 정말 UX writer만 할 수 있는 일일까? 내가 해야 하는 일이 이것일까? 생각했을 때 확신이 없었어요. 일단은 모든 업무를 가리지 않고 다 받아서 무작정 열심히 처리했었죠.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/toss-tech/og_1st_uxwriter.png","imageType":"직접입력"},"relatedPostConfig":{"id":2563,"relatedPosts":[{"id":21022,"updatedTime":"2023-04-12T17:25:56+09:00","createdTime":"2023-04-12T16:03:04+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"토스의 8가지 라이팅 원칙들","subtitle":"토스의 문구는 8가지 라이팅 원칙을 고려하면서 쓰고 있어요. 사람이 말하는 것 같은 문장을 지향하면서요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/11/썸네일.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/11/썸네일.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"8-writing-principles-of-toss","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-11-15T17:53:48+09:00","commentBoard":null,"disclaimer":null},{"id":21028,"updatedTime":"2023-04-14T11:55:57+09:00","createdTime":"2023-04-12T16:03:45+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"디자이너가 새로운 도메인을 빠르게 학습하는 법","subtitle":"토스는 일이 굉장히 빠르게 돌아가는 조직이에요. 저는 1년 반 동안 무려 4개의 새로운 분야를 학습해야 했어요. 이때 제가 쓴 방법들을 알려드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"how-to-learn-new-domain","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-07T14:56:37+09:00","commentBoard":null,"disclaimer":null}],"title":"지금 인기있는 글"},"editor":{"id":563,"name":"김자유","slug":"jayu-kim","shortDescription":"UX Writer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/jayu-kim.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":4,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"라이팅 팀은 토스 제품 안에 있는 문구를 관리하고 있어요. \n\n저희 팀의 강점은 라이팅 팀뿐만 아니라 조직 전체가 라이팅을 잘할 수 있게 만드는 것인데요. 매끄러운 커뮤니케이션을 위한 문구 개선은 물론, 그 문구를 라이팅 팀뿐 아니라 모든 팀원이 쓸 수 있도록 원칙을 만들기도 하고, 시스템으로 구현하는 일도 하고 있어요. \n\n토스의 8가지 라이팅 원칙들 >\n\n\n\nUX writer의 업무 범위는 어떻게 정하게 됐나요?\n잘 정착되지 않은 직군이다 보니 다른 직군처럼 ‘일반적으로 해야 하는 일’이 없잖아요. 어떤 일을 어디까지 해야 하는지도 새로 정해야 했을 것 같아요. 팀에서 무슨 업무를 할지 어떻게 정하셨어요? \n토스 라이팅 팀은 앱 안에 들어가는 제품 라이팅을 중점적으로 관리하고 있어요.\n\n처음에는 저도 제가 어디까지 일해야 할지 정하기가 어렵더라구요. 그래서 문장 교정도 하고, 웹사이트도 하고, 채용 콘텐츠 관련된 일도 하고 이것저것 다 했죠. 개발자가 보는 문서를 교정하는 일도 했었네요.\n\n\n입사 첫 주에 받았던 요청\n업무를 하면서 이게 정말 UX writer만 할 수 있는 일일까? 내가 해야 하는 일이 이것일까? 생각했을 때 확신이 없었어요. 당시엔 신규 입사자였으니까, 일단은 모든 업무를 가리지 않고 다 받아서 무작정 열심히 처리했었어요. \n\n\n하지만 시간이 갈수록 업무가 엄청 불어났어요. 그때 프로덕트 디자이너가 30명 가까이 됐었거든요. 디자이너가 30명인데 라이터는 1명이었던 거죠. 선택과 집중을 해야 했어요. 그때 디자이너분들을 한 분씩 찾아가서 1:1 커피챗을 했어요. ‘제가 무슨 역할을 하면 좋을까요’라고 여쭤봤죠. \n\n\n복사 붙여 넣기로 디자이너분들께 DM 돌리기 (하지만 절대 15분 안에 끝나지 않았다 ^^…)\n\n사실 만나기 전에는 ‘엥? 저도 모르겠는데요’라고 반응하시면 어쩌지 싶어서 걱정도 했어요. 놀랍게도 실제로 만나고 보니 정말 많은 인사이트를 갖고 계신 거예요. 이런 고민이 있었고, 예전에 이런 시도를 해봤고, 라이터에게 이런 걸 기대하고, 이런 아이템도 생각해 봤다 등등… \n\n그때 인터뷰한 내용을 바탕으로, ‘일단 제품에 집중해야겠다’는 결정을 내릴 수 있었어요. 직접 말씀해 주셨던 문제를 푸는 일이니, 공감대도 잘 형성돼서 설득도 어렵지 않았어요. \n\n첫 직군으로서 어디에 집중해야 할지 모르겠다면, 이해관계자를 인터뷰하는 걸 추천드려요. 기대했던 것과 완전 다른 답을 얻게 될 때가 많더라구요. \n\n\n\n혼자서 전체 제품의 퀄리티를 챙기기 위해서 어떤 시도들을 하셨나요?\n1인 팀인 상태에서 많은 디자이너들과 커뮤니케이션하고, 또 전체 제품의 퀄리티를 챙겨야 했을 텐데 어떻게 극복하셨나요?\n라이팅은 모두가 쓸 수 있기 때문에, 제 업무를 디자이너분들께 위임해야겠다고 생각했어요.\n\n처음에는 요청 업무를 처리하는 것만으로도 급급했어요. 하지만 점점 업무에 적응하게 되면서, 요청받지 않은 영역들도 챙기기 시작했죠. 그러다 제 손길이 굉장히 랜덤하게 닿는 것 같다는 생각을 하게 된 거예요. \n\n친한 디자이너분과 밥을 먹다가 얘기해서 살펴보거나, 어쩌다 들어간 디자인 리뷰에서 살펴보거나, 제가 직접 앱을 쓰다가 발견하거나… 그렇게 발견하지 못한 영역들은 충분히 챙기고 있지 못하다는 생각이 들었고, 저 혼자서 모든 문구를 직접 본다는 건, 제품의 어느 부분을 늘 놓치는 것과 같다고 생각하게 됐어요. \n\n그렇다고 모든 제품을 배포하기 전에 제가 검수를 할 수는 없었어요. 속도가 빠른 토스의 문화와 맞지 않았죠. 그래서, 접근 방식을 바꾸기로 했어요. 바로 다른 사람이 잘 쓰게 만드는 일에 집중한 거예요. 제가 글을 쓸 때 생각하는 것들을 규칙으로 만들어서 전파했죠. 그 규칙이 더 고도화된 것이 시스템이고요.\n\n\n출처: 어느 날 토스가 말을 걸기 시작했다 (토스 디자인 콘퍼런스 Simplicity21)\n그렇게 열심히 규칙을 전파하고 시스템을 만든 결과, 지금은 ‘이렇게 쓰면 안 된다’, ‘토스의 보이스톤은 이런 것이다’라는 공감대가 팀 내에 어느 정도 형성되어 있어서, 라이팅 팀이 미처 보지 못하더라도 어느 정도 퀄리티는 챙겨서 나가게 됐어요. 라이팅 팀뿐만 아니라, 토스 팀의 라이팅 실력이 높아지게 된 거죠. \n\n\n\n첫 3개월 동안 했던 가장 큰 실수는 무엇이었나요?\n물론 그런 일들이 있었기 때문에 지금도 있는 것이겠지만, 돌이켜봤을 때 ‘정말 바보 같았다’는 생각이 드는 일이 있나요? 새롭게 첫 직군을 시작하는 분들께 좋은 조언이 될 수도 있을 것 같아요. \n보이스톤을 만들 때 우리 사례에서 시작하지 않았던 거요. \n\n보이스톤이라는 걸 처음 만들어보니까, 타사 레퍼런스를 되게 많이 찾아봤어요. 구글, 우버, 에어비앤비, 메일침프, 듀오링고… 유명한 회사에서 내놓은 자료란 자료는 다 봤는데, 딱이다 싶은 게 없는 거예요. 너무 두루뭉술했거든요. \n\n예를 들어 메일 침프의 문서가 좋았는데, ‘와, 드라이한 유머라니 멋지다! 근데 이걸 어떻게 하지? snobbish하지 않으려면 어떻게 말해야 하는 걸까?’ 도저히 모르겠는 거예요.\n\n\n메일침프 콘텐츠 스타일 가이드\n그러다 <strategic writing for UX>라는 책에서 본 보이스 차트라는 프레임 워크가 생각났죠. 어차피 다른 회사들 것을 그대로 가져다 쓸 수 없다면, 좋은 틀을 가지고 작업해봐야겠다 싶었어요. \n\n\n출처: <Strategic writing for UX>, Torrey podmajersky\n그래서 바로 가져와서 빈칸을 채워봤어요. 만들면서 ‘오, 보이스톤을 만들 때는 이런 걸 고려해야 하는구나’하면서 뭔가 되는 듯한 느낌이었어요. 예를 들면 이런 식이었어요. \n\n제품 콘셉트: Reliable, 안심하고 돈을 맡길 수 있을 정도의 신뢰감\n라이팅 콘셉트: 신뢰를 주는 글쓰기(일관적인, 퀄리티 높은), 비문이 없고 일관적이며 퀄리티 높은 문장을 지향한다.\n어휘: 명료하지만 기계 같지 않다.\n어투: 문장형(명사형X), 청유형 문장(강요나 지시X)\n…\n만들고 보니 너무 뜬구름 잡는 이야기만 하는 것 같고, 만든 저조차도 이 문서를 보고 우리 톤에 맞는 문장을 써보라고 하면 못 쓸 것 같은 거예요.  되게 멋있는 말인데 하나하나 뜯어보면 너무 추상적이고, 사실 대부분의 상황에서는 Do와 Don’t 중에 고르는 게 아니라 Do와 Better를 가려내야 하는 경우가 많았기 때문에 큰 도움이 되지 않았죠. \n\n그래서 일단 제품에서 ‘이건 우리 톤이야’싶은 화면을 무작정 끌어모았어요. 그렇게 사례를 찾는 과정에서 ‘이건 우리 톤이 아닌데(아니었으면 좋겠는데)?’싶은 것들도 자연스럽게 찾게 되고요. 중요한 건 우리 톤인지 아닌지를 엄밀하게 검증하려고 하지는 않았다는 점이에요. \n\n‘이 정도면 괜찮은 듯?’, ‘이건 좀 그런가’ 정도의 애매한 감정을 가지고서 구분해보려고 했어요. 그렇게 사례를 모으니 좋은 문장과 그렇지 않은 문장의 패턴들이 보이기 시작하더라구요. 그렇게 조금씩 토스의 보이스톤을 명문화하기 시작했죠.\n\n\n라이팅 원칙을 만들기 위해 사례를 한 곳에 모으는 중. 이렇게 모은 사례들에서 공통점을 찾아 원칙으로 만들어요.\n그 이후로 모든 가이드라인은 사례를 수집하는 것부터 시작해요. 연역적으로 접근하는 게 빠르고 효율적이라고 느껴질 수 있지만, 실제로 쓸 수 있는 규칙을 만들려면 언젠가는 귀납적으로 접근할 수밖에 없어요. \n\n\n\n3개월 동안 했던 일 중 가장 비효율적인 일이 있다면 무엇인가요?\n첫 직군이다 보니 처음부터 지금처럼 체계가 잘 갖춰져있지는 않았을 것 같거든요. 당연히 처음에는 비효율적으로 일을 하기도 했을 것 같은데 ‘나 이것까지 해봤다’하는 비효율 사례가 있을까요?\n‘전체 사일로 워싱’이란 걸 했었어요.\n\n말 그대로 전체 사일로를 돌아다니면서 문구를 개선하는 거예요. 모든 디자인 화면의 문구를 저 혼자서 하나하나 다 뜯어보는 거죠. 지금 생각하면 비효율도 그런 비효율이 없는데, 그때는 다른 방법이 생각 안 났어요.\n\n\n갑자기 댓글이 달리면 당황스러우실 것 같아 디자이너분들께 개인적으로 메시지를 보냈던 기억이 나네요.\n\n사실 그 작업의 목적은, 실제로 그 문구를 고친다기보다는 라이팅에 대한 관심도를 올리기 위함이었어요. 이렇게 한 번 피드백 받으시면 다음에 문구를 쓸 때는 제가 말씀드린 내용을 기억하실 거라고 생각했어요. \n\n그래서 ‘이 문구는 이렇게 바꿔주세요’하고 대안만 던지는 게 아니라, 왜 그렇게 바꾸는 게 좋은지 이유를 함께 남겼었죠. 지금 생각해 보면 그런 노력들이 규칙을 전파하고 공감대를 형성하는 데에 큰 기여를 한 것 같아요.\n\n\n제플린에 하나하나씩 남겼던 댓글들 모음(왠지 죄송한 마음에 귀여운 말투로…)\n\n\n첫 3개월 동안 가장 힘들었던 점이 있다면요?\n처음 생긴 직군으로서, 참고할만한 레퍼런스도 없고 함께 일할 팀원도 없어서 힘들었던 점들이 있을 것 같아요. \n디자이너분들을 설득하는 일이 제일 어려웠던 것 같아요. \n\n사실 입사하기 전에는, 라이터는 저 하나니까 글은 제가 제일 잘 쓸 거라고(…) 생각했어요. 그런데 제가 지금까지 써오던 글이랑 제품 안에 들어가는 문구의 세상이 엄청 다른 거예요. \n\n예를 들면 독자가 이해하기 쉽게 맥락을 충분히 설명하고 배경 지식 없이도 읽을 수 있는 단어로 풀어써도, 그 문장을 굉장히 좁은 영역에 넣어야 했기 때문에 정보를 덜어내야 했어요. 즉, 제가 생각해 온 좋은 문장이 여기에서는 좋은 문장이 아니었죠. 그게 좀 충격이었어요. \n\n그러니 어떻게 설득해야 할지 막막하더라구요. 저만의 기준으로 아무리 ‘이렇게 써야 합니다’라고 해도 그 분들의 기준은 달랐을 테니까요. 제가 단순히 예쁜 글을 쓰는 사람이 아니라, 실용적인 글을 잘 쓰는 사람이기도 하다는 걸, 제 전문성을 다시 입증해야 하는 상황이었어요. \n\n그때 발견한 건 토스 안에 있는 사람들이 모두 지표 중심으로 일하고 있다는 점이었어요. 그들을 설득하기 위해선 그게 가장 빠른 길이겠구나 싶었죠. 그래서 그동안 디자이너분들이 실험했던 화면들을 다 모아서 ‘이렇게 썼더니 이기더라’라는 규칙을 만들었어요. \n\n\n토스가 금융을 더 쉽게 만드는 또 하나의 방법, UX writing > \n\n\n그게 라이팅 프린시플의 초기 버전이었어요. 사실 이 원칙만 봤을 때는 당연한 말처럼 느껴질 수 있지만, 실제 지표 상승을 이끌어낸 사례들을 기반으로 한 것이기 때문에 공감대를 얻을 수 있었어요. \n\n물론 지금은 지표만이 유일한 기준은 아니에요. 지표 자체보다는, 제가 디자이너 분들과 ‘같은 곳을 보고 있다’라는 공감대를 형성하는 게 중요했던 거죠. 그렇게 라포가 쌓이니, 이제는 라이팅 팀이 중요하다고 생각하는 부분들도 존중을 해주시더라구요. 예를 들면 지표에는 크게 영향을 주지 않지만 브랜딩 적으로 임팩트 있는 해요체 적용 같은 거요. \n\n처음 가이드라인을 만들 때는, 만드는 사람이 아니라 사용하는 사람이 공감할 수 있게 만드는 게 중요한 것 같아요. 그게 실제로 유용한 가이드라도, 내가 중요하게 생각하는 가치가 빠져있다면 와닿지 않으니까요. 지금 해요체가 토스의 톤을 구성하는 데에 가장 큰 역할을 하고 있지만, 제가 처음부터 말투를 고쳐야 한다고 설득했다면 아무도 공감하지 않았을 것 같거든요. \n\n\n\n처음 입사한 당시의 나에게 해주고 싶은 조언이 있다면요?\n이걸 미리 알았더라면 조금 덜 돌아갈 수 있었을 텐데, 싶은 이야기가 있을 것 같아요.\n‘갖고 있는 것들을 활용하기’요.\n\n회사에 나 하나뿐이고, 내가 제일 전문가여야 한다는 생각에 회사 안에서 정보를 더 찾아보는 건 크게 중요하지 않다고 생각했었어요. 이미 잘하고 있는 다른 회사를 참고하거나 책이나 아티클 같은 외부의 정보를 정말 많이 찾아봤던 것 같아요. \n\n물론 그 정보들이 어떤 면에서 도움이 되기는 했지만, 실질적인 문제를 찾아주지는 않았어요. 근본적으로는 우리 조직이 실제로 갖고 있는 문제를 해결해야 하는 것 같거든요. 지금 우리 팀원들이 느끼는 문제는 무엇인지, 우리 제품에서 문제는 무엇인지. ‘지금 우리’에 집중하라고 말해줄 것 같아요. 제가 디자이너 분들을 인터뷰하고, 가이드라인을 만들기 전에 사례를 먼저 수집했던 것처럼요.","isDisplayingFeedback":true},{"id":21024,"updatedTime":"2023-07-05T22:07:39+09:00","createdTime":"2023-04-12T16:03:17+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"내 아이디어를 너무 믿지 마세요","subtitle":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"dont-trust-your-gut","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-28T17:31:40+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21024,"title":null,"description":"‘내 아이디어를 너무 믿지 마세요.’제가 토스에서 일하면서 가장 크게 배웠던 것 중 하나예요. 저는 너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였던 적이 여러 번 있었거든요. 이걸 가장 크게 느꼈던 사례를 하나 소개해드릴게요.제가 채용 사이트를 맡고 있을 때였...","urlSlug":"dont-trust-your-gut","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"내 아이디어를 너무 믿지 마세요","description":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-14-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2359,"relatedPosts":[{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","commentBoard":null,"disclaimer":null},{"id":21023,"updatedTime":"2023-04-12T17:25:57+09:00","createdTime":"2023-04-12T16:03:12+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"토스 디자인 원칙 Value first, Cost later","subtitle":"토스의 제품 디자인 원칙 중에는 Value first, cost later라는 항목이 있어요. 비용을 말하기 전에 가치를 명확하게 전달해야한다는 내용이에요. 가치를 먼저 보여주는 것 만으로도 지표를 눈에 띄게 개선한 사례를 소개해드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image-1.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image-1.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"value-first-cost-later","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-16T18:49:46+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":576,"name":"강효정","slug":"hyojeong-kang","shortDescription":"Product Designer(Tools)","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/hyojeong-kang.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":2,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"‘내 아이디어를 너무 믿지 마세요.’\n\n제가 토스에서 일하면서 가장 크게 배웠던 것 중 하나예요. 저는 너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였던 적이 여러 번 있었거든요. 이걸 가장 크게 느꼈던 사례를 하나 소개해드릴게요.\n\n문제\n제가 채용 사이트를 맡고 있을 때였어요. 채용팀에서 하는 이벤트들과는 별개로 토스에 지원하는 지원자 수를 늘리기 위해 제품 관점에서 시도할 수 있는 게 없을까? 고민을 했었어요.\n\n가설\n이직을 할 때 보통 이력서나 자기소개서 등을 준비하는데, 이 서류들을 준비하는 과정이 엄두가 안나서 이직을 미루거나 포기하는 사람들이 많아요. 그래서 서류를 준비하는 것보다 간편한 방법이 있다면 지원자가 많이 늘겠다 싶었죠.\n\n어떻게 해야 지원자가 간편하다고 느낄까? 고민하다가 문득 ‘음성’이라는 단어가 스쳐지나갔어요. 당시 제가 출근길에 항상 팟캐스트를 들었거든요. 편하게 이야기 하는 팟캐스트 속 사람들이 갑자기 생각나면서 아이디어 하나가 반짝 떠올랐어요.\n\n“이력서를 글이 아닌 음성으로 받으면 어떨까?”\n\n해결책\n책상에 앉아 각 잡고 써야 하는 이력서가 아니라, 친한 동료한테 얘기하듯이 내 업무 경험을 음성으로 녹음하고 이걸로 이력서를 대신하는 제품을 만들기로 했어요. 하고 싶은 이야기를 문장으로 정리해서 쓰는 것보다 생각나는대로 내뱉는 게 부담도 덜하고 지원자의 마음을 더 잘 표현할 수 있을 것 같았죠.\n\n어떤 회사에서도 시도하지 않았던 신박한 아이디어라는 생각에 저는 이 아이디어에 완전 빠져버렸어요. 그래서 클로바, 파파고, 아이폰 음성 메모 등 목소리를 녹음하는 각종 앱을 참고하며 빠르게 스케치를 했어요.\n\n\n최초 아이디어 스케치\n\n그리고 이 아이디어는 ‘3가지 질문에 답하면 저절로 완성되는 이력서’라는 콘셉트로 발전했어요. 이력서나 자기소개서는 몇 번을 썼다 지웠다 하면서 짧게는 며칠, 길게는 몇 주에 걸쳐 간신히 완성하는 게 흔한 일이잖아요?\n\n그런데 3가지 질문에 대답만 하면 저절로 완성된다니, 게다가 힘들게 글로 쓰는게 아니라 말로 하면 된다니! 우리가 채용의 문화를 완전 바꿔버릴 수도 있겠다 싶었어요. 너무 잘될 것 같다는 막연한 믿음이 있었지만 혹시 몰라서 프로토타입을 만들어 사내에서 UT(사용성 테스트)를 해봤어요.\n\n\n결과\n그런데 제 예상과는 완전히 다른 결과가 나온 거예요. 갑자기 예상 못한 녹음 기능이 나타나 당황스럽다는 의견부터 말투나 목소리까지 신경써야 해서 글로 쓰는 것보다 오히려 더 오래 걸릴 것 같다, 대본을 준비해서 말해야 할 것 같다 등 부정적인 피드백이 많았어요. 의도와는 다르게 간편한게 아니라 오히려 더 어렵고 부담스러운 방식이라고 느끼셨던거죠.\n\n생각과 너무 다른 반응에 조금 당황스럽기도 했지만 그래도 개발하기 전에 알게 돼서 다행이다 싶었죠. 이후 여러 번의 UT를 반복하며, 입사 지원은 지원자에게 중요한 일이기 때문에 ‘음성 지원’이라는 낯선 방식이 오히려 거부감을 준다는 사실을 깨달았어요.\n\n그래서 무작정 지원을 유도하는 게 아니라, 토스와 잠재 지원자 사이에 ‘작은 접점’이라도 만들어보자라는 마음으로 ‘3가지 질문에 답하면 합격 확률 높은 포지션을 알려줄게요’라는 콘셉트로 방향을 바꿨어요. 그리고 참여자의 부담감을 덜어주기 위해 ‘이건 입사 지원이 아니다’라는 것을 명시했고 편하게 말할 수 있도록 돕는 장치들을 넣었어요. 이렇게 출시한 제품은 정말 많은 분들이 참여해주셨고 그 중 일부는 실제 지원까지 하셨어요.\n\n\n\n적용해보기\n개발하기 전에 프로토타입을 만들어 UT를 하면 예상치 못한 문제를 발견할 수 있어요. 그렇게 발견한 문제를 개선한 후에 개발을 하면 시간과 비용을 많이 아낄 수 있고요. UT는 실제 유저를 대상으로 하면 제일 좋지만 그게 어려울 땐 비슷한 환경의 사람들을 찾는 편이에요.\n\n외부의 잠재 지원자를 찾기 어려우니 사내에 이직 경험이 있는 다양한 직군의 동료들을 대상으로 한다\n그리고 UT를 하기 전에 무엇을 검증하고 싶은지, 검증을 위해 확인해야 할 것은 무엇인지를 고려해서 시나리오를 짜요.\n\n검증하고 싶은 것\n음성을 녹음해서 지원하는 방식을 쉽고 편하게 느끼는가?\n확인해야 할 것\n음성 녹음 UI를 보고 어떤 반응을 보이는가?\n녹음 기능을 어려움 없이 사용할 수 있는가?\n질문을 보고 말로 쉽게 대답할 수 있는가?\n시나리오\nOO님은 ‘3가지 질문에 답하면 저절로 완성되는 이력서’라는 배너 광고를 보고 이 화면(첫 화면)으로 왔어요. 다음 버튼을 눌러 실제로 질문에 답해보시겠어요?\n아이디어는 말 그대로 아이디어일 뿐, 실제로 의미있는 결과를 만들기 위해선 아이디어를 검증하고 수정하는 과정을 계속 반복해야 하는데요. 이때 프로토타입과 UT를 활용하면 검증에 걸리는 시간을 줄일 수 있으니 여러분도 적극 활용하시길 바라요!","isDisplayingFeedback":true},{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21004,"title":null,"description":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 여러 선택지 중에서 고민하다 보면, 쉽게 이탈하게 되니까요. 사용자에게는 너무 많은 선택지보다, 최고의 선택지 하나가 더 좋을 수 있어요.그렇다면 어떤 것이 최고의 선택지일까요? 혜택이 가장 좋은 것? 다른 사람들이 많이 쓰는 ...","urlSlug":"recommend-just-one","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"추천할 때는 제일 좋은 것 하나면 된다","description":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/tech-blog/thumbnail-02.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2358,"relatedPosts":[{"id":21024,"updatedTime":"2023-07-05T22:07:39+09:00","createdTime":"2023-04-12T16:03:17+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"내 아이디어를 너무 믿지 마세요","subtitle":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"dont-trust-your-gut","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-28T17:31:40+09:00","commentBoard":null,"disclaimer":null},{"id":21028,"updatedTime":"2023-04-14T11:55:57+09:00","createdTime":"2023-04-12T16:03:45+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"디자이너가 새로운 도메인을 빠르게 학습하는 법","subtitle":"토스는 일이 굉장히 빠르게 돌아가는 조직이에요. 저는 1년 반 동안 무려 4개의 새로운 분야를 학습해야 했어요. 이때 제가 쓴 방법들을 알려드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"how-to-learn-new-domain","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-07T14:56:37+09:00","commentBoard":null,"disclaimer":null},{"id":21023,"updatedTime":"2023-04-12T17:25:57+09:00","createdTime":"2023-04-12T16:03:12+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"토스 디자인 원칙 Value first, Cost later","subtitle":"토스의 제품 디자인 원칙 중에는 Value first, cost later라는 항목이 있어요. 비용을 말하기 전에 가치를 명확하게 전달해야한다는 내용이에요. 가치를 먼저 보여주는 것 만으로도 지표를 눈에 띄게 개선한 사례를 소개해드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image-1.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image-1.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"value-first-cost-later","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-16T18:49:46+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":581,"name":"박다롱","slug":"darong-park","shortDescription":"Product Designer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/darong-park.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 여러 선택지 중에서 고민하다 보면, 쉽게 이탈하게 되니까요. 사용자에게는 너무 많은 선택지보다, 최고의 선택지 하나가 더 좋을 수 있어요.\n\n그렇다면 어떤 것이 최고의 선택지일까요? 혜택이 가장 좋은 것? 다른 사람들이 많이 쓰는 것? 나와 관련이 있는 것? 카드혜택추천 서비스에서 직접 실험하고 발견한 선택지를 알려드릴게요.\n\n카드혜택추천은 이름 그대로 체크/신용카드를 혜택에 따라 추천해주는 서비스예요. 사람들이 많이 쓴 순위를 보여주기도 하고, 혜택 종류별로 보여주거나, 사용자의 소비 내역을 분석해서 딱 맞는 카드를 추천해주기도 해요.\n\n\n문제\n카드혜택추천은 이미 잘 운영되고 있는 제품이었어요. 카드 혜택 TOP 10에서 많은 사용자분들이 좋은 카드를 발급받았고, 매출에 큰 기여를 하고 있었어요. 꾸준한 매출로 기초 체력이 좋은 제품이라고 할 수 있죠. 하지만 폭발적인 성장을 위해서는, 이 기초 체력 위에 좀 더 튼튼한 체력을 더 쌓아올려야 했어요. 그래서, 새로운 카드 신청 맥락을 찾기로 했죠.\n\n\n가설\n저희는 이전에 최고의 카드를 추천해주기 위해서 여러가지 실험을 했었어요. 그 중 ‘카드 혜택 TOP 10’으로 전달했을 때 신청율이 가장 높았기 때문에, 그 화면을 유지하고 있었죠.\n\n그런데 지표를 살펴보니, (어쩌면 당연하겠지만) 그 중에서도 1위 카드의 신청율이 압도적이었어요. 카드 이벤트 혜택이 가장 좋기도 했고, 1위라는 단어 자체도 매력적인 요소였던 것 같아요. ‘1위’ 혹은 ‘1등’이라는 단어가 신뢰감과 검증된 느낌을 준다는 생각이 들었어요.\n\n그렇다면 다른 카드 신청 화면에서도 ‘1위’를 적용해볼 수 있겠다 싶었죠.\n\n해결책\n먼저 토스 홈에 노출되는 배너 문구를 실험했는데, ‘1등 카드 확인하기’의 클릭율이 20%p 높았어요. 아무래도 나에게 딱 맞는 카드라는 게 추상적으로 느껴지기도 했을 것이고, 1등이라는 단어가 후킹하게 느껴졌던 것 같아요.\n\n\n다음으로는 카드 순위를 보여주며 추천하는 A안과, 1위 카드 한 개만 보여주는 B안를 비교해보기로 했어요. 저는 당연히 순위를 보여주는 A안이 이길 거라는 생각을 했어요.\n\n\n결과\n제 예상과는 다르게 한 개만 보여준 B안이 카드 신청 전환율이 더 좋았어요. 여러개의 카드를 제안하게 되는 경우, 사용자들이 더 많이 고민하게 되었던 것 같아요. 결국 핵심은 선택지를 한 가지만 주는 것이었던 거죠.\n\n(* 사실 각각 컨셉에 맞는 화면을 구성하느라 실험의 변수가 잘 통제되어있진 않았어요. 지금이라면 더 좋은 실험을 설계할 수 있을텐데, 하는 생각도 드네요! )\n\n적용해보기\n여러 가지 상품을 추천하는 제품이 있다면 한 개만 강조해보는건 어떨까요? 가장 좋은 선택지를 골라 사용자의 고민을 줄이면, 이탈이 줄어들 거에요.\n\n가장 좋은 선택지처럼 보이게 아이디에이션하는 방법을 알려드릴게요.\n\n사회적 증거를 들어 신뢰감을 준다.\n토스 회원들이 가장 많이 구매한 상품이에요.\n지금까지 3만명이 구매한 상품이에요.\n리뷰 평점이 가장 좋은 상품을 소개할게요.\n사용자의 정보를 활용한다.\n매일 카페를 가는 김토스님, 카페 할인되는 카드를 만들어보세요.\n30대 여성에게 가장 인기있는 원피스예요.\n송파구에 사는 김토스님, 송파구 방문 1위 맛집이에요.","isDisplayingFeedback":true},{"id":21023,"updatedTime":"2023-04-12T17:25:57+09:00","createdTime":"2023-04-12T16:03:12+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"토스 디자인 원칙 Value first, Cost later","subtitle":"토스의 제품 디자인 원칙 중에는 Value first, cost later라는 항목이 있어요. 비용을 말하기 전에 가치를 명확하게 전달해야한다는 내용이에요. 가치를 먼저 보여주는 것 만으로도 지표를 눈에 띄게 개선한 사례를 소개해드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image-1.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image-1.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"value-first-cost-later","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-16T18:49:46+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21023,"title":null,"description":"토스의 제품 디자인 원칙 중에는 Value first, cost later라는 항목이 있어요. 비용을 말하기 전에 가치를 명확하게 전달해야한다는 내용이에요.언뜻 생각하면 당연해 보이는 내용이지만, 종종 해야 할 액션을 설명하는 것에 집중한 나머지 가치를 생략하고 사용자에게 결정이나 비용...","urlSlug":"value-first-cost-later","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"토스 디자인 원칙 Value first, Cost later","description":"토스의 제품 디자인 원칙 중에는 Value first, cost later라는 항목이 있어요. 비용을 말하기 전에 가치를 명확하게 전달해야한다는 내용이에요. 가치를 먼저 보여주는 것 만으로도 지표를 눈에 띄게 개선한 사례를 소개해드릴게요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/%E1%84%87%E1%85%A9%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8A%E1%85%A5%E1%86%B7%E1%84%82%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AF_%E1%84%87%E1%85%A2%E1%86%AF%E1%84%85%E1%85%B2%E1%84%91%E1%85%A5%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2350,"relatedPosts":[{"id":21035,"updatedTime":"2023-09-17T21:45:50+09:00","createdTime":"2023-04-12T16:04:24+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"문제 원인의 원인을 찾아서","subtitle":"좋은 해결책을 내기 위해서 제가 쓰는 방법은, 문제 원인의 원인을 찾는 거예요. 진짜 문제를 발견하면, 임팩트 있는 해결책을 생각해 낼 확률이 훨씬 높아지죠.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":"","imageAlt":null,"title":"토스 Tools product designer가 궁금하다면?","description":null,"ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/Frame-46.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/Frame-46.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"real-reason","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-02T17:40:06+09:00","commentBoard":null,"disclaimer":null},{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","commentBoard":null,"disclaimer":null},{"id":21028,"updatedTime":"2023-04-14T11:55:57+09:00","createdTime":"2023-04-12T16:03:45+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"디자이너가 새로운 도메인을 빠르게 학습하는 법","subtitle":"토스는 일이 굉장히 빠르게 돌아가는 조직이에요. 저는 1년 반 동안 무려 4개의 새로운 분야를 학습해야 했어요. 이때 제가 쓴 방법들을 알려드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"how-to-learn-new-domain","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-07T14:56:37+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":575,"name":"이혜인","slug":"hyein-lee","shortDescription":"Product Designer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/hyein-lee.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스의 제품 디자인 원칙 중에는 Value first, cost later라는 항목이 있어요. 비용을 말하기 전에 가치를 명확하게 전달해야한다는 내용이에요.\n\n언뜻 생각하면 당연해 보이는 내용이지만, 종종 해야 할 액션을 설명하는 것에 집중한 나머지 가치를 생략하고 사용자에게 결정이나 비용을 지불할 것을 요구하곤 해요.\n\n가치를 먼저 보여주는 것 만으로도 지표를 눈에 띄게 개선한 사례를 소개해드릴게요.\n\n배경\n오늘 소개해드릴 서비스는 ‘내 보험’인데요. 내가 가입한 모든 보험을 한 번에 조회해주는 서비스예요. 토스에는 여러 조회 서비스들이 있어요. 예를 들면 내 계좌 모아보기, 신용 점수 조회, 내게 맞는 대출 찾기 같은 서비스예요.\n\n‘내 보험’은 기존 보험 조회 경험을 매우 편하게 만들어준 서비스예요. 만약 오프라인에서 내가 가입한 보험 내역을 알아보려면, 보험사에 전화해서 가입자 본인 확인 후에 이메일로 받아보아야 했어요. 하지만 토스에서는 몇 가지 정보만 입력하면 조회를 할 수 있었죠.\n\n오프라인보다는 편해지기는 했지만, 토스의 다른 조회 서비스와 비교했을 때는 훨씬 불편했어요. ‘내 보험’은 핸드폰 문자 인증, 이메일 인증, 캡챠, 비밀번호 설정 등 여러 차례 인증을 거쳐야만 했거든요. 다른 조회 서비스들은 질문 3,4개 정도만 답해도 조회가 가능했기 때문에 비교가 됐죠.\n\n\n문제\n실제로 이 퍼널을 뚫고 조회를 완료한 사람의 비율은 매우 낮았어요.\n\n토스를 쓰는 사용자들은 매끄러운 경험에 익숙해져있었어요. 그런 사용자들에게 갑자기 긴 퍼널을 지나가라고 하니 매우 견디기 어려웠겠죠.\n\n사용자들은 ‘내 보험’ 탭에 들어오자마자 바로 가입한 보험들이 보였으면 했어요. 그런데 바로 보험이 보이지도 않는데, 긴 조회 과정을 거치게 하니 인내심을 잃고 포기했죠. 심지어 토스 팀원분들 중에서도 포기하는 분이 많았으니 문제가 심각하다고 생각했어요.\n\n가설\n문제를 해결하기 위해, 어떤 가치를 얻을 수 있는지 미리 보여주면 지루한 과정도 마칠 수 있을 것이란 가설을 세웠어요.\n\n당시 ‘내 보험’팀은 끔찍히 긴 조회 과정이 문제라고 생각했어요. 그래서 이 퍼널을 어떻게 하면 개선할 수 있을지에 대해 고민했죠. 하지만 조회 과정을 우리가 줄일 수는 없었어요. 왜냐하면 이 퍼널은 토스 내부에서 만드는 게 아니라, 보험을 조회하는 기관의 시스템을 이용했기 때문이죠.\n\n어떻게 할지 고민하면서, 여러 실험과 유저 인터뷰를 진행했어요. 그러면서 몰랐던 사실을 알게 됐죠. 보험에 관심있는 사용자들 대부분은 나와 비슷한 연령대의 다른 사람들은 어떻게 보험을 들었는지 궁금해했어요. 보험료는 얼마인지, 어떤 보험을 가입했는지, 보장금액은 얼마나 준비했는지 등이요.\n\n우리가 분명히 줄 수 있는 가치인데, 조회라는 허들을 넘지 못해서 그 가치를 보여주지 못한다는 게 너무 안타까웠어요. 그러다 ‘어떤 가치를 얻을 수 있는지 미리 보여주면 어떨까?’라는 생각을 하게 된 거예요.\n\n해결\n가설을 검증하기 위해, 사용자가 조회 퍼널을 시작하기 전에 얻을 수 있는 가치를 먼저 보여주기로 했어요.\n\n긴 퍼널이 기다리고 있기 때문에, 가치를 아주 명료하게 보여줘야겠다고 생각했죠. 명료하게 보여준다는 말은 충분히 구체적이면서 이해하기 쉬워야 한다는 뜻이에요. 사용자가 얻게 될 이익을 체감할 수 있을 정도로요.\n\n예를 들어 배달앱을 켜서 치킨을 고르고 있는 상황이라면, 30%할인이라는 말보다는 치킨 5000원 할인이 더 와닿을 수 있어요. 사용자가 내 보험의 이익을 체감하려면, 구체적으로 상상할 수 있게 조회 화면을 먼저 보여주어야겠다 생각했죠. 아직 조회 전이라 사용자 데이터가 없기 때문에 더미 데이터를 넣은 화면을 조회 시작하기 전에 보여주기로 했어요.\n\n사용자는 보험료를 비교한 그래프를 보고, 본인의 보험료도 또래와 비교해서 볼 수 있다는 가치를 상상할 수 있게 되었어요.\n\n\n결과\n이 화면을 넣었더니, 조회를 끝내는 사용자 비율이 기존보다 67%나 높아졌어요.\n\n얻을 수 있는 가치를 확실하게 체감하고 나니, 지루한 과정을 참고 조회를 끝까지 한 거죠. 조회하는 과정을 건드리지 않고, 앞단에서 화면 하나를 추가한 것 만으로도 엄청난 상승폭을 만들어낸 거죠. 정말 놀라웠어요.\n\n단계를 줄여서 비용을 낮춰야겠다고만 생각했었는데, 가치를 먼저 이야기하는 것이 얼마나 강력한지 알게 된 실험이었어요.\n\n적용해보기\n혹시 사용자에게 행동을 유도하기 위해서, 무작정 요청하고 있지는 않나요?\n\n“지금 보험을 조회하세요”, “신용점수를 알아보세요”처럼요. 물론 무슨 액션을 해야 하는지 알려주는 것도 중요하지만, 왜 사용자가 그 액션을 해야하는지 설명해주는 것도 정말 중요해요. 사용자는 처음 만난 화면에서 얻게될 이익과 지불할 비용을 본능적으로 저울질하거든요.\n\n지금 디자인 하는 화면 중에 비용이 유독 큰 화면이 있진 않은지 한 번 점검해보세요. 예를 들어 오늘 사례처럼, 정보를 입력받는 화면의 비용을 확인해보는 방법이 있어요. 이 질문들을 해보고 비용이 높다고 판단된다면, 그만큼의 밸류를 먼저 알려주는 게 좋죠.\n\n질문이 3,4개 이상이면 사용자는 지치기 시작해요.\n5초 내에 답변하기 어려운 질문이라면 사용자가 고민하게 만들어요. (까다로운 비밀번호 조건이나 이메일 주소 등)\n민감한 질문을 받았을 때 거부감이 커질 수 있어요. 예를 들면 개인 정보에 가까울 수록 입력할 때 비용이 커지는 거죠. (연봉 정보 등)","isDisplayingFeedback":true},{"id":21028,"updatedTime":"2023-04-14T11:55:57+09:00","createdTime":"2023-04-12T16:03:45+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"디자이너가 새로운 도메인을 빠르게 학습하는 법","subtitle":"토스는 일이 굉장히 빠르게 돌아가는 조직이에요. 저는 1년 반 동안 무려 4개의 새로운 분야를 학습해야 했어요. 이때 제가 쓴 방법들을 알려드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"how-to-learn-new-domain","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-07T14:56:37+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21028,"title":null,"description":"저는 토스가 첫 금융권 회사예요. 그래서 입사하기 전에 굉장히 긴장을 했었죠. 왜냐하면 토스는 일이 굉장히 빠르게 돌아가는 조직이라고 들었는데, 금융이라는 새로운 분야를 빠르게 학습하고 따라갈 수 있을지 걱정이 됐거든요.아니나 다를까, 1년 반 동안 무려 4개의 새로운 분야를 학습해야 ...","urlSlug":"how-to-learn-new-domain","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"디자이너가 새로운 도메인을 빠르게 학습하는 법","description":"토스는 일이 굉장히 빠르게 돌아가는 조직이에요. 저는 1년 반 동안 무려 4개의 새로운 분야를 학습해야 했어요. 이때 제가 쓴 방법들을 알려드릴게요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://toss.tech/wp-content/uploads/2023/03/og-image-1536x768.png","imageType":"직접입력"},"relatedPostConfig":{"id":2352,"relatedPosts":[{"id":21035,"updatedTime":"2023-09-17T21:45:50+09:00","createdTime":"2023-04-12T16:04:24+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"문제 원인의 원인을 찾아서","subtitle":"좋은 해결책을 내기 위해서 제가 쓰는 방법은, 문제 원인의 원인을 찾는 거예요. 진짜 문제를 발견하면, 임팩트 있는 해결책을 생각해 낼 확률이 훨씬 높아지죠.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":"","imageAlt":null,"title":"토스 Tools product designer가 궁금하다면?","description":null,"ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/Frame-46.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/Frame-46.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"real-reason","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-02T17:40:06+09:00","commentBoard":null,"disclaimer":null},{"id":21023,"updatedTime":"2023-04-12T17:25:57+09:00","createdTime":"2023-04-12T16:03:12+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"토스 디자인 원칙 Value first, Cost later","subtitle":"토스의 제품 디자인 원칙 중에는 Value first, cost later라는 항목이 있어요. 비용을 말하기 전에 가치를 명확하게 전달해야한다는 내용이에요. 가치를 먼저 보여주는 것 만으로도 지표를 눈에 띄게 개선한 사례를 소개해드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image-1.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image-1.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"value-first-cost-later","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-16T18:49:46+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":577,"name":"김보명","slug":"bomyeong-kim","shortDescription":"Product Designer(Tools)","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/bomyeong-kim.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"저는 토스가 첫 금융권 회사예요. 그래서 입사하기 전에 굉장히 긴장을 했었죠. 왜냐하면 토스는 일이 굉장히 빠르게 돌아가는 조직이라고 들었는데, 금융이라는 새로운 분야를 빠르게 학습하고 따라갈 수 있을지 걱정이 됐거든요.\n\n아니나 다를까, 1년 반 동안 무려 4개의 새로운 분야를 학습해야 했어요. 제한된 시간 안에서 결과물을 내려면 쏟아지는 정보를 빠르게 학습해야 했어요. 하지만 그게 어려운 상황들이 늘 있었죠.\n\n문제\n온보딩할 때 많은 정보를 빠르게 익히는 것이 어렵다.\n\n4개의 분야를 만나며, 각 분야의 방대한 정보와 그것을 빠르게 익혀야 하는 상황은 정말 힘들었어요. 해야 할 일과 이해의 범위가 정해져 있고, 작았던 이전 조직과 다른 상황이었죠. 이후 회고했을 때 저는 주로 2가지의 실수를 반복하고 있었던 것 같아요.\n\n실수 1 – 모든 정보를 사실로 받아들이기\n\n설명해 주시는 분들도 간혹 오류가 있는 정보나, 개인의 생각이 반영된 정보를 주시는 경우도 많았어요. 처음 도메인을 만났을 때는 이런 부분들을 명확히 구분하기가 어려웠어요. 온보딩 과정 중 대부분을 ‘사실’로 인지하고 문제를 해결하려고 했어요. 결국 디자인 단계에서 채워지지 않은 근거나 이해하기 어려운 논리를 발견하고 다시 처음으로 돌아가고는 했어요.\n\n실수 2 – 모든 것을 이해하려고 하기\n\n‘개념부터 완벽히 이해하면, 답은 저절로 찾게 될 거야’\n\n대한민국에서 교육과정을 겪었던 분이라면, 꼭 한번은 들었던 이야기일 것 같아요. 제가 당시 선택했던 전략이었고, 틀린 방법은 아니라고 생각해요. 하지만 저를 기다리는 동료들과, 그 상황에서도 커져가고 있을 문제를 두고 여유롭게 학습하는 것은 비효율이었어요. 당시 저는 이 상황을 이해하지 못하고, 데스크 리서치를 필요 이상으로 갖기 시작했어요. 무엇부터 이해해야 할지 모르니 전부 다 이해해 보겠다는 마음이었죠. 논문까지 찾아보며, 시간 비용을 그대로 낭비하고 있었어요.\n\n이 문제를 해결하지 않으면 계속해서 병목이 될 것 만 같았어요. 항상 억지로 이해하고, 길게 다시 돌아가서 전제를 바로잡거나, 설명자의 주관적인 판단은 반박 or 싱크를 했어요. 혹은 대차게 실패를 경험한 후에 깊은 회고를 하기도 했죠.\n\n이런 식으로 문제가 될 때마다 돌아가는 방법은 제 문제를 본질적으로 해결해 주지는 못했어요. 저는 되돌아가기 보다 나아가고 싶었기 때문인 것 같아요. 과거의 경험들을 바탕으로 문제를 정의하고 해결할 가설을 세웠어요.\n\n가설\n‘온보딩, 싱크, 일을 동시에 할 수 있지 않을까?’\n\n처음부터 모든 것을 이해하기보다 필요한 것부터 이해할 방법을 찾고, 설명을 들으며 동시에 그 정보를 검증하는 것. 그리고 일까지 함께 할 방법이 있을 것 같았어요. 그리고 그 가설을 여러 방법으로 실행에 옮겨 보았어요.\n\n해결책\n1. 내가 모르는 부분을 관찰해 줄 조력자 만들기\n\n\n처음부터 모든 것을 이해할 수 있는 것은 비효율임을 인정하고, 필요한 정보부터 이해할 필요가 있었어요. 하지만 제게 필요한 정보를 어떻게 찾을 수 있을까요? 초심자는 자신이 무엇을 모르는지 조차 알 수 없어요. 이에 도움받기 위해서는. 내 무지 상태를 지속적으로 관찰해 줄 조력자가 필요했어요. 동료를 활용한 메타인지인 것이죠. 동료들도 제게 기대하는 결과가 있기 때문에, 현재 상황에서 필요한 정보부터 강조하여 말해줄 가능성이 높아요. 이때는 몰랐지만, 이 방식이 토스의 코어 밸류인 Learn Proactively의 일환임을 알게 됐어요.\n\n2. 들은 내용 그자리에서 직접 설명해보기\n\n\n앞서 말씀드렸던 ‘설명 받는 정보에 오류가 있거나 개인의 생각이 담겨있을 때’의 어려움과 내가 모르는 부분을 더 발견할 수 있는 방법이에요. 저는 온보딩 중에 제가 직접 다시 설명해 보기로 했어요. 화이트보드를 이용해서요. 학생인 제가 직접 가르치는 입장이 돼보는 것이죠. 이 방식은 유대인의 교육 법인 ‘하브루타’와 유사한 방식이었어요.\n\n*하브루타 – 짝을 이뤄 서로 질문을 주고받으면서 공부한 것에 대해 논쟁하는 정통 유대교 교리를 공부하는 유대인의 전통적인 토론 교육 방법\n\n이 방식으로 제 생각과 설명자의 주장에 싱크를 맞추어 ‘정보의 오류’나 ‘가치 판단 영역’을 구분할 수 있었어요. 대부분 제 설명에서 부족한 정보는 바로바로 채워주시고, 논점이 발견되면 그 자리에서 이야기하고 싱크 할 수 있게 됐어요. 덧붙여서 이때 ‘설명이 막히는 곳’, ‘반박 당하는 곳’을 놓치지 않고 이야기하는 것이 중요한 것 같아요. 몰랐던 부분일 확률이 높고, 논쟁을 벌어야 하는 영역일 가능성이 높아요.\n\n3. 틀릴 것을 전제로 디자인하기\n\n\n아마도 2번이 제대로 진행된 이후라면 대부분의 제품디자이너 머릿속엔 어떤 그림이 나오기 시작할거에요. 2번 이후 간단히 문제와 가설을 정의한 후, 이해한 버전을 그대로 그림을 그려 관계자와 사용자에게 보여주는 방법이에요. 이전에 서로 이해가 달랐던 부분을 디자이너의 그림을 통해 빨리 맞춰갈 수 있어요.\n\n제 경험상 이 때 나왔던 그림이 완전히 틀렸던 경우는 한번도 없었어요. 1~2번의 과정을 거쳐오며 많은 부분 싱크가 되었기 때문이죠. 수정하거나, 고민해야할 부분은 일부였고 전반적인 얼개는 맞았던 기억이 있어요. 이렇게 되었다면, 일은 거의 동시에 진행된거라 보아도 무관할 것 같아요.\n\n결과\n\n\n가설을 세우고, 새로운 방식으로 도메인을 이해하기 시작한 후와, 과거를 비교해 보았어요. 먼저 온보딩부터 첫 디자인 단계를 만나는 시점이 앞당겨졌어요. 그리고 다시 돌아가기보다는 나아가는 방식이 되었죠. 대부분의 단계를 동시에 하게 되니. 절대적인 시간도 줄어들고, 길었던 데스크 리서치 기간도 상당 부분 줄어들게 됐어요. 가장 좋았던 것은 오류 없는 가설로 만든 디자인을 사용자에게 더 빨리 테스트해 볼 수 있다는 점이었어요.\n\n복잡한 도메인을 맞닥뜨리는 작업자라면 누구나 막막함을 경험하셨을 것 같아요. 이런 부분들을 적극적으로 채워주실 수 있는 동료분들이 있고, 몇 가지의 방법만 활용한다면 어떤 도메인을 만나도 필요한 정보를 빠르게 습득할 수 있을 것 같아요.\n\n특히나 데이터 정합성이 중요한 도메인이라면, 초기에 얻은 정보에 bias가 생기지 않도록 관계자와 최대한 싱크를 하는 것이 중요한 것 같아요. 정확히 싱크 되지 않은 채로 탄생한 디자인은 결국 사용자의 문제를 뾰족하게 해결할 수 없게 되고, 개선하는 데에 많은 시간이 걸리게 되기 때문이에요.\n\n적용해보기\n진행하기 전에 꼭 염두 해야 할 점.– 모든 정보들이 ‘가치 중립적’인지 생각해 보기.– 많은 것을 이해하기 보다 필요한 것부터 이해하기.\n\n내가 모르는 부분을 관찰해줄 조력자 만들기.\n식사, 커피챗처럼 캐주얼한 자리에서 예고하기.\n팀 내에서 직무별로 조력자 만들기. (도메인, 테크)\n예 : ‘데이터 구조에 대해 모르는 것이 많아요. 앞으로 자주 물어보게 될 것 같은데 괜찮을까요?’ → 99%는 “언제든지 물어봐 주세요!”라고 답변 받음.\n들은 내용. 그자리에서 직접 설명해보기\n설명이 틀릴까 봐 긴장된다면, 말하기 전에 양해 구하기.\n예 : “처음 듣는 정보들이라, 많이 틀리겠지만. 들은 내용들을 설명해 볼게요.”\n틀릴 것을 전제로 디자인하기\n생각이 다른 부분을 중점으로 이야기달라고 말하기.\n이 디자인은 완성된 것이 아님을 공유하고, 논의 시작하기.\n자꾸만 되돌아가게 되는 단계, 방대하고 어려워보이는 도메인 때문에 어려움을 겪고 계신다면, 이 방법들을 사용해보시면 어떨까요?","isDisplayingFeedback":true},{"id":21035,"updatedTime":"2023-09-17T21:45:50+09:00","createdTime":"2023-04-12T16:04:24+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"문제 원인의 원인을 찾아서","subtitle":"좋은 해결책을 내기 위해서 제가 쓰는 방법은, 문제 원인의 원인을 찾는 거예요. 진짜 문제를 발견하면, 임팩트 있는 해결책을 생각해 낼 확률이 훨씬 높아지죠.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":"","imageAlt":null,"title":"토스 Tools product designer가 궁금하다면?","description":null,"ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/Frame-46.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/Frame-46.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"real-reason","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-02T17:40:06+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21035,"title":null,"description":"토스 팀원이면 누구나 개인 법인 카드를 1장씩 가지고 있어요. 이 카드로 식대나 택시비, 교육비 등 업무와 관련된 것이라면 자율적인 판단 하에 결제할 수 있어요. 자유롭게 사용하되, 모바일 또는 PC로 어디에 사용했는지 그 용도와 내역을 적어 제출해야 해요. 재무팀에서 그 내용을 바탕으...","urlSlug":"real-reason","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"문제 원인의 원인을 찾아서","description":"좋은 해결책을 내기 위해서 제가 쓰는 방법은, 문제 원인의 원인을 찾는 거예요. 진짜 문제를 발견하면, 임팩트 있는 해결책을 생각해 낼 확률이 훨씬 높아지죠.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/Frame%2045.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2351,"relatedPosts":[{"id":21028,"updatedTime":"2023-04-14T11:55:57+09:00","createdTime":"2023-04-12T16:03:45+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"디자이너가 새로운 도메인을 빠르게 학습하는 법","subtitle":"토스는 일이 굉장히 빠르게 돌아가는 조직이에요. 저는 1년 반 동안 무려 4개의 새로운 분야를 학습해야 했어요. 이때 제가 쓴 방법들을 알려드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/og-image.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"how-to-learn-new-domain","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-07T14:56:37+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":576,"name":"강효정","slug":"hyojeong-kang","shortDescription":"Product Designer(Tools)","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/hyojeong-kang.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":2,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스 팀원이면 누구나 개인 법인 카드를 1장씩 가지고 있어요. 이 카드로 식대나 택시비, 교육비 등 업무와 관련된 것이라면 자율적인 판단 하에 결제할 수 있어요. 자유롭게 사용하되, 모바일 또는 PC로 어디에 사용했는지 그 용도와 내역을 적어 제출해야 해요. 재무팀에서 그 내용을 바탕으로 매달 법인 카드 결산 업무를 해야 하거든요.\n\n문제\n매달 반복되는 이 업무에 큰 문제가 있었어요. 바로 마감 기한 내에 영수증을 제출하지 않는 팀원이 40%가 넘는다는 것인데요. 재무팀에서는 법인 카드 결산을 해야 하는 일정이 있고 미작성된 영수증을 허위로 적을 수 없기 때문에 기한을 어긴 팀원들 한명 한명에게 메세지를 보내 얼른 적어달라고 부탁을 해야 했죠.\n\n이 비효율적인 일을 매달 반복해야 한다니, 그냥 지나칠 수 없겠죠?\n\n가설\n그럼 팀원들은 왜 마감 기한을 지키지 못할까요? 팀원들이 실제로 영수증을 적는 모습을 관찰하고 인터뷰하며 이런 가설을 세웠어요.\n\n영수증을 쓰는 과정이 너무 불편해서 미루다가 기한을 놓친다.\n\n평균적으로 하루에 한 번 정도 법인 카드를 사용한다고 했을 때, 한 달에 약 20개의 영수증이 생겨요. 결제를 하고 영수증을 바로 적으면 1분이 채 걸리지 않지만 앱을 켜는 순간부터 답답하고 불편해서 나중에 적어야지 미루게 되고, 몰아서 한번에 적으려고 하니 어디에 썼나 기억도 잘 안나고 양도 많아져서 오래 걸리고… 그러다가 결국 마감 기한을 놓치게 된다고 생각했어요.\n\n해결\n그럼 이 제품은 왜 사용이 불편했을까요? 영상을 보면서 어떤 점이 불편한지 한번 찾아보시겠어요?\n\n첫 번째로, 식대 영수증을 적는 모습을 녹화한 영상인데요.\n\n문제가 보이시나요? 사실 이것만으로는 뭐가 문제인지 알기가 어려워요. 실제로 팀원들이 영수증을 적는 모습을 관찰할 땐 영상처럼 1개가 아니라 여러 개를 적는 모습을 봐야 해요. 그리고 한 사람이 아니라 여러 사람을 관찰해야 하고요. 그래야 여러 명이 반복적으로 겪는 불편함이 무엇인지 파악할 수 있고 비로소 문제가 뾰족해지기 시작하거든요.\n\n저는 3명 정도 관찰했고 매월 팀원들의 법인 카드 사용 내역이 적힌 엑셀 시트도 몇 달치를 쭉 훑어봤어요. 여러분은 아래 시트에서 어떤 점이 눈에 띄세요?\n\n\n모두가 ‘식대’ 영수증을 적은 건데 사용 내역이 제각각이었어요. 작성 가이드가 있긴 했지만 이걸 아는 사람도 있고 모르는 사람도 있었어요. 그래서 그냥 각자가 아는 방식으로 다양하게 적게 된 것이죠.\n\n이렇게 저마다 다르게 쓰는데 사용내역이라는 게 재무팀에게 정말 의미 있는 데이터일까요? 이를 확인하기 위해 재무팀에서 꼭 받아야 하는 정보와 이유를 물어봤고 ‘먹은 사람의 이름만 정확하게 적으면 된다’는 답변을 받았어요.\n\n정리하면, 사용자 인터뷰와 시트에서 발견한 식대 영수증의 문제는 이런 것들이었어요.\n\n사용성 문제\n\n어차피 대부분이 식대인데 계정 과목(사용용도)을 매번 선택해야 함\n같이 먹는 사람이 항상 비슷한데 매번 새롭게 적어야 함\n점심, 식대, 재택 등 굳이 적지 않아도 될 내용들을 몰라서 매번 적고 있음\n데이터 문제\n\n같이 먹은 사람의 이름을 적지 않거나 정확한 이름을 적지 않음(성이나 동명이인 구분용 알파벳을 빼고 적음)\n\n여러분이라면, 이 문제를 어떻게 해결하시겠어요?\n\n\n선택하거나 적어야 할 항목을 최소화하기 위해 가능한 것들은 자동화했고 사용자로부터 받아야 하는 정보를 정확하게 받을 수 있는 장치를 넣었어요.\n\n결제처가 음식을 파는 업종일 때, 사용용도를 식대로 자동 선택해주기\n사용내역을 자유롭게 적는 것이 아닌, 꼭 적어야 하는 식사한 사람 이름만 선택할 수 있게 바꾸기\n내 이름은 기본으로 적어주기\n최근에 같이 먹은 사람 리스트 보여주기\n팀원의 이름을 직접 적는게 아니라 검색 > 선택으로 바꿔서 정확한 이름 받기\n\n\n두 번째로 많은 영수증인 야근택시비를 적는 과정을 볼게요.\n\n택시 앱의 결제 방식을 아는 분이라면 이번 영상에서는 무엇이 문제인지 캐치하셨을 것 같아요. 바로 택시는 1번 탔는데 영수증은 3개가 생긴다는 점인데요.\n\n앱으로 택시를 부르던 경험을 한번 떠올려보세요. 출발지와 목적지를 선택하면 예상 금액이 나오죠? 택시를 잡으면 그 금액으로 일단 결제가 돼요. 그리고 도착지에서 내리면 최종 금액으로 다시 결제가 되고 이전에 결제했던 건은 취소가 돼죠.\n\n그래서 영수증이 3개나 생기는데요. 문제는 이 3개를 처리하는 과정이 영상에서 보신 것처럼 너무 번거로운거죠.\n\n그리고 사용 내역 역시 식대처럼 다양한 형태로 적고 계셨어요.\n\n\n야근 교통비는 사용 내역을 구체적으로 적을 필요 없다는 재무팀의 의견을 받아 이렇게 해결했어요.\n\n선결제와 취소 영수증은 시스템에서 알아서 처리하고 사용자에게는 최종 영수증만 보여주기\n결제처가 택시 앱이고 결제시간이 22시~06시 사이면 사용 용도와 사용 내역을 모두 야근 교통비로 자동 선택, 적어주기\n영수증 상세 페이지에 진입하지 않아도 자동으로 적힌 내용이 맞는지 확인하고 빠르게 제출할 수 있도록 숏컷 제공하기\n모든 것을 자동화했고 제출 전 오류가 없는지 확인할 수 있도록 사용자의 최종 컨펌 단계만 남겨두었어요.\n\n\n결과\n앞에서 마감 기한을 놓치는 팀원이 약 40%가 된다고 했던 것 기억하시나요? 제품 개선 이후 이 비율이 무려 5%로 줄었어요. 95%의 팀원들이 제때 영수증을 낸다는 것이죠. 그 결과 재무팀의 커뮤니케이션 비용도 그만큼 줄일 수 있었어요.\n\n해결책이 그렇게 대단하거나 특별한 게 아님에도 효과는 엄청나지 않나요?\n\n\n적용해보기\n좋은 해결책을 내기 위해서 제가 쓰는 방법은, 문제 원인의 원인을 찾는 거예요.\n\n해결해야 하는 문제를 한 문장으로 적는다.\n예: 마감 기한 내에 영수증을 제출하지 않는 팀원이 40%가 넘는다.\n문제에 계속 질문을 하고 답을 한다.\n예: 왜 마감 기한을 놓치지? 한 달치를 한 번에 적으려다 보니 너무 많아서 → 왜 한 달치를 한번에 적지? 그때 그때 적기 귀찮아서 → 왜 적기 귀찮지? → 영수증 쓰는 게 불편해서 → 왜 불편하지? → 적어야 할 게 많아서 → 왜 적어야 할 게 많지? → 식대도 선택해야 되고 같이 먹은 사람도 적어야 되니까 → 꼭 적어야 되는 정보인 건 맞아? → 적어야 하는 정보인 건 맞아 → 그럼 왜 직접 적어야 하지? 자동으로 적어줄 순 없어?…\n이렇게 질문을 반복하다 보면 근본적인 문제를 발견할 수 있어요. 일단 이 문제를 발견하고 나면, 임팩트 있는 해결책을 생각해 낼 확률이 훨씬 높아지죠.\n\n내가 내는 해결책이 항상 그저 그렇다 싶으면, 이 방법을 써보시는 건 어떨까요?","isDisplayingFeedback":true},{"id":21017,"updatedTime":"2023-04-14T11:56:46+09:00","createdTime":"2023-04-12T16:02:33+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"우리에게 당연하지만 사용자는 아닌 것들","subtitle":"사용자 관점에서 본다는 게 엄청난 게 아닌데도, 왠지 엄청난 것으로 개선해야 할 것 같은 느낌이 들 때도 있죠. 그래서 오늘은 사용자 관점을 활용해 개선한 굉장히 가벼운 사례들을 가져와봤어요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/01/d-TechBlog-Image-3.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/01/d-TechBlog-Image-3.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"thinking-user-perspective","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-01-19T18:15:32+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21017,"title":null,"description":"제품을 디자인하다 보면 사용자의 관점이 아니라 메이커의 관점에서 생각하게 될 때가 있어요. 디자이너라면 ‘당연히 사용자의 관점에서 봐야 한다’고 생각하지만, 제품을 오래 만들다 보면 너무 당연해 보여서 사용자의 관점을 놓치게 되기도 하죠.사용자 관점에서 본다는 게 엄청난 게 아닌데도, ...","urlSlug":"thinking-user-perspective","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"우리에게 당연하지만 사용자는 아닌 것들","description":"사용자 관점에서 본다는 게 엄청난 게 아닌데도, 왠지 엄청난 것으로 개선해야 할 것 같은 느낌이 들 때도 있죠. 그래서 오늘은 사용자 관점을 활용해 개선한 굉장히 가벼운 사례들을 가져와봤어요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.tosspayments.com/public/permanent/service/contents/tech-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2353,"relatedPosts":[{"id":21024,"updatedTime":"2023-07-05T22:07:39+09:00","createdTime":"2023-04-12T16:03:17+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"내 아이디어를 너무 믿지 마세요","subtitle":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"dont-trust-your-gut","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-28T17:31:40+09:00","commentBoard":null,"disclaimer":null},{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":578,"name":"김소현","slug":"sohyeon-kim","shortDescription":"Product Designer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/sohyeon-kim.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"제품을 디자인하다 보면 사용자의 관점이 아니라 메이커의 관점에서 생각하게 될 때가 있어요. 디자이너라면 ‘당연히 사용자의 관점에서 봐야 한다’고 생각하지만, 제품을 오래 만들다 보면 너무 당연해 보여서 사용자의 관점을 놓치게 되기도 하죠.\n\n사용자 관점에서 본다는 게 엄청난 게 아닌데도, 왠지 엄청난 것으로 개선해야 할 것 같은 느낌이 들 때도 있죠. 그래서 오늘은 사용자 관점을 활용해 개선한 굉장히 가벼운 사례들을 가져와봤어요.\n\n사용자에게 익숙하지 않은 UI 개선하기\n토스에는 ‘내 소비’라는 제품이 있는데요, 내가 토스에 연결한 계좌와 카드의 수입, 지출, 이체 내역을 한곳에 모아서 보여주는 기능이에요.\n\n\n현재 내 소비 디자인\n\n지금의 모습과는 많이 다르지만, 제가 초기 ‘내 소비’를 디자인했을 때 고민했던 점을 소개해 드릴게요.\n\n초기의 ‘내 소비’에서는 수입, 지출, 이체 내역이 만들어진 시간 순서대로 쌓이게 되는 리스트를 제공하는 것이 핵심 사용성이었어요. 그러다 보니 최근의 소비 내역을 건별로 하나하나 확인하기에는 좋았지만 오늘, 어제, 특정일 언젠가의 소비 합계는 얼마인지, 돈이 언제 얼마나 들어왔고 나갔는지 한눈에 파악하기 어려웠어요.\n\n그래서 달력과 같은 형태로 월 단위로 소비 내역을 한눈에 보고 싶다는 사용자의 보이스를 여러 차례 받게 되면서 소비내역에 달력을 넣기로 했어요.\n\n\n달력을 넣기 전/후 디자인\n\n\n달력을 여는 인터렉션 프로토타입\n\n위의 프로토타입과 같이 서랍을 열듯이 화면을 터치한 후 아래로 끌어내리면 달력이 펼쳐지는 방식이예요.\n\n프로토타입으로 사내 동료분들 대상으로 사용성 테스트를 해보니 대체로 어려움 없이 달력을 발견하고 여닫는 방법을 쉽게 이해한다고 보여졌어요. 사용성에는 문제가 없다고 판단하고 실제 사용자들에게 내보내 이용 추이를 살펴보고 달력의 유용성을 검증해 보기로 했어요.\n\n다수의 사용자 요청이 있었고 그에 응하는 기능 개발이었기 때문에 내 소비를 이용 중인 사용자라면 반갑게 달력을 이용해 줄 것이라고 기대했어요.\n\n그런데 결과는 기대와 달리 달력을 열어보는 사용자들의 수가 너무 적었어요.\n\n이후 실제 사용자의 사용성 인터뷰를 통해 달력을 여닫는 UI 동작을 쉽게 눈치채지 못하는 사례를 발견했고 달력이 이미 있음에도 이를 인지하지 못하고 달력이 필요하니 만들어 달라는 보이스가 여전히 들어오기도 했죠.\n\n일반 사용자들은 상대적으로 메이커만큼의 높은 UI 이해력을 가지고 있지 않을 수 있다는 사실을 간과한 것이 문제였어요.\n\n작은 공수로 빠르게 문제를 해결해 보기 위해 달력을 여닫는 모션을 보여주는 튜토리얼을 넣기도 하고 최초 1회 달력이 열린 상태로 화면을 마주하도록 만들어보기도 했어요.\n\n그럼에도 달력을 열어보는 사용자의 수가 여전히 적어서 우리 팀은 보다 과감한 변화를 주기로 했어요.\n\n\n사용자에게 익숙한 ‘탭’형태의 UI로 개선한 디자인\n\n위 이미지가 개선된 화면이에요.\n\n스마트폰을 이용하는 사용자라면 누구나 한 번쯤 사용해 보았을 익숙한 ‘탭’형태의 UI를 활용했어요.\n\n그 결과 개선 이후 달력을 열어보는 사용자가 네 배 정도 늘어났어요. 작동 방식을 이해하는데 비용이 들지 않는 익숙하고 단순한 UI 활용으로 진입점에 대한 인지도가 월등히 높아졌기 때문이에요.\n\n자주 봐서 익숙하고 특별하지 않지만 누구나 쉽게 떠올릴 수 있는 UI가 사용자 관점에서는 가장 쉬운 UI였던 거예요.\n\n제품을 만드는 나에게 익숙한 UI가 사용자에게도 익숙한 UI는 아니라는 것, 사용자 관점에서도 익숙한 UI가 이긴다는 것을 큰 비용을 들여 되새기는 계기가 되었어요.\n\n사용자가 오해할 만한 기능 개선하기\n하나의 사례를 더 소개 드릴게요.\n\n\n이체 내역의 메모 남기기\n\n내 소비 내역 또는 이체 내역을 상세하게 볼 수 있는 화면이에요.이 화면에는 내역에 대한 간단한 메모를 남길 수 있는 기능이 있어요.\n\n당시 이 기능을 쓰던 사용자 분들이 ‘메모가 자꾸만 사라진다‘라는 의견을 남겨주셨어요. 개발자 분은 ‘혹시 메모에 특수문자가 들어가있는 것 아닐까?‘라는 생각에 어떤 문제가 있는지 확인하게 되었어요. 그러다 혼잣말이 아닌 대화를 시도하는 느낌으로 남겨진 메모를 발견했어요.\n\n이를 계기로 물음표로 끝나는 메모들을 골라내니 꽤 여러 건의 질문과 대화를 시도하는 메모들이 발견되었는데 대략 100건 중 5~10건 정도라고 파악되었어요.\n\n해당 건은 버그를 해결하기 위해 필수적으로 내용 확인이 필요했던 케이스예요. 당시 소비 메모 기능을 쓰던 사용자분들이 ‘메모가 자꾸만 사라진다’라는 의견을 남겨 주셨어요. 이러한 문제를 해결하던 과정에서 일부 사용자가 메모 기능을 채팅으로 착각하고 있다는 것을 발견했어요.\n채팅으로 추정되는 메모는 누구의 것인지 전혀 알 수 없어요. 식별자는 전부 암호화되어 관리되고 있기 때문이에요.\n또한, 메모에 접근 가능한 개발자는 매우 엄격하게 제한되어 있어요.\n개인적인 메모를 남기는 사람이 가장 많았지만, 어떤 사용자들은 메모 남기기를 고객센터에 보내는 메모라고 이해해서 CS 문의를 남기기도 했고, 어떤 사용자들은 이체 대상자에게 메세지를 보낼 수 있는 기능이라고 이해하기도 했어요.\n\n개인의 카드/계좌를 연결하고 불러온 내 소비 내역이기 때문에 메모 역시 개인적인 기록이라고 이해하는 것이 당연하다고 생각했는데 사용자들에게는 당연한 것이 아니었어요.\n\n비교적 적은 사용자가 겪는 문제였지만 우리팀은 작은 개선으로 이 문제를 해결해보기로 했어요.\n\n\n개선된 메모 UI\n\n메모를 입력하는 화면 하단에 ‘나만 볼 수 있는 메모’ 라는 텍스트를 넣어주는 방법으로요.\n\n‘이건 사용자 관점이 아니다’ 라는\n문제 의식을 캐치하는 팁을 공유하자면\n\n내가 만든 디자인으로 팀을 설득하는 과정 중 다음과 같은 문장을 사용하게 된다면 사용자 관점을 잠시 내려두고 있는 상태일 수 있음을 의심해 보세요.\n\n① “이건 당연히 알 수 있는 거 아닌가?”당연히 알 수 있을 것 같은데 이걸 왜 모르지? 라는 생각이 들었다면 그 이유는 나는 사용자가 아니기 때문이라는 것을 위의 두 사례로 배웠어요.사용자는 연령에 따라, 디바이스나 서비스 이해 정도에 따라, 경험의 유무에 따라, 또 디자인의 전달력에 따라 이해의 정도가 다르기 때문에 공급자의 의도를 당연하게 알아줄 수 없어요.\n\n② “어려울 수도 있긴 한데 일단은~”→ 내 안의 공급자적 자아가 사실은 쉽게 풀어내지 못한 디자인임을 스스로도 알고 있지만 이 정도에서 타협하고 싶을 때 나오게되는 말이에요.\n\n③ “원래 어려운 개념이라~”→ 원래 이런거다 라는 식으로 이해를 구하고 있는 스스로를 인지했다면 거기에서 멈추어야해요. 원래 어려운 것을 쉽게 만드는 것이 프로덕트 디자이너의 책임이니까요.고백하자면 저 역시 자주 꺼내게 되는 말이에요. 원래 쉬운 것을 역시나 쉽게 풀어내는 일만 잘해내는 디자이너가 될 순 없지! 라고 여러 순간 되새기고 있답니다.\n\n④ “이건 빠르게 잠깐 내보낼 실험이라서 괜찮아”→ 적은 모수의 사용자에게 빠르게 실험해보는 거니까~ 라는 것이 면죄부가 될 수 없어요. 우리는 실험용 화면과 영원히 보존할 용도의 화면을 구분해서 디자인하지 않고, 토스앱 안에서는 다양한 제품의 여러 실험이 동시에 진행되고 있어요. “실험이라서 이정도의 어려움, 이정도의 조금 덜 정돈된 전달력이어도 괜찮아” 라는 생각이 허용되면 디자이너에게는 잠깐일 수 있지만 사용자는 그 잠깐의 경험이 거듭 쌓이게 되면서 어렵고 어설픈 경험을 연쇄적으로 감당해야 하게 되니까요.\n\n사용자 관점으로 생각한다는 것은 ‘코어에 힘주기’와 같이 의식적으로 노력하지 않으면 결코 저절로 되지않아서 어려워요.\n\n사용자를 가까이에서 더 자주 만나면서 내 제품을 낯설게 바라볼 수 있는 기회를 만들고, 정량적으로 드러나는 사용 패턴을 확인하며 사용자가 겪는 어려움을 기민하게 알아가는 것이 사용자 관점으로 사고하는 힘을 키워 나가는 유일하지만 강력한 방법이라고 생각해요.","isDisplayingFeedback":true},{"id":21038,"updatedTime":"2023-05-23T12:57:09+09:00","createdTime":"2023-04-12T16:04:40+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"잘 만든 시스템 하나로 미친 효율 얻는 방법","subtitle":"‘원래 하던 일’을 단순히 똑같이 해내는 것이 아니라, ‘더 잘하게 만드는 도구’를 만들어서 원래 하던 일을 훨씬 더 빠른 속도로 해낼 수 있어요. 효율이 복리로 쌓이게 만드는 거죠.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":null,"ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/01/본문.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/01/본문.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"how-to-make-marvelous-productivity-with-well-made-system","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-01-12T19:05:56+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21038,"title":null,"description":"토스에는 팀원들이 업무를 잘할 수 있게 하루 종일 도와주는 인터널 제품들이 있어요. 이런 제품들은 운영 비용을 절감하고 업무를 효율적으로 돕는 중요한 가치를 제공해요.인터널 프로덕트 디자이너는 이런 인터널 제품을 만드는 것은 물론, 이 제품을 쓰는 데에 드는 운영 비용을 줄이는 일도 함...","urlSlug":"how-to-make-marvelous-productivity-with-well-made-system","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"잘 만든 시스템 하나로 미친 효율 얻는 방법","description":"‘원래 하던 일’을 단순히 똑같이 해내는 것이 아니라, ‘더 잘하게 만드는 도구’를 만들어서 원래 하던 일을 훨씬 더 빠른 속도로 해낼 수 있어요. 효율이 복리로 쌓이게 만드는 거죠.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-13.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2348,"relatedPosts":[{"id":21024,"updatedTime":"2023-07-05T22:07:39+09:00","createdTime":"2023-04-12T16:03:17+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"내 아이디어를 너무 믿지 마세요","subtitle":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"dont-trust-your-gut","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-28T17:31:40+09:00","commentBoard":null,"disclaimer":null},{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":574,"name":"오지은","slug":"jieun-oh","shortDescription":"Product Designer(Tools)","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/jieun-oh.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"세 번 이상 반복하고 있는 업무가 있나요?\n토스에는 팀원들이 업무를 잘할 수 있게 하루 종일 도와주는 인터널 제품들이 있어요. 이런 제품들은 운영 비용을 절감하고 업무를 효율적으로 돕는 중요한 가치를 제공해요.\n\n툴즈 프로덕트 디자이너는 이런 인터널 제품을 만드는 것은 물론, 이 제품을 쓰는 데에 드는 운영 비용을 줄이는 일도 함께 하고 있어요.\n\n그런데, 조직의 규모가 커지면서 불편한 점들이 생겼어요. 필요한 기능이 계속 늘어나는데 만들 사람은 부족했거든요. 그리고 같은 기능을 여러 사람이 각자 바닥부터 고민해서 만드는 비효율적인 상황도 생겼어요.\n\n인터널 제품들 중에는 CH팀이나 오퍼레이션 등의 팀원들의 업무를 돕기 위해 여러가지 기능을 제공하는 제품이 있어요.\n\n그 중에 권한을 관리하는 기능을 예시로 들어볼게요. 팀원이 권한을 신청하면 관리자가 부여하고 관리하는 기능이에요.\n\n이 기능은 복잡하지만 아주 기본적인 기능이어서 모든 계열사에서 필요해요. 그런데 각 계열사에서 제품이 새로 생길 때마다 똑같은 기능을 밑바닥부터 다 따로 만들고 있었어요.\n\n\n왼쪽 : 계열사 1의 상담 관리 제품에서 만든 권한 관리 기능오른쪽 : 계열사 2의 유통 관리 제품에서 만든 권한 관리 기능\n\n또 다른 예시로 돈을 잘못 송금했을 때 돈을 돌려받도록 도와주는 착오송금 기능이 있어요.\n\n이것도 한 번만 고민해도 오래 걸리는데 코어, 뱅크 등 계열사마다 다 따로 만들어야 하니까 너무 비효율적이잖아요. 게다가 일반, 미성년자, 토스아이디 등 송금 종류별로도 다 따로 고민해서 만들어야 하는 거예요.\n\n그러면 이런 문제를 어떤 과정으로 해결해나갔는지 알려드릴게요.\n\n비효율적이지만 하나하나 개선하기\n제일 처음 한 일은 무작정 제품 개선하기였어요.\n\n일단 다 뜯어보기 전에는 수십, 백몇 가지 백로그 중에 어떤 경험들이 반복되거나 유사한지 알기가 어렵거든요. 기능을 하나씩 개선해나가면서 어떤 공통된 규칙을 찾을 수 있는지 파악하는 거예요.\n\n그 시작은 상담에 필요한 업무들을 처리하는 ‘비바매니저’라는 제품이었어요. 오랜 시간 여러 사람들이 규칙 없이 개발하는 바람에 통일된 사용 경험을 주지 못하는 상황이었죠.\n\n\n불필요하게 나눠진 정보를 통합하고 분산된 운영 경험을 하나로 이어주었어요.이런 단순한 작업만으로도 효율을 낼 수 있어요.\n\n이 제품을 개선하는 처음 몇 개월은 기능을 직관적으로 사용하고 정보를 효율적으로 파악하게 만드는 작업을 했어요. 예를 들면 함께 봐야하는 정보를 모아주고, 다른 제품을 오가는 비용이 일어나지 않도록 기능을 연결해주는 것처럼요.\n\n그런 것들을 다 해결하고 나니까 자동화할 수 있는 것들이 보이기 시작했어요.\n\n예를 들어 CH 팀이 고객에게 송금 내역 등의 문서를 보내줄 때 고객이 불러준 이메일 주소를 받아 적고, 고객에게 동의를 받았다고 기록하고, 비밀번호로 잠긴 파일을 다운받고, 보안 환경에서 일반 인터넷 환경으로 파일을 옮기고, 구글 메일로 고객에게 파일을 보내고, 다시 보안 환경에서 이메일을 보내는 일련의 과정을 건당 평균 45분에 걸쳐 처리하고 있었어요.\n\n\n이런 복잡한 과정을 하게 자동화해서 5분 내로 처리할 수 있게 도와주는 거죠. 이런 식의 자동화를 또 몇 개월 하면서 운영 비용을 줄여나갔어요.\n\n1년 간 쌓인 문제들에서\n패턴을 발견하고 시스템으로 만들기\n\n자동화를 포함해서 1년 간 60가지가 넘는 운영 비효율을 하나하나 해결했어요. 그러고 보니까 통일된 경험으로 묶을 수 있는 패턴들이 보이기 시작했어요.\n\n비슷하게 반복되는 경험들\n\n송금 내역, 상담 내역 등 정보를 검색하는 경험들\n계정 차단, 비밀번호 초기화, 주문 취소, 수수료 면제 등을 처리하는 관리 경험들\n착오 송금, 부정 거래건 등 특정 내역을 기관에 접수하고 진행 상태를 관리하는 경험들\n다양한 상황에서 데이터를 수정하거나 추가하는 경험들 등\n\n비슷한 경험들을 묶어서 규칙을 만들어내는 과정\n\n여러 제품에서 필요한데 할 때마다 새로 고민하는 것들\n\n로그인과 본인 인증하는 과정 구현하기\n권한을 관리하고 운영하는 기능 구현하기\n메뉴 구조를 만들고 전체적인 레이아웃을 구성하기 등\n\n계정 차단, 비밀번호 초기화, 주문 취소, 수수료 면제 등을 처리하는 운영 기능에 대한 패턴\n\n처음에는 다 다른 문제라고 생각해서 할 때마다 새로 개선했던 것들이 알고 보니 비슷한 경험이어서 하나의 해결책으로 통일될 수 있었던 거죠. 이런 것들을 모으고 규칙으로 만들어서 20가지 정도의 패턴으로 시스템화했어요.\n\n\n정보 구성에 대한 패턴\n\n그 결과, 지금은 비바매니저라는 제품의 93%를 이 패턴으로 자동화할 수 있게 됐어요.\n\n이렇게 했더니 팀에서는 제품에 필요한 정보나 기능을 빠르게 업데이트할 수 있게 되었어요. 개발자가 하나하나 힘들게 개발하지 않아도 되도록 짧은 명령어를 입력하는 것만으로 기능을 쉽게 추가할 수 있도록 구현했거든요.\n\n그리고 무엇보다 익숙하고 일관되게 사용 경험이 통일되어 CH 팀이나 오퍼레이션 메니저 분들이 기능마다 따로 학습하는 문제가 훨씬 줄어들었어요.\n\n여러 제품, 다른 계열사까지 전파되고 있는 시스템\n이런 유용한 시스템을 한 제품에서만 쓴다는 건 아까운 일이었어요.\n\n토스에서는 인터널 제품을 두 개 이상 사용해서 일하는 경우가 절반 가까이 되는데 아직도 제품들은 각기 사용성이 다르고 학습 비용이 높았거든요.\n\n그래서 우리 팀에서는 이 시스템을 다른 제품에도 적용할 수 있지 않을까? 하는 생각을 했고 인터널 플랫폼 팀에서도 공감하여 플랫폼을 구축해 주었어요.\n\n이 플랫폼은 우리 팀이 아닌 그 누구라도 이 시스템을 사용할 수 있게 도와주는 환경이에요. 반복적인 고민을 하지 않아도 되고 개발 비용도 대폭 줄일 수 있다는 장점이 시스템 전파에 불을 붙이기 시작했어요.\n\n이 과정에서 여러 추가 가치를 제공하게 되었는데요. 예를 들면 시스템이 업데이트되면 플랫폼을 사용하는 모든 제품과 계열사가 그 혜택을 누릴 수 있게 됐어요. 각 계열사의 망분리 환경에서도 이 플랫폼을 사용할 수 있고, 개인 정보 마스킹, 접근통제, 이중 본인인증, 파일 암호화 등 플랫폼에서 자체적으로 보안 장치가 되어있어서 보안에 대한 고민을 제품마다 따로 할 필요가 없어졌어요.\n\n현재 토스 증권 원장 관리 시스템, 토스 페이 어드민, AML 시스템 등 이미 전사의 많은 팀과 계열사에서 어드민 플랫폼 환경 위에서 제품을 구현하고 사용하고 있어요.\n\n복리 효과를 내는 습관과 시선 갖기\n사실 전체적인 효율을 봤을 때 결과는 좋았지만 과정은 순탄하지만은 않았어요.\n\n시스템화하는 작업이 처음이라 규칙을 잘못 만들어 여러 번 고치기도 하고, 제품 개발도 병행하니까 초반에는 시간이 두 배나 걸렸거든요.\n\n하지만 1년간 문제를 반복한 팀원 모두가 이것의 중요성을 알고 포기하지 않았고, 시스템을 활용하니 초반 두 배의 시간이 걸린 것을 만회하고도 남는 폭발적인 속도를 낼 수 있었어요. 또한 제품에 적용하는 과정에서 이터레이션을 돌며 시스템이 점차 견고해졌어요.\n\n\n함께 자라기 애자일로 가는 길(김창준 저)\n\n이런 식으로 일하는 방식은 ‘함께 자라기’라는 책에서도 소개하는 일의 복리 효과와도 같아요.\n\n‘원래 하던 일’을 단순히 똑같이 해내는 것이 아니라, ‘더 잘하게 만드는 도구’를 만들어서 원래 하던 일을 훨씬 더 빠른 속도로 해낼 수 있어요. 효율이 복리로 쌓이게 만드는 거죠. 비효율적인 상황을 참지 못하는 마음 하나가 일을 훨씬 더 효율적으로 돕는 도구를 만드는 계기가 되는 거예요.\n\n그리고 이 과정에서 나와 팀이 함께 성장할 수 있어요. 토스에서 툴즈 프로덕트 디자이너로 일하면서 이런 ‘더 잘하게 만드는 도구’ 를 만들고 더하기가 아닌 곱하기 속도를 낼 때 가장 큰 보람을 느껴요.\n\n💡 우리 팀에 적용하는 방법\n그러면 이런 ‘더 잘하게 만드는 도구’는 어떻게 만들까요?\n\n1단계 과거에 어떤 일을 했는데 지금 또 비슷한 일을 하고 있다면 앞으로 또 이런 일이 생길 것 같은지 생각해 봅니다.\n\n🤔 토스 코어에서 제품 사용 권한을 관리하는 기능을 만들었는데, 알고 보니 증권에서도 따로 만들고 있었다. 그렇다면 뱅크에서도 앞으로 만들게 될까?\n\n2단계 과거에 일했던 지금의 과정을 규칙으로 만들어서 간단히 정리해 보세요. ‘이런 일은 이런 방법으로 해결한다.’라는 식으로요. 개발하거나 디자인을 거창하게 할 필요 없이 정리만요.\n\n🤔 권한 관리 기능을 만들 때는 팀원이 권한을 이렇게 신청하고 관리자가 이렇게 관리하게 한다는 플로우를 항상 동일하게 사용해야겠다.\n\n\n3단계 또 반복적인 일을 하게 되었을 때 이 규칙대로 그 일을 해보는 거예요. 그러면서 규칙을 더 쉽고 간단하게 다듬는 거죠. 활용되지 않는 규칙은 없애고, 많이 활용되는 규칙은 더 정교하게 만들어요.\n\n🤭 권한 관리 기능을 바닥부터 구현하지 않고 패턴만을 활용해서 증권과 플레이스에서도 제품에 바로 적용해 볼까?🤔 흠… 해보니까 여러 권한을 그룹으로 묶어주는 기능은 코어에서만 필요하니까 공통 규칙에서 제외하자.\n\n팁 : 잘 안 맞는 규칙에 기능을 억지로 끼워 맞추느라 불편한 사용 경험을 주지는 않는지 고민해 보는 과정도 중요해요. 그런 과정으로 만든 규칙은 확장성이 좋아지고, 그저 일관되기만 하는게 아니라 직관적으로 제품 사용 경험을 전달해요.\n\n여기까지만 해도 충분히 나만의 도구가 완성됩니다. 일단 이것은 내 업무에서 적극적으로 활용할 수 있어요.\n\n4단계 위의 과정을 충분히 해봤다면, 그 도구들 중에 효과가 큰 일이 무엇인지 생각해 봐요. 일의 발생 빈도, 건당 소요 시간, 일을 하는 사람의 수, 휴먼 에러에 대한 리스크의 크기 등을 기준으로 따져보면 우선순위가 생길 거예요.\n\n🤔 패턴이 너무 많은데…? 가장 우선순위가 높은 ‘페이지 구성하기’, ‘정보 검색하기’, ’상태 변경하기’ 같은 것들만 한두 개 먼저 만들어서 활용해 보고 또 추가하자. (어드민 플랫폼에서 사용하는 패턴도 처음부터 한 번에 다 만든 것이 아니라, 이런 흐름으로 20가지가 나오게 됐어요.)\n\n5단계 그러면 그런 것들은 실제로 동작하게 만들어보세요. 위의 과정들로 충분히 함께할 개발자를 설득할 수 있을 거예요. 그러고 나면 개인도, 프로젝트도 함께 성장하는 일만 남았답니다.","isDisplayingFeedback":true},{"id":21025,"updatedTime":"2023-05-23T12:54:19+09:00","createdTime":"2023-04-12T16:03:25+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"사용자 3명인 제품, 만들어야 할까?","subtitle":"사용자가 3명 뿐인 제품, 쓰는 사람이 적으면 개선을 하지 말아야 할까요? 토스 콘텐츠 시스템(TCS)을 만들면서, 최소한의 비용으로 최대한의 효율을 내기 위해 고민했던 지점들을 소개해드려요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":"","title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/12/스크린샷-2022-12-22-오후-4.19.28.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/12/스크린샷-2022-12-22-오후-4.19.28.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"only-3-users-product","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-12-22T16:20:35+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21025,"title":null,"description":"토스에는 Internal Product Designer라는 직군이 있어요. 토스 팀원들이 빠른 속도로 혁신할 수 있도록 인프라를 만드는 일을 해요. 내부 제품을 만드는 팀도 일하는 방식은 다른 팀과 크게 다르지 않은데요. 어떤 제품 혹은 인프라를 만들었을 때 임팩트가 클지, 어떤 일이 ...","urlSlug":"only-3-users-product","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"사용자 3명인 제품, 만들어야 할까?","description":"사용자가 3명 뿐인 제품, 쓰는 사람이 적으면 개선을 하지 말아야 할까요? 토스 콘텐츠 시스템(TCS)을 만들면서, 최소한의 비용으로 최대한의 효율을 내기 위해 고민했던 지점들을 소개해드려요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-12.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2347,"relatedPosts":[{"id":21024,"updatedTime":"2023-07-05T22:07:39+09:00","createdTime":"2023-04-12T16:03:17+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"내 아이디어를 너무 믿지 마세요","subtitle":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"dont-trust-your-gut","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-28T17:31:40+09:00","commentBoard":null,"disclaimer":null},{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":582,"name":"이영진","slug":"youngjin-lee","shortDescription":"Product Designer(Tools)","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/youngjin-lee.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"툴즈 프로덕트 디자이너?\n토스에는 Tools Product Designer라는 직군이 있어요. 토스 팀원들이 빠른 속도로 혁신할 수 있도록 인프라를 만드는 일을 해요. 내부 제품을 만드는 팀도 일하는 방식은 다른 팀과 크게 다르지 않은데요. 어떤 제품 혹은 인프라를 만들었을 때 임팩트가 클지, 어떤 일이 더 중요한지 팀원들간에 치열한 논의를 통해 방향을 정해요.\n\n제가 처음 합류한 팀은, 새로 생긴 인터널 팀이었어요. 당시 토스증권은 설립된지 얼마 안되어서, 토스코어에 비해 인프라가 충분하지 않았는데요. 그런 환경에서 팀원들의 업무 효율을 끌어올리기 위해 만들어진 팀이었어요. 상담원 분들이 쓰는 고객 상담 툴부터 서비스 개발에 필요한 어드민 제품까지, 풀어야 할 문제가 산더미처럼 쌓여있는 상태였죠. 그때 PO가 팀에 콘텐츠 에디터를 만들자고 제안했어요.\n\n인터널 팀에서 꼭 풀어야 하는 문제일까?\n입사한지 얼마 안된 제가 봐도 할 일이 산더미인데 콘텐츠 매니저는 3명이었고, 콘텐츠는 매일매일 부지런히 발행되고 있었어요. 다소 불편하긴 하지만 멀쩡히 동작하는 에디터가 있으니 팀 차원에서 해결할 문제라는 것에 공감할 수 없었어요.\n\n나: 왜요? 불편하긴 하지만 돌아가는 에디터가 있긴 하잖아요. 쓰는 사람이 세 명밖에 없는데 더 임팩트 있는 일 해야죠!\nPO: 일단 어떻게 일하고 계신지 보고 얘기하시죠.\n강하게 반대하니 PO가 콘텐츠 발행 프로세스 한번만 참관하자고 저를 설득했고, 콘텐츠 매니저 온보딩 세션을 듣게되었어요.\n\n\n*토스 앱에는 ‘오늘의 머니팁’, 토스 증권 ‘투자는 이렇게’ 같이 어려운 금융 개념이나 뉴스를 쉽고 빠르게 알려주는 서비스가 곳곳에 있어요. 콘텐츠 매니저는 이런 글을 기획하고 만드는 에디터 역할을 해요.\n\n문제의 크기를 재보자\n콘텐츠 매니저의 온보딩을 들으면서, 기존 콘텐츠 발행 프로세스가 얼마나 비효율적인지 직접 느낄 수 있었어요. 하나의 글을 발행하기 위해 거쳐야 하는 툴만 열 개 가까이 되었고, 그마저도 멀쩡히 동작하지 않아 코딩하듯 글을 써야했어요.\n\n\nBefore – 코딩하듯 글을 써야했던 이전 에디터 화면\n\n실제로 글을 쓰려면 알아야 하는 html문법이 ppt로 수십장에 달했어요. 다 외우기 어려우니 매번 문서를 찾아보아야 했고, 이 작업만 전담하는 어시스턴트가 따로 있었어요.\n\n3시간여의 온보딩을 듣고 나니 이렇게까지 글을 만들어내는 콘텐츠 매니저분들이 새삼 대단하게 느껴졌고, 이 발행 과정을 꼭 개선하고 싶다는 공감대가 생겼어요.\n\n최소한의 리소스로 최대한의 효율을 만들어보자\n결국, 콘텐츠 에디터를 개선하기로 했어요. 하지만 여전히 3명만 쓰는 제품에 많은 리소스를 투입하기는 어려웠죠. 그래서 제품을 새롭게 만드는 선택지는 배제하고, 두 가지 목표를 세웠어요.\n\n1) 최소한의 리소스를 써서, 2)최대한의 효율을 낸다. 이런 전제 하에 나온 방향은 두 가지가 있었어요.\n\n1)기존 에디터 개선: 기존 에디터에서 가장 심각한 문제 5가지만 해결하자.\n\n2)오픈소스를 활용한 새로운 에디터 개발: 오픈소스를 활용해서 새로운 에디터를 만들자.\n\n하지만 두 가지 솔루션 모두 단점을 가지고 있었어요.\n\n1)기존 에디터 개선: 너무 오랜 기간 여러 개발자의 손을 거쳐 히스토리를 알 수 없고, 부분만 고치기 어려운 구조였어요. 아무리 개선 범위를 좁힌다고 해도 투자하는 시간 대비 효율이 낮을 것을 예상할 수 있었어요.\n\n2)오픈소스를 활용한 새로운 에디터 개발: 사실 기존에 쓰던 에디터가 이 목표로, 오픈소스를 활용해 만든 툴이었어요. 애매하게 커스터마이징한 에디터를 만들었다간 언젠가 지금과 비슷하게 손 쓰기 어려운 상태가 될 위험이 있었어요.\n\n둘 중 하나가 아닌 완전히 다른 해결책\n최소한의 리소스를 쓰면서 효율을 만들려면 어느정도의 단점을 감수하는 건 당연한 일인데도, 더 나은 방법을 찾고 싶었어요. 포기하지 않고 팀원들과 머리를 맞댄 끝에 기존 후보들의 단점을 보완하면서 문제를 해결할 솔루션으로 노션을 생각해냈어요.\n\n노션의 장점은 이런 것들이었어요.\n\n텍스트 에디터를 우리가 직접 만들지 않아도 되고:노션이 화려하고 정교한 글 서식을 지원하지는 않지만, 토스 콘텐츠에서 주로 쓰는 서식은 모두 갖추고 있었어요.앞으로 토스 콘텐츠가 화려하고 새로운 서식 스타일로 차별화할 거였다면 몰라도, 지금의 콘텐츠 제작 방식은 충분히 커버할 수 있을 거라는 확신이 있었어요.\n지속적으로 업데이트되며 믿을 수 있는 외부 솔루션:오픈소스는 지원 여부에 따라 활용할 수 있는 것의 한계가 명확해요. 지원 여부에 따라 미래에 fade out될 가능성까지 고려해야 해요.노션의 api를 같은 기준으로 볼 수도 있는데, 적어도 지금 크게 성장하고 있고, 가까운 미래에 망하지 않을 것(가까운 미래까지 활발하게 업데이트 및 기능 확장할 것)으로 예상했어요.\n노션으로 콘텐츠 시스템 만들기\n토스에는 TDS라는 이미 훌륭한 UI 디자인 시스템이 있어요. 이 시스템과 노션의 텍스트 블록을 1:1로 매칭해주기만 하면, 노션에서 글 쓰는 것과 서비스에 글이 올라가는 것의 간극을 아예 없앨 수 있었어요.\n\n콘텐츠 매니저가 노션에 글을 쓰면, 토스 디자인 시스템이 적용된 서비스 화면이 자동으로 그려지기 때문에 서식 편집을 따로 할 필요가 없게 되었어요.\n\n\nafter – 원고 작성 화면과 서식이 자동으로 적용된 서비스상 콘텐츠 화면\n\n원고 작성이 끝나면, 글이 토스앱 안에서 어디에 어떻게 올라갈 것인지 서비스와의 접점만 설정하면 돼요.\n\n\nafter – 이미지, CTA 등 발행 설정 화면\n\n한 달의 시간으로 얻은 확장 가능한 효율\n문제를 찾는 과정부터 솔루션을 제품화하기까지, 한 달 동안 바뀐 점은 이렇게나 많았어요.\n\n1. 작업 속도가 빨라졌어요.\n\n\n10여개에 달하는 툴을 오가며 글을 써야 했던 이전과 달리, 노션에서 글을 쓰고 어드민에서 발행 설정만 하면 되기 때문에 작업 시간이 적게는 1/3, 많게는 1/10까지 줄었어요.\n\n2. 적은 인원이 더 많은 일을 할 수 있게 됐어요.\n\n\n하나를 발행할 때에도 편집 어시스턴트와 여러 차례 커뮤니케이션해야했던 이전과 달리, 콘텐츠 매니저 혼자서 편집, 발행까지 클릭 몇 번으로 할 수 있게 됐어요.\n\n다른 무엇보다 원고를 쓰는 일, 더 좋은 글을 쓰는 일에 집중할 수 있게 되었어요.\n\n3. 데이터 접근성이 높아지고 콘텐츠를 더 많은 곳에서 활용하게 됐어요.\n\n\n채팅 상담에서 어려운 증권 개념을 콘텐츠로 풀어준 사례\n\n이런 효용이 사내에 바이럴로 번지며 콘텐츠 뿐만아니라 텍스트 에디터를 필요로 하는 곳이 엄청나게 많은 것을 알게되었는데요, 공문﹒공시를 올리거나, 채용 페이지에 게시물을 올리는 등 예상치 못했던 니즈가 팀에 쏟아져 들어왔어요.\n\n인사, CX 처럼 디자이너, 개발자가 없는 팀들이 유저에게 필요한 글을 게시할 때 비슷한 어려움을 겪고 있었던거죠. 그래서 지금은 토스 전체 계열사에서, 다양한 플랫폼에 글을 쓸 수 있도록 제품을 확장하고 있어요.\n\n\n이 정도 리소스로 이만한 임팩트를 낼 수 있다면 사용자 3명인 제품도, 만들어볼만 하지 않을까요?","isDisplayingFeedback":true},{"id":21033,"updatedTime":"2023-04-12T17:25:56+09:00","createdTime":"2023-04-12T16:04:09+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"토스 디자인 원칙, Easy to answer","subtitle":"토스에는 좋은 제품을 만들기 위한 디자인 원칙들이 있어요. 오늘은 그 중에 easy to answer라는 항목을 적용해서 제품을 개선한 사례를 소개해드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/12/Columns.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/12/Columns.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"insurance-claim-process","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-12-14T21:45:20+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21033,"title":null,"description":"토스에는 제품 디자인 원칙인 product principles가 있어요. 토스 제품의 winning strategy 를 담고 있고, 좋은 제품의 기준이 되는 원칙들인데요. 이 기준을 가지고 더 활발하게 피드백하기도 하고, 사용자에게 미친 만족감을 주기 위한 원동력 삼기도 한답니다. 오늘...","urlSlug":"insurance-claim-process","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"토스 디자인 원칙, Easy to answer","description":"토스에는 좋은 제품을 만들기 위한 디자인 원칙들이 있어요. 오늘은 그 중에 easy to answer라는 항목을 적용해서 제품을 개선한 사례를 소개해드릴게요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://toss.tech/wp-content/uploads/2022/12/Columns.png","imageType":"직접입력"},"relatedPostConfig":{"id":2344,"relatedPosts":[{"id":21024,"updatedTime":"2023-07-05T22:07:39+09:00","createdTime":"2023-04-12T16:03:17+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"내 아이디어를 너무 믿지 마세요","subtitle":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"dont-trust-your-gut","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-28T17:31:40+09:00","commentBoard":null,"disclaimer":null},{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":571,"name":"김재현","slug":"jaehyeon-kim","shortDescription":"Head of UX","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/jaehyeon-kim.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스에는 제품 디자인 원칙인 product principles가 있어요. 토스 제품의 winning strategy 를 담고 있고, 좋은 제품의 기준이 되는 원칙들인데요. 이 기준을 가지고 더 활발하게 피드백하기도 하고, 사용자에게 미친 만족감을 주기 위한 원동력 삼기도 한답니다. 오늘은 그 중 easy to answer라는 원칙을 지켜 제품을 개선한 사례를 보여드리려고 해요.\n\n이탈이 많은 구간이 있다면\n토스에는 [병원비 돌려받기]라는 보험비를 간편하게 청구하는 기능이 있어요.\n\n이 기능을 출시하는 2019년에는 보험비 청구 신청을 위해 아직도 영수증, 세부 내역서, 처방전 등과 보험사가 제공하는 신청 서류를 직접 작성해 팩스나 이메일로 제출하는 것이 일반적이었어요.\n\n토스앱에선 가입한 보험사를 선택하고, 필요한 서류를 올리기만 하면 신청이 끝났죠. 이 간편함 자체가 혁신이었어요.\n\n\n출시 후 1년 쯤 지났을때 사용 지표를 들여다보니, 보험사 선택하는 단계 그리고 정보 입력 과정에서 이탈하는 사용자가 많다는 것을 발견했어요. 청구 과정은 간편해졌지만, 청구를 위해 알아야하고 준비해야 될 내용에는 변화가 없었기 때문이죠.\n\n때마침 토스에서 토스보험파트너라는 보험설계사 서비스가 생겨, 대량의 상담을 할 수 있게 됐어요. 청구에 도움이 필요한 사용자는 전문가 상담을 받을 수 있게 했죠.\n\n병원비 돌려받기를 시작하면 보험 전문가 도움받기, 직접 신청하기 중 원하는 방법을 선택할 수 있고, 보험 전문가 도움받기를 선택하면 바로 채팅 상담이 시작되는 방식이었어요. 상담 신청이 많아지는 것을 보고, 문제가 해결됐다고 생각했어요.\n\n\n하지만 얼마 후, UX리서치팀에서 병원비 돌려받기 기능이 불편하다는 사용자의 의견을 주셨어요. 사용자 5분과 UT를 진행해봤죠. UT 결과로 서류 준비 과정이 여전히 불편하다, 가족 대신 신청하는 기능이 있었으면 좋겠다 등 여러 문제점을 발견할 수 있었는데, 진입점부터 문제가 있다는 것도 알게 됐어요.\n\n더 쉽게 청구를 진행할 수 있도록 만들었던 1.보험 전문가 도움받기 2.직접 청구하기 선택 단계에서, 머뭇거리고 고민하는 사용자를 발견했거든요.\n\n문제는 ‘대답하기 어려운 질문’\n왜 머뭇거렸을까요?정답은 ‘사용자가 대답하기 어려운 질문’이었기 때문이에요.토스 제품 원칙 easy to answer를 지키지 못했기 때문.\n\n“저녁 뭐 먹을래?”\n\nvs\n\n“저녁에 피자 먹을까?”\n\n어떤 질문에 더 대답하기 쉬운가요? 3초 안에 답이 안나오면 어려운 질문이에요. 제품은 쉬운 질문을 했을때 사용자가 직관적으로, 막힘 없이 선택하거나 답을하고, 끝내 원하는 결과에 더 빠르게 도달할 수 있어요.\n\n그래서 사용자가 대답하기 쉬운 질문으로 머뭇거리는 지점을 개선하기로 했어요.\n\n사용자가 대답하기 쉬운 질문을 던지자\n\nbefore : '전문가 도움받을래 직접 할래?'after : '서류 있어?'\n\n'전문가 도움받을까요, 직접 할래요?' 보다 '서류 있나요?'\n리서치 결과를 봤더니, 전문가에게 상담을 하는 사용자 대부분이 어떤 서류가 필요한지를 물어보고 있었어요.\n\n그래서 고객에게 신청 진행 방식을 고르라고 하는 것보다 “서류 있나요?”라는 더 간단하고 명확한 질문이 적절할 것이라는 가설을 세웠어요. 돌아보니, 진행 방식 선택 이후에 어떤 과정이 펼쳐질지 예상이 안되기 때문에 더 고민되지 않았을까 깨달았어요.\n\n“서류 있나요?”\n\n어떤 서류를 의미하는지 바로 이해할 수 있도록 풀어내는 것도 정말 어려웠어요. 병원 방문, 입원, 수술 등 진단에 따라 필요한 서류에 대한 안내가 다 다른데, 이해하기 쉽게 설명할 방법이 있을지. ‘더 알아보기’ 페이지를 통해 자세한 내용을 따로 안내해주면 될지.\n\n대부분의 진료에 해당되는 진료비 영수증과 약제비 영수증을 대표 서류로 보여주면 되겠다는 결정을 하고, 그래픽팀과 여러 탐구를 해보면서 병원을 다녀온 누가봐도 이해할 수 있는 이미지를 얻게됐어요.\n\n\n기존 화면과 개선된 화면의 지표를 확인해봤는데, 기존 화면에 비해 이탈하는 사용자가 50% 감소했어요. 더 쉬운 질문으로 더 많은 사용자가 다음 단계로 넘어가는 효과를 확인할 수 있었어요.\n\n참고로, 서류가 있다고 선택한 사람과 없다고 선택한 사람의 비율은 5:4 였어요.\n\n모든 보험사가 아니라, 내 보험사 중에 고르기\n그 외에도 easy to answer가 잘 안되는 지점들을 이번 기회에 개선했어요.\n\n보험비를 청구할 보험사를 고를 때, 처음에는 모든 손해보험사, 생명보험사 목록을 보여줘서 이탈이 많았어요. 그래서, 보험 정보가 토스에 연동되어있는 사용자라면, 가입된 보험사 목록만 보이게 만들었어요. 그랬더니 이탈률이 개선됐죠.\n\n보험 정보가 토스에 연동되어있지 않은 사용자라면, 기존 방식 그대로 보여주는 게 아니라 설계사와 상담을 할 수 있도록 퍼널을 추가햇어요.\n\n\n대답하기 쉬운 질문으로 개선한 사용자 경험\n쉬운 질문 하나로 전체 청구 신청 과정에 큰 변화가 있었어요.\n\n기존에는 사용자가 직접 보험비를 신청하다 여러 이유로 막혀서 이탈하는 경우가 많았어요. 가장 큰 문제는, [직접 신청]을 선택했을 때 어떤 과정을 거치게 될지 예상할 수 없다는 것이었어요.\n\n이 문제는 easy to answer라는 원칙을 적용하는 것만으로도 크게 개선할 수 있었어요. “서류 있나요?” 질문 하나로 직접 신청을 원하는 사용자와 도움이 필요한 사용자를 더 명확하게 구분할 수 있게되었어요. 그렇게 구분한 사용자들에게 각각의 상황에 맞는 솔루션을 줄 수 있었죠.\n\n이 방법으로 서류 준비가 안된 사용자는 신청 과정을 진행하다 뒤늦게 막히는 안좋은 경험 대신,앞에서부터 개인화된 도움을 받을 수 있게 됐어요. 화면을 개선한 뒤 실제로 이탈하는 사용자가 60%로 대폭 감소했어요.\n\n\n“전문가 도움받기”라는 좋은 기능을 제공했으니 잘 사용하겠지’라고 만족하지 않고, UT 등을 통해 사용자의 상황을 더 깊게 파악해야겠다고 다시 다짐하게 되는 과정이었어요. 유용한 기능을 추가하는 것도 물론 중요하지만, 그만큼 Easy to answer를 통해 사용자 관점에서 경험을 잘 설계하는 것도 중요하는 걸 알게 됐고요.\n\n지금도 높은 NPS로 사랑받고 있는 병원비 돌려받기 기능, 더 쉽게 만들기 위한 고민은 계속될 예정이에요!\n\n","isDisplayingFeedback":true},{"id":21008,"updatedTime":"2023-04-12T17:25:57+09:00","createdTime":"2023-04-12T16:01:15+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"플랫폼 디자이너가 효율을 만들어내는 법","subtitle":"수많은 가짓수들을 단순히 더하기로 추가하는 것이 아니라 곱하기로 확장하면서 극단적인 효율과 심미성까지 챙겼던 과정들을 플로우차트 제작 프로젝트를 예시로 소개해드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/12/flowchartTN.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/12/flowchartTN.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"how-platform-designer-make-effectiveness","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-12-08T18:40:30+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21008,"title":null,"description":"토스에는 디자인 플랫폼 팀이 있고, 그 안에 플랫폼 디자이너라는 직군이 있어요. 플랫폼 디자이너는 무슨 방법을 써서라도 메이커의 디자인 작업 과정의 비효율을 효율화하는 사람이에요. 디자인 시스템을 만들기도 하고, 디자인 툴을 바꾸기도 했죠.오늘 소개해드릴 프로젝트는 툴을 바꾸면서 새로운...","urlSlug":"how-platform-designer-make-effectiveness","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"플랫폼 디자이너가 효율을 만들어내는 법","description":"수많은 가짓수들을 단순히 더하기로 추가하는 것이 아니라 곱하기로 확장하면서 극단적인 효율과 심미성까지 챙겼던 과정들을 플로우차트 제작 프로젝트를 예시로 소개해드릴게요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-9-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2346,"relatedPosts":[{"id":21024,"updatedTime":"2023-07-05T22:07:39+09:00","createdTime":"2023-04-12T16:03:17+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"내 아이디어를 너무 믿지 마세요","subtitle":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"dont-trust-your-gut","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-28T17:31:40+09:00","commentBoard":null,"disclaimer":null},{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":573,"name":"황희영","slug":"heeyoung-hwang","shortDescription":"Platform Designer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/heeyoung-hwang.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스에는 디자인 플랫폼 팀이 있고, 그 안에 플랫폼 디자이너라는 직군이 있어요. 플랫폼 디자이너는 무슨 방법을 써서라도 메이커의 디자인 작업 과정의 비효율을 효율화하는 사람이에요. 디자인 시스템을 만들기도 하고, 디자인 툴을 바꾸기도 했죠.\n\n오늘 소개해드릴 프로젝트는 툴을 바꾸면서 새로운 환경에 맞게 작업 과정을 효율화했던 작업이에요.\n\n극단적인 효율화로 미친 생산성 만들기\n제가 처음 토스의 플랫폼 디자이너로 입사했을 때는 스케치에서 프레이머로 이사가 진행되고 있었던 시점이었어요. 스케치에 있는 컴포넌트를 프레이머로 옮겨야 했는데, 그중에 플로우차트를 옮겨보기로 했어요. 플로우차트는 버튼을 누르면 어느 화면으로 가는지, 사용자의 상황에 따라 어떤 화면을 그려줄 것인지 등, 화면끼리의 관계나, 흐름을 표현하기 위해서 쓰이는 도구예요.\n\n\n\n스케치와 프레이머의 가장 큰 차이점은 스케치는 드로잉 기반의 툴이고, 프레이머는 코드 기반의 툴이라는 거예요. 사실 이런 차이를 고려하지 않고, 그냥 스케치에 있는 플로우차트를 그대로 옮길 수도 있었죠. 하지만 저는 여기서 극단적인 효율화를 추구하고 싶었어요. 둘은 전혀 다른 툴이기 때문에, 스케치에서 사용하는 방식 그대로 프레이머에 옮기는 것은 큰 의미가 없다고 생각했거든요. 툴에 특성에 맞게 코드를 활용해서 가장 효율적으로 사용할 수 있는 방법을 적용하고자 했어요.\n\n더하기가 아닌 곱하기\n\n스케치에서 쓰던 플로우차트는 위 이미지처럼 여러 가지 형태의 화살표 중 지금 필요한 형태의 화살표를 찾아서 선택한 다음 대지에 넣는 방식이었어요.\n\n사실 프레이머에 스케치에서 사용하던 것들을 그대로 옮겨올 수는 있었어요. 하지만 그렇게 만든다면, 스케치에서 쓰던 사용 방식을 그대로 차용해야 했죠.\n\n만약 스케치에서 사용하던 방식을 그대로 프레이머에 옮기게 된다면, 프레이머에는 스케치와 달리 좌우 반전이나 상하 반전의 기능이 없었기 때문에 일자와 ㄱ,ㄴ 모양만 해도 관리해야 하는 옵션이 1+1+1+1…. 이렇게 늘어나면서 스케치보다도 가짓수가 많은 24개가 됐어요.\n\n더구나 프레이머는 스케치처럼 드롭다운을 단계별로 나눌 수도 없었기 때문에 모든 화살표를 한 번에 보면서 골랐어야 했어요. 저는 이렇게 필요한 옵션을 하나하나 추가하는 방식을 더하기 방식이라고 불렀어요.\n\n\n프레이머에서의 디자인 컴포넌트로 그리게 되면 모양과 색을 한방향으로 쌓아서 고르게 돼요, 일자와 ㄱ,ㄴ모양만 해도 관리해야 하는 가짓수가 8*3 = 24개가 돼요\n\n여기에 화살표를 그리는 데에 당연히 있을 법한 ㄷ이나 , Z 모양의 화살표를 추가하게 된다면, 모양의 선택하는 데에 있어서 걷잡을 수 없이 복잡해질 것이 눈에 보였어요.\n\n화살표 위 아래 방향을 바꾸고 싶은데.. 반대 방향이 어딨더라… 아! 지금 쓴것과 반대 모양의 화살표를 180도로 뒤집어야 하는구나!\n\n그냥 위아래가 바뀐 화살표를 쓰고 싶었을 뿐인데 왜 다른 화살표를 써야 할까? 의문이 들었죠. 우리가 좀 더 상식적으로 플로우차트를 쓰기 위해서는 더하기 방식이 아닌 곱하기 방식을 써야 했어요. 1+1+1…+1=24가 아니라 4x2x3=24 이런식으로요.\n\n곱하기 방식으로 그리기 위해 총 28가지 화살표를 돌려보거나 반전했을 때 공통으로 겹치는 가장 기초의 형태를 찾았고, 단 4가지의 타입으로 화살표의 형태를 정의할 수 있었어요.\n\n\n가장 기초의 형태를 찾기 위해 시도해봤던 흔적들\n\n\n그렇게 해서 나온 4가지 형태\n\n그 외에도 색상만 바꾸고 싶다거나, 레이블을 화살표 선 위에 올려놓고 싶다거나, 선의 스타일을 바꾸고 싶거나 하는 당연히 되어야 할 것만 같은 옵션들도 점차 추가해가면서 하나의 컴포넌트로 아래와 같은 수많은 옵션을 그릴 수 있도록 만들었어요. 곱하기 방식을 사용했기 때문에 지속적인 확장이 가능했죠.\n\n\n하지만 곱하기 방식으로 옵션을 만들어 낸다는 것이 쉽지만은 않았어요. 하나씩 그리는 더하기 방식이 아니다 보니, 예상치 못하게 동작하는 모습이 나오기도 했기 때문이에요.\n\n가장 의도와 다르게 나왔던 옵션은 레이블이었어요. 상하 반전, 좌우 반전, 90도 회전으로 방향 바꾸기 등등 어떤 조작을 해도 화살표는 이미지이기 때문에 문제가 없었지만, 레이블에는 텍스트가 들어가기 때문에 텍스트는 반전도, 회전도 하면 안 됐어요.\n\n반전은 화살표를 반전시킨 이후에, 텍스트박스를 다시 반전시키면 정상적으로 보이게 됐기 때문에 쉽게 해결할 수 있었지만, 회전과 반전을 함께 하니 레이블의 위치가 예상과 달리 움직이게 되면서, 정확한 레이블의 위치를 찾을 수 있는 규칙을 만들어가며 문제를 해결했어요.\n\n\n우린 깐부… 아니 디자이너잖아\n화살표 사용 방식은 잘 정의했지만, 그것을 직접 구현할 때 또 문제가 생겼어요.\n\n곱하기 형식을 적용하기 위해선 코드로 컴포넌트의 모양을 그려줬어야 했는데요. 코드를 단순하게 짜면, 쉽게 만들 수 있지만, 모서리가 뾰족하게 각져있는 형태의 보기 불편한 플로우차트를 그릴 수밖에 없었어요.\n\n\n하지만 저는 이런 플로우차트로 화면을 그린다는 건 참을 수가 없었고, 심미적으로 아름다운 플로우차트를 그리기 위해서 아래와 같은 문제를 해결해 나갔어요. 마름모 꼭짓점을 둥글게 만들거나, 화살표 모양을 둥글게 만들고, 화살표와 선이 만나는 지점이 둔탁해 보이지 않게 모양을 바꾸기도 했어요.\n\n\n\n\n\nPO까지 즐겨 쓰는 플로우차트\n이렇게 사용성과 심미성을 챙긴 플로우차트는, 원래는 디자이너분들을 위해 만들었던 것이지만 유려한 결과물이 되어 다른 직군까지도 쓰게 되었어요. 토스의 몇몇 제품은 아주 복잡도가 높아요. 화면 하나를 그리는 것보다 그것들이 어떻게 연결되어있고 어떤 상황에 쓰이는지 구조도를 그리고 메모하는 게 중요한 제품들이 있죠. 그런 제품을 다룰 때 플로우차트가 매우 큰 역할을 했어요.\n\n\n위 이미지가 좋은 사례인데요. 일부분만 캡쳐해도 얼마나 복잡한 제품인지 느껴지시죠? 플로우차트가 없었다면, 또 있다해도 불편한 사용성을 갖고 있었다면 이 제품을 설명하기 위해서 정말 많은 시간을 허비해야 했을 거예요. 그런데 플로우차트를 개선한 후에는 심미성은 물론 사용성도 매우 좋아졌기 때문에 프레이머에 익숙하지 않은 PO도 이런 결과물을 만들 수 있었어요.\n\n앞으로도 플랫폼 디자이너로서 작은 단위의 효율성도 꼼꼼하게 챙겨가며 큰 임팩트를 내려고 해요. 기대해주세요!","isDisplayingFeedback":true},{"id":21037,"updatedTime":"2023-04-14T12:14:55+09:00","createdTime":"2023-04-12T16:04:34+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"토스에 처음 입사한 디자이너를 위한 온보딩 프로그램","subtitle":"토스 디자인 챕터는 온보딩을 위한 다양한 프로그램이 있어요. 디자이너가 직접 설계한 디자이너 온보딩, 어떤 것들을 신경 썼는지 하나씩 소개해드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/12/design-article-1201-2.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/12/design-article-1201-2.png","backgroundColor":null,"isFill":true,"imageAlt":null},"key":"designer-onboarding","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-12-01T15:31:41+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21037,"title":null,"description":"저희 디자인 챕터는 100명이에요. 디자이너와 디자인을 돕는 여러 직무로 이루어져 있어요. 인턴부터 토스를 5년 넘게 다닌 디자이너까지 각자 스테이지에서 최선을 다해 성장하려고 애쓰고 있어요.저는 디자인 챕터의 성장을 돕는 일 중에 신규입사자를 돕는 온보딩 과정을 설계했어요.디자인 챕터...","urlSlug":"designer-onboarding","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"토스에 처음 입사한 디자이너를 위한 온보딩 프로그램","description":"토스 디자인 챕터는 온보딩을 위한 다양한 프로그램이 있어요. 디자이너가 직접 설계한 디자이너 온보딩, 어떤 것들을 신경 썼는지 하나씩 소개해드릴게요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-1201-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2343,"relatedPosts":[{"id":21024,"updatedTime":"2023-07-05T22:07:39+09:00","createdTime":"2023-04-12T16:03:17+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"내 아이디어를 너무 믿지 마세요","subtitle":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"dont-trust-your-gut","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-28T17:31:40+09:00","commentBoard":null,"disclaimer":null},{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":570,"name":"강영화","slug":"younghwa-kang","shortDescription":"Product Designer(Tools)","description":"_","imageUrl":"https://static.toss.im/illusts/profile-younghwa.jpeg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":4,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"저희 디자인 챕터는 100명이에요. 디자이너와 디자인을 돕는 여러 직무로 이루어져 있어요. 인턴부터 토스를 5년 넘게 다닌 디자이너까지 각자 스테이지에서 최선을 다해 성장하려고 애쓰고 있어요.\n\n저는 디자인 챕터의 성장을 돕는 일 중에 신규입사자를 돕는 온보딩 과정을 설계했어요.\n\n디자인 챕터에는 컬쳐클럽이라는 조직이 있어요. 올 하반기부터 신규입사자분의 온보딩을 돕는 일과 챕터 전체의 심리적 안정감을 만들기 위한 액션 아이템을 찾고 꾸준히 실행하고 있어요.\n\n\n컬쳐클럽을 힘껏 응원해주는 디자인 챕터 팀원들\n\n신규입사자를 돕는 일을 하면서 고민도 많았고, 생각도 많았어요. 한국 회사에서 인하우스 디자이너의 온보딩 프로세스를 어떻게 설계했는지 구체적인 사례를 찾기 어려웠다는 점이 제일 어려웠어요. 이 글이 같은 고민을 하는 디자인 조직, 더 나아가서는 인사팀이나 다양한 아이디어를 필요로 하는 업계 동료분들께 도움이 될 거라 믿어요.\n\nㅤ\n\nㅤ\n\n신규입사자\n메이트\n세션 주최자\n이 프로젝트에 착수하고 먼저 한 일은, 온보딩 과정을 겪는 세 그룹의 이해관계자와 그 어려움을 파악한 일이예요. 그리고 이해관계자별로 문제의식을 정리했어요.\n\nㅤ\n\n신규입사자\n저희 팀에 조인하시기로 해주신 소중한 분들이에요.\n\n그런데 이분들이 들어와서 필요한 정보를 잘 얻지 못하는 점이 문제였어요.\n\n온보딩 프로그램이 정례화되어있지 않아서 그때그때 필요한 학습이 잘 일어나지 않았어요. 그리고 그나마 잡은 프로그램도 입사 후 너무 빠른 시기에 모두 들어야 해서 효과적인 학습이 일어나기 어려운 구조였고요. 디자인 팀 구조를 파악하거나 내가 도움을 어디서 받을지 확인하기 어려운 점도 문제였지요.\n\nㅤ\n\n메이트\n토스 팀 차원에서 신규입사자를 돕는 사람을 지정해주는 메이트 제도를 운영하고 있어요. 메이트는 온보딩 과정에 참여하는 짝꿍으로 신규입사자가 팀에 적응할 때 여러가지 도움을 주는 분이에요. 디자인 챕터에서는 이분들이 “심리적 안정감”에 집중해서 도움을 주시길 기대했고 메이트 선정 과정에서부터 고려한답니다.\n\n메이트분들은 신규 입사자분들에게 도움을 주고 싶지만 어떤식 으로 도와줘야 신규입사자에게 효과적인지 알기 어려워하셨어요. 신규입사자가 어떤 타임라인으로 어떤 온보딩 프로그램이 진행되는지 몰랐거든요.\n\n세션 주최자\n디자인 챕터는 온보딩을 위해 “세션”을 열어요. 툴 사용법부터 전략까지 신규입사자에게 도움이 되는 다양한 내용으로 구성되어 있고요. 이 세션을 만들고 운영하는 주최자분들은 신규입사자분들이 자주 만나야 하는 바쁜 분들이시죠. 실제로 팀에서 중요한 역할을 많이 하시기 때문에 이분들의 시간은 항상 부족해요. 그런데도 짬 내서 온보딩 업무를 해주고 계셨어요.\n\n어떤 분들은 세션에 너무 자주 참여하고 시간을 지나치게 많이 쓰고 있었어요. 비효율이 생겼지만 이를 효율적으로 해결하는 방법을 잘 모르셨어요.\n\nㅤ\n\nㅤ\n\n위에서 살펴본 이해 관계자의 문제를 표로 정리해보고 해결해야 하는 문제를 정의했어요.\n\n\n→ 신규입사자 : 학습에 비효율적인 온보딩 방식 → 신규입사자를 돕는 분들 : 정보 접근성이 떨어짐, 시간 부족\nㅤ\n\nㅤ\n\n신규입사자분들이 효율적으로 학습하도록 프로그램을 정례화하고, 온보딩 관련 문서 접근성을 높이면 많은 문제가 해결될 거라고 보았어요.\n\n\nㅤ\n\n신규입사자 온보딩 프로그램 만들고 운영\n가장 먼저 신규입사자 온보딩 프로그램 구성을 정했어요. PD분들은 1주 차에 Framer 사용법을 들으시고 5주 차에는 제품 윤리 세션을 들어요. 1주부터 5주까지는 한주에 한 개씩만 세션을 듣도록 배치했어요. 안 그래도 신규입사자분들은 토스 팀 공통 온보딩 세션 때문에 이미 캘린더에 일정이 꽉 차 있었거든요.\n\n그리고 3주차 부터 3개월 동안 풀도록 간단한 퀘스트 목록을 드렸어요.\n\n이 퀘스트에는 다양한 프로그램이 있기 때문에 단순 학습부터 토론까지 다른 팀원과 인터랙션이 극대화되는 경험을 하게돼요.\n\n\n작게는 디자이너 미팅에서 자기소개부터 세션 참여하기 같은 디자인 챕터에서 운영하는 프로그램에 참여하는 소소한 퀘스트가 있고요.\n온보딩 프로그램이나 세션에서 배운 점을 직접적으로 실천해보는 퀘스트도 있어요. 직접 UT 해보거나 업무를 하면서 배운 점을 디자이너 정기 미팅에 공유하는 거죠.\n마지막으로 다른 서비스 버그를 제보하거나 UX가 이상한 부분을 함께 제보하는, 팀에서 만드는 다양한 제품에 참여하는 참여형 퀘스트가 있어요. 토론과 UX 개선에 참여하는 과정까지 깊게 참여할수록 신규입사자분들은 소속감을 느끼게 되지요.\n이 퀘스트를 통해 신규입사자 분들은 온보딩 과정이 어렵지 않도록 느끼실 거예요. 내가 앞으로 어떤 방식으로 업무 온보딩을 해야 하는지에 대한 로드맵 역할을 해서 때문에 막막함이 적어지고요. 캐주얼하게 학습 과정에 참여해요.\n\nㅤ\n\nㅤ\n\n정보 접근성을 높이는 문서화\n정보 접근성을 높이기 위해 온보딩 로드맵과 메이트의 역할을 문서화했어요.\n\n1) 디자인 챕터 온보딩 로드맵\n온보딩 로드맵 문서는 신규입사자분들이 확인하는 용도이지만, 신규입사자를 돕는 모두에게도 이정표가 돼요. 메이트를 포함한 신규입사자를 돕는 분들이 온보딩 로드맵을 참고하고 계시거든요. 내가 돕는 사람이 현재 어디에 있는지 보는 거죠.\n\n\n2) 메이트의 역할\n메이트는 어떤 역할인지, 무엇을 해야 하는지, 왜 해야 하는지 메이트분들이 잘 이해하도록 정리했어요.\n\n\n그리고 이 두 문서는 지속적인 피드백을 통해 개선되고 있어요.\n\n\n문서가 있으니 지금 어떤 프로그램이 부족할지, 내가 기여해야하는 부분은 어디일지 살펴보고 의견을 주시기도 해요.\n\nㅤ\n\nㅤ\n\n더 효율적인 방법 찾기\n프로그램을 만들면서 동시에 세션 주최자분들이 신규입사자 온보딩에 품을 덜 들일 방법을 많이 고민했어요. 얼마 전에는 세션 4개를 비대면화했고 한 개의 세션도 면대면으로 운영하지 않을 방법을 찾고 있어요.\n\n\n보통 슬랙에서 진행 상황을 안내하면서 다양한 이해관계자분들과 소통하고 있답니다. 1~2주에 한 번씩 문서로 대체 가능한지 살펴보거나, 세션이 진행된다면 더 잘 전달할 방법을 같이 고민해드리고 있어요.\n\n더 나아가서 인터널 팀과 협업해서 기계적인 일은 대부분 자동화할 예정이에요. 신규입사자가 들어오면 바로 업무에만 몰입하는 환경을 만들 거예요. 💪\n\nㅤ\n\nㅤ\n\n직무 적응을 위한 공식 프로그램뿐만 아니라, 심리적 안정감 형성을 위한 프로그램도 추가로 운영하고 있어요.\n\n💌 깜짝 콜라보런치 : 랜덤으로 신규입사자분들과 기입사자분들간 식사 자리를 잡아드리는 깜짝 콜라보런치\n☕ 다른 직무와 티타임 : PD, IPD와 각종 디자이너를 돕는 직무와 연결해 티타임 주선\nㅤ\n\nㅤ\n\n프로그램별로 계획한 효과를 냈는지에 집중해서 정성적으로 평가했어요.\n\n이 프로그램이 성공적으로 끝난다면 어떤 모습일지 상상하고 이해관계자에게 각각 반응을 여쭈었어요. 가능하면 사후 설문을 통해 만족도 조사까지 받기도 했고, 약식으로 온도 체크를 하기도 했답니다.\n\n평가를 해보니 좋은 성과가 있었고 이 온보딩 프로그램이 잘 돌아간다고 판단했어요.\n\n신규입사자는 일 외에 불필요한 고민을 많이 하지 않고, 팀에 빠르게 랜딩하는데 도움이 되었다는 보이스가 있었어요.\n메이트는 신규입사자를 더 잘 돕게 됐어요. 또, 누군가를 도우면서 스스로 성장하는 계기가 됐어요.\n세션을 준비하는 팀원들은 불필요한 리소스를 많이 쓰지 않아도 돼요.\nㅤ\n\nㅤ\n\n제 기대보다 사용자 반응이 너무 좋았어요. 업무에 도움을 받으시는 건 당연했고요. 각각 이해관계자분들이 챕터에 잘 온보딩 하시고 팀에서 더 많은 인터랙션이 생기는 게 눈으로 보일 정도였답니다.\n\n\n이 외에도 담지 못한 많은 메시지가 있지요 💌\n\nㅤ\n\nㅤ\n\n지금은 디자인 챕터 온보딩 버전 1 을 릴리스 한 거로 생각해요. 피드백을 계속 반영하면서 개선하며 이터레이션을 돌고 있기 때문에 완벽하지 않고, 마치 제품을 개선하는 일처럼 계속 발전하고 있어요. 비효율적인 부분이 많이 없어졌기에 이전까지 파악하기 어려웠던 더 큰 문제들도 발견했어요.\n\n이런 인사 관련 업무의 특성상 4~5개월 정도 긴 호흡으로 진행하고, 바라보고, 평가하는 시간이라 저에게도 도전적인 시간이었어요. 이 시간을 통해 제 강점과 관심사가 조직문화에서 발휘될 거라고 기대했어요. 정말로 팀에 큰 임팩트를 주고 있어서 행복해요. 이렇게 제 덕업일치 모먼트를 소개할 수 있어서 기쁘기도 하고요!\n\n제품과 조직 성장, 업무 안에서의 고민을 계속 이 블로그에서 풀어볼 테니 기대해주세요. 🙂","isDisplayingFeedback":true},{"id":21013,"updatedTime":"2023-04-14T11:58:27+09:00","createdTime":"2023-04-12T16:02:08+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"직접 만지고, 돌리는 토스뱅크카드 인터랙션","subtitle":"토스뱅크카드의 중요한 디자인 컨셉은 앞면과 뒷면의 색상이 다르다는 것인데요. 지금까지는 이 정보를 표현하기 위해서 이미지를 두 장 쓰거나, 영상을 만들었죠. 하지만 그걸로는 부족했어요. 저는 모바일 화면에서도 실물 카드를 보는 것과 똑같은 경험을 만들고 싶었어요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/11/DesignTech-0-img.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/11/DesignTech-0-img.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"touch-and-turn-tossbankcard","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-11-24T19:16:25+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21013,"title":null,"description":"토스뱅크카드의 중요한 디자인 컨셉은 앞면과 뒷면의 색상이 다르다는 것인데요. 지금까지는 이 정보를 표현하기 위해서 이미지를 두 장 쓰거나, 영상을 만들었죠. 하지만 그걸로는 부족했어요. 저는 모바일 화면에서도 실물 카드를 보는 것과 똑같은 경험을 만들고 싶었어요.","urlSlug":"touch-and-turn-tossbankcard","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"직접 만지고, 돌리는 토스뱅크카드 인터랙션","description":"토스뱅크카드의 중요한 디자인 컨셉은 앞면과 뒷면의 색상이 다르다는 것인데요. 지금까지는 이 정보를 표현하기 위해서 이미지를 두 장 쓰거나, 영상을 만들었죠. 하지만 그걸로는 부족했어요. 저는 모바일 화면에서도 실물 카드를 보는 것과 똑같은 경험을 만들고 싶었어요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/DesignTech-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2335,"relatedPosts":[{"id":21024,"updatedTime":"2023-07-05T22:07:39+09:00","createdTime":"2023-04-12T16:03:17+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"내 아이디어를 너무 믿지 마세요","subtitle":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"dont-trust-your-gut","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-28T17:31:40+09:00","commentBoard":null,"disclaimer":null},{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":565,"name":"김지혜","slug":"jihye-kim","shortDescription":"Interaction Designer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/jihye-kim.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":2,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스뱅크카드 만들어 보셨나요?\n토스뱅크가 출범한 지도 벌써 1년이 지났는데요. 당시에 카드를 발급받으신 분이라면 이 화면을 경험하셨을 거예요. 이 화면에서 4가지 색상의 카드 중 어떤 색을 고를지 한참을 고민하셨다면 저는 너무 뿌듯할 것 같아요. 카드를 고르는 사용자를 위해, 어떻게 디자인하게 되었는지 비하인드 스토리를 공유해드릴게요.\n\n\n토스뱅크카드의 중요한 디자인 콘셉트는 앞면과 뒷면의 색상이 다르다는 것인데요. 정적인 이미지로는 앞/뒤 색상이 다른지 알기 어려워요. 잘못했다간 “저는 검정 카드를 선택했는데, 핑크 카드가 왔어요.” 라는 오해가 생길 수도 있죠. 지금까지는 대부분의 제품이 이런 문제를 이미지를 두 장 넣거나, ‘앞뒤가 다릅니다’라고 설명하는 방식으로 풀어왔어요. 조금 더 신경 쓰면 MP4 영상으로 만들거나요.\n\n하지만 저는 모바일 화면에서도 실물 카드를 보는 것과 똑같은 경험을 만들고 싶었어요. 그러려면 사용자가 수동적으로 정보를 수용하는 게 아니라, 능동적으로 경험에 참여하게 만들어야 했어요. 인터랙티브한 경험으로요.\n\n직접 만지고, 돌리고, 뒤집어보면서 내가 쓰게 될 카드를 마치 손에 쥐고 있는 듯한 느낌을 주는 거죠.\n\n인터랙티브한 경험을 만드는 과정\n지금도 그렇지만, 당시에도 사용자가 인터랙션할 수 있는 그래픽을 만들 수 있는 디자인 툴이 없었어요. HandOff가 어렵기 때문에 여러 가지 디자인 툴을 써보고 개발자분과 긴밀하게 소통하면서 극복해야 했죠. 동일한 목표를 위해 개발자와 긴밀하게 싱크하는 것이 중요했어요.\n\n예를 들면 Cinema 4D는 영상 제작 툴이라 사용자가 Touch Up 했을 때 애니메이션을 주기 어려워요. 영상처럼 만들 수밖에 없죠. Spline만으로는 플로우를 프로토타입 하긴 어렵고요. 그래서 저는 Spline에 화면 별로 모션을 각각 만들어서 Framer에 임베드하는 방식으로 프로토타입을 만들었어요. 툴에서 표현할 수 없는 것들은 구두로 개발자분께 하나하나 공유해 드렸고요.\n\n\n사용자가 처음 화면을 만나면, 카드를 한번 빠르게 회전시켜서 앞 뒤 색이 다르다는 걸 보여줬어요. 카드를 잡으면 회전이 멈추고, 손을 놓으면 다시 원래 자리로 돌아가서 자연스럽게 회전할 수 있도록 모션을 튜닝했어요. 하단 버튼은 토스의 브랜드 컬러로 파란색을 쓰고 있었는데, 이게 카드와 함께 있으니 너무 튀는 거예요. 이 화면만큼은 카드 색과 어울리게 만들고 싶었어요. 보고 있는 카드 색상과 버튼 색상이 연동되면 좋겠다고 생각했죠. 사실 이건 아이디어만 갖고 있었고, 실제로 구현하기는 어려울 수 있겠다고 생각했어요. 그래서 색상이 루핑되면서 재생되는 정도로 스펙 아웃하는 것을 염두에 두기도 했고요. 그런데 놀랍게도 개발자분께서 제가 의도한 것들을 전부 구현해주셔서, 정말 기뻤죠.\n\n이런 과정을 거쳐 만든 결과물이 여러분이 만났던 토스뱅크카드 발급 과정이에요. 사용자분들의 반응도 정말 좋았어요.\n\n\n화면을 캡쳐해서 SNS에 업로드한 사용자들\n\n인터랙티브한 경험을 만들기 어려운 이유\n하지만 이렇게 모바일에서 인터랙티브한 경험을 구현한 사례는 찾기가 정말 어려워요. 이렇게 장점이 명확한데 그동안 왜 아무도 하지 않았을까요?\n\n크게 세 가지 이유가 있어요.\n\n사용자가 인터랙션할 수 있는 그래픽을 만들 수 있는 디자인 툴이 없어요.\n처음 시도하는 기술이라면 디자이너와 개발자에게 진입장벽이 있어요.\n사용자 경험을 디테일하게 챙기는 일들은 빠른 속도로 제품을 만드는 팀에서 해내기 어려워요.\n첫 번째 문제를 해결하기 위해서 팀원들이 여러 가지 툴을 찾아보기 시작했어요. 수영님이 Spline이라는 툴을 써보자고 제안해주셨고, 현선님은 C4D와 같은 그래픽 톤을 만들기 위해 텍스쳐와 라이팅을 테스트하셨죠. 저는 Spline을 활용해서 컨셉 디자인을 했어요.\n\n두 번째 문제는 병철님이 Spline을 Framer에서 프로토타입 할 수 있도록 환경을 만들어줬어요. 그리고 Spline, WebGL, Three.js 등을 모바일 제품에 적용했을 때 우려되는 점들을 기술 검토했죠. 그러고 나니 Three.js라는 기술로 해결할 수 있겠다는 결론이 났고 추후 개발자 덕성님이 합류했을 때 작업에 바로 착수할 수 있었어요.\n\n하지만 가장 큰 문제는 세 번째예요. 이렇게 사용자 경험을 Extramile해서 챙기는 일은 빠르게 돌아가는 애자일 조직에서는 공감대를 얻기가 어렵죠. 앞에서 말한 두 가지 문제도 ‘이 프로젝트를 해야 한다’는 전제 없이는 생길 수 없는 문제고요. 하지만 토스에는 디자인 플랫폼이라는, 사용자 경험을 극대화하는 조직이 따로 있어요.\n\n21년 당시 저희 팀은 “Paradigm Shift in Interface Design”이라는 이니셔티브 아래에, 해결하기 어려운 사용성 문제를 디자인﹒개발﹒그래픽﹒인터랙션 등을 융합하여 해결해낸다는 목표가 있었는데요. 팀원들이 같은 페이지 위에서 목표를 공유하고 있다보니, 앞에서 말한 두 가지 문제도 굉장히 빠르게 해결되고, 일이 엄청난 속도로 진행되었어요.\n\n\n인터랙티브한 경험을 만들고 난 뒤 생긴 일\n토스뱅크카드의 발급 과정은 디자인을 포함해서 2주 안에 개발이 끝났어요. 시작하기 전에는 공수가 많이 들어가지 않을까 걱정했는데 실제로 해보니 금방 해낼 수 있었죠. 위에서 말씀드렸던 것처럼, 출시하고 나니 이 화면을 캡처하면서 SNS를 공유하시는 등 바이럴이 좋았어요.\n\n더 뿌듯했던 건, 이 프로젝트 이후 시스템으로 자리잡아 여러 제품에서 활용되고 있다는 점이에요. 틴즈 회원들이 신청하는 유스카드 발급화면이나, 증권의 뱃지 화면 등 토스 앱에 인터랙티브한 그래픽 사례들이 빠르게 만들어졌죠. 토스뱅크카드를 시작으로, ‘인터랙티브한 경험’을 만드는 게 새로운 선택지가 된 거예요.\n\n\n상상할 수 없는 것을 상상하기 위해서\n이렇게 좋은 성과를 내긴 했지만, 사실 저희 인터랙션 팀도 현실에 부딪혀 스펙 아웃을 하는 경우가 대다수예요. 처음엔 비주얼을 멋지게 만들어서 팀원들을 동기부여 하면 된다고 생각했지만, 일의 임팩트와 공수를 고려하다 보면 구현할 수 있는 수준으로 디자인을 수정하는 일을 겪을 수 밖에 없더라고요. 하지만 구현할 수 없더라도, 스펙아웃 될 것을 알면서도 항상 우리의 Moonshot을 그리는 태도가 가장 중요하다고 생각해요. 상상할 수 없는 것을 상상하기 위해서는 말이에요!\n\n사용자의 불편함을 인터랙티브한 인터페이스로 해결할 수 있는 미지의 땅이 아직 많이 있다고 생각해요. 이 프로젝트가 초석이 되어 세상에 이러한 시도가 더 많아지길 기대하고 있답니다. 좋은 영감이 되었길 바라며 글을 마무리할게요!","isDisplayingFeedback":true},{"id":21022,"updatedTime":"2023-04-12T17:25:56+09:00","createdTime":"2023-04-12T16:03:04+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"토스의 8가지 라이팅 원칙들","subtitle":"토스의 문구는 8가지 라이팅 원칙을 고려하면서 쓰고 있어요. 사람이 말하는 것 같은 문장을 지향하면서요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/11/썸네일.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/11/썸네일.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"8-writing-principles-of-toss","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-11-15T17:53:48+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21022,"title":null,"description":"UX 라이팅에서는 모든 팀원이 같은 기준으로 글을 쓰는 게 중요해요. 토스에는 모두가 같은 기준으로 글을 쓸 수 있는 여러 가지 인프라가 준비돼있어요. 크게 다섯 가지로 분류할 수 있는데요.https://wp.toss.tech/wp-content/uploads/2022/11/image-...","urlSlug":"8-writing-principles-of-toss","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"토스의 8가지 라이팅 원칙들","description":"토스의 문구는 8가지 라이팅 원칙을 고려하면서 쓰고 있어요. 사람이 말하는 것 같은 문장을 지향하면서요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-8-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2342,"relatedPosts":[{"id":21024,"updatedTime":"2023-07-05T22:07:39+09:00","createdTime":"2023-04-12T16:03:17+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"내 아이디어를 너무 믿지 마세요","subtitle":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"dont-trust-your-gut","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-28T17:31:40+09:00","commentBoard":null,"disclaimer":null},{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":563,"name":"김자유","slug":"jayu-kim","shortDescription":"UX Writer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/jayu-kim.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":4,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"UX 라이팅에서는 모든 팀원이 같은 기준으로 글을 쓰는 게 중요해요. 토스에는 모두가 같은 기준으로 글을 쓸 수 있는 여러 가지 인프라가 준비돼있어요. 크게 다섯 가지로 분류할 수 있는데요.\n\n\n토스 라이팅 시스템\n\n피라미드 위에서 아래로 내려갈수록 추상적인 개념에서 구체적인 개념으로 내려오는 거예요. 가이드라인과 템플릿, 시스템은 지난 아티클 <가이드라인을 시스템으로 만드는 방법> 에서 살짝 소개해드렸는데요. 오늘은 코어밸류와 프린시플을 소개해드리려고 해요.\n\n라이팅 코어밸류\n\n코어밸류는 말 그대로 가장 핵심적인 가치예요. 우리 제품, 브랜드가 어떤 가치를 지향하느냐에 대한 이야기죠. 보이스톤을 얘기할 때 보이스와 톤의 차이점에 대해서 많이 이야기하는데요. 보이스는 목소리예요. 저희가 멀리서 누가 “안녕~”이라고 했을 때 목소리를 듣고 제 친구인 걸 알아볼 수 있잖아요. 그래서 목소리는 그 사람의 아이덴티티, 정체성에 가까워요.\n\n반면 톤은 애티튜드, 태도에 가까워요. 우리가 다른 사람을 만난다고 해서 목소리가 바뀌지는 않잖아요. 근데 말하는 방식은 다를 수 있죠. 친구한테는 “야, 이거 좀 해줘.” 하는데 회사에서는 “OO님, 이것 좀 부탁드려요.” 라고 말하는 것처럼요. 이런 것을 톤이라고 해요.\n\n코어밸류는 둘 중에 보이스를 만드는 규칙에 가까워요. 비교하자면 사람의 성격에 가깝기 때문에, 형용사 형태일 때가 많고, 추상적인 개념이에요.\n\n토스에는 다섯 가지 라이팅 코어밸류가 있어요.\n\nClear 명확한\n\n첫 번째 가치는 Clear예요. 명확한 글쓰기란 뜻이죠. 문구를 작성할 때 단어의 의미가 어렵거나 모호하지는 않은지, 한 번에 이해할 수 있는 문장인지를 점검해요. 정확한 정보를 명확하게 전달하고, 메이커가 아닌 사용자가 이해할 수 있는 문장을 쓰기 위해 신경 쓰고 있어요.\n\nConcise 간결한\n\n두 번째 가치는 Concise예요. 간결한 글쓰기란 뜻이죠. 사용자는 쏟아지는 정보를 모두 읽지 않아요. 원하는 정보를 빠르게 스캔할 수 있도록 꼭 필요한 내용만 필요한만큼 전달하는 것을 중요하게 생각해요.\n\nCasual 친근한\n\n세 번째 가치는 Casual이에요. 친근한 글쓰기란 뜻이죠. 토스의 보이스톤이 다른 서비스와 구분되는 데에 결정적인 역할을 하는 가치예요. 금융이나 IT 업계에서 쓰던 어려운 용어와 딱딱한 뉘앙스를 쉽고 친절하게 고쳐 쓰고 있어요.\n\nRespect 존중하는\n\n네 번째 가치는 Respect예요. 존중하는 글쓰기란 뜻이죠. 제품을 만들다보면 당장 클릭하게 만들고, 전환시키고 싶은 마음에 코스트를 숨기거나 혜택을 더 크게 보이게 만들고 싶을 때가 있어요. 신뢰를 쌓는 것은 어렵지만 무너지는 것은 쉽죠. 당장의 이익을 조금 포기하더라도, 진실되고 사용자를 존중하는 커뮤니케이션을 해야 해요.\n\nEmotional 공감하는\n\n다섯 번째 가치는 Emotional이에요. 공감하는 글쓰기란 뜻이죠. 신뢰를 쌓을 때는 사실을 정확하게 전달하는 것도 중요하지만, 그것만으로는 부족할 때가 있죠. 토스와 연결되어 있다는 느낌을 받을 수 있게, 사용자가 느낄 감정에 공감하고 어떤 감동을 줄 수 있을지 고민해요.\n\n라이팅 프린시플\n\n토스에는 여덟 가지 라이팅 프린시플이 있어요. 코어밸류를 실제로 문장에 녹여내기 위해서 지향하는 원칙들이죠. 각각의 원칙들은 모두 코어밸류에서 기반한 것이랍니다.\n\n예를 들어 라이팅 코어밸류 중에는 concise라는 항목이 있는데, ‘간결하게 쓴다는 게 어떤 걸 의미하는 거지?’ 라고 궁금할 수 있잖아요. 그때 ‘의미 없는 단어를 없애자.’ 라는 한 층 더 구체적인 형태로 가공하는 거죠.\n\n가이드라인과 다른 점은, 프린시플만으로는 이 문장이 옳다 그르다를 무 자르듯 구분하기는 어렵다는 거예요. 대신 전반적인 방향성을 정하는 역할을 하죠. 이를테면 ‘의미 없는 단어를 없애자’고 제시하는 게 프린시플이라면, ‘[혹시]는 의미 없는 단어다’라고 결정하는 게 가이드라인이죠.\n\nPredictable hint\n다음 화면을 예상할 수 있는 힌트가 있는가?\n\n다음 화면을 예상할 수 있는 문장을 씁니다. 사용자가 다음 화면으로 넘어갈 때 충분한 힌트를 줘야 해요. 종종 결과적으로 사용자가 얻을 수 있는 이익을 설명하느라, 당장 다음 화면에서 무슨 일이 일어날지 쓰지 않게 되는 경우가 있는데요. 사용자에게 밸류를 알려주는 것은 좋지만, 이것이 과하면 사용성을 해칠 때도 있으니 주의해야 해요.\n\n\n[다른 곳에서 후불결제 하기]라는 버튼을 눌렀더니 자신이 쓰는 브랜드를 제보하는 설문 조사 화면이 나왔어요. 토스는 그 설문을 받아서 새로운 브랜드를 제휴하기로 했던 거죠. 그렇게 제휴가 되면 궁극적으로 원하는 브랜드에서 후불 결제를 할 수 있게 되니 틀린 말은 아니지만, 당장 다음 화면에서 무슨 일이 일어날지 알려주지 않았기 때문에 사용자는 불안할 수밖에 없어요.\n\nWeed cutting\n의미 없는 단어를 모두 제거했는가?\n\n토스에서는 넣든 빼든 의사 전달에 영향이 없는 단어를 잡초라고 불러요. 작은 모바일 화면 안에서는 문장 안에 자라있는 잡초들을 제거하는 게 중요하죠. 우리는 모바일 앱을 쓸 때 읽지 않아요. 스캔하죠.\n\n사용자가 빠르게 원하는 정보를 습득할 수 있도록, 간결하게 써야 해요. 단, 단순히 글자 수를 줄이는 것보다 의미 없는 단어와 문장을 제거하는 것이 중요해요.\n\n\n[앞으로]라는 단어는 이 문장에서 넣어도 그만, 빠져도 그만인 단어죠. 굉장히 소소하지만, 이런 작은 잡초들을 뽑는 것부터가 간결한 라이팅의 시작이에요.\n\nRemove empty sentences\n의미 없는 문장을 모두 제거했는가?\n\nWeed cutting이 문장 안의 잡초를 뽑는 원칙이라면 이 항목은 화면 안의 잡초, 즉 의미 없는 문장을 뽑는 거예요. 한 화면 안에서 똑같은 말을 불필요하게 반복해서 쓰지 않는 거죠.\n\n공간이 비어보인다거나, 뭔가 허전한 느낌이 든다는 이유로 의미 없는 문구를 쓰는 것도 피해야 하고요.\n\n\n전달하고 싶은 내용을 제목에서 충분히 이야기했음에도, 종종 뭔가 허전해보이는 느낌에 의미 없는 설명을 덧붙일 때가 있어요. 똑같은 말을 반복하는 것도 포함이고요. 그런 텅 빈 문장들은 사용자가 정말 중요한 정보에 집중하는 데에 방해가 돼요.\n\nFocus on key message\n정말 중요한 메시지만 전달하고 있는가?\n\n메이커는 제품의 맥락을 많이 알고 있다보니 가끔 지나치게 많은 것들을 설명할 때가 있어요. 사용자에게 당장 필요한 정보가 아닌데도 알려줘야 할 것 같은 압박을 느끼는 거죠.\n\n문제는 이런 압박이 사용자에게는 글을 읽어야 하는 부담으로 다가온다는 점이에요. 사용자가 이미 알고 있는 정보는 과감하게 생략하고, 지금 꼭 확인해야 하는 내용만 추려서 전달하는 게 중요해요.\n\n\n그 달의 원금과 이자를 자동 이체로 갚은 뒤에, 추가적으로 상환하고 싶을 때 보게 되는 화면이에요. 기존 안에서는 여러 내용을 설명하긴 했지만 그래서 사용자가 어떤 것을 선택해야 하는지가 명확하지 않았죠.\n\n자세히 읽어보면 두 선택지의 차이는 금액을 직접 입력하는 것과 다음 달에 내야 할 금액을 자동으로 설정하는 것이었죠. 모든 맥락을 설명해주는 것만 친절한 게 아니라, 때로는 정보를 생략해서 필요한 내용만 알려주는 것이 더 친절한 커뮤니케이션일 때가 있어요.\n\nEasy to speak\n이해하기 어려운 용어나 표현을 사용하지 않았는가?\n\n쉽게 표현합니다. 일상에서 구두로 쓰이지 않는 단어나 금융, IT 업계에서만 쓰이는 전문 용어를 최대한 줄여, 별도의 학습 없이도 이해할 수 있게 직관적으로 써야 해요.\n\n한 문장 안에는 가능하면 하나의 메시지만 담아서 짧은 호흡으로 한 번에 읽을 수 있도록 쓰고요.\n\n\n이 원칙의 핵심은 Easy to read가 아니라 speak이라는 점이에요. 눈으로 읽었을 때 어색하지 않더라도, 실제로 소리 내어 읽었을 때 어색한 문장이 있어요. 한자어를 쓰거나, 문어체를 쓰거나, 호흡이 지나치게 긴 문장들이죠.\n\nSuggest than force\n\n특정 행동을 강요하거나 공포감을 주고 있지 않은가?\n\n권유와 강요는 다릅니다. 스스로에게 선택권이 있다는 점을 느낄 수 있게, 사용자를 존중하는 문장을 써야 해요. 사용자에게 우리가 원하는 바를 강요하거나 협박하지 않아야 해요. 불필요한 공포감을 조성해서 우리가 원하는 방향으로 유도하는 것도 피해야 해요.\n\n\n계좌를 개설하는 도중에 나가는 사용자에게 어떤 안내를 해야 할까요? 물론 사용자가 놓칠 수 있는 혜택을 알려주는 것도 좋지만, 그게 ‘이 혜택을 놓치면 손해보시는 거예요’라는 뉘앙스를 함께 전달해서는 안되겠죠. 혜택을 그대로 전달하면서도 사용자가 온전히 스스로 선택할 수 있게 뉴트럴한 톤으로 문구를 바꿨어요.\n\nUniversal words\n모두가 이해할 수 있고 모두에게 무해한가?\n\n모두가 알아 들을 수 있고, 불편함을 느끼지 않는 문장을 씁니다. 연령, 교육 수준 및 종사 업계에 따라 이해도가 다른 용어를 지양하고, 정보 진입 장벽을 높이는 단어는 쉽게 바꿔야 해요.\n\n이 원칙은 보통 유행어, 은어, 밈 등을 쓸 때 많이 어겨지는데요. 이 원칙을 지키면서도 올드하거나 지루하지 않고 세련된 위트를 구사하기 위해 노력하고 있어요.\n\n\n특정 사용자들만 이해할 수 있는 유행어보다, 사실을 전달하는 것에 초점을 맞추면 모두가 이해할 수 있는 문구를 쓸 수 있어요.\n\nFind hidden emotion\n단순히 정보를 전달하는 것을 넘어 사용자의 감정에 공감했는가?\n\n필요한 정보를 정확하게 전달하는 것도 중요하지만, 그 정보를 전달받는 순간 사용자의 마음이 어떨지 생각해보면 전혀 다른 커뮤니케이션을 할 수도 있어요. 정보 뒤에 숨은 감정을 생각해보며, 직관적인 문장을 넘어 공감하는 문장으로 사용자와 유대감을 만들어요.\n\n\n대표적인 사례로 대출 만기 푸시가 있어요. 한 번은 제가 다른 은행 앱에서 대출을 다 갚은 적이 있는데, 아무런 안내도 없이 대출 계좌가 사라져버렸어요. 매달 꼬박 꼬박 갚았던 기록이라도 남길 수 있을 줄 알았는데 말이죠.\n\n상환은 그저 대출이 사라졌다는 것만을 의미하는 게 아니라는 걸 알게 됐어요. 그보다는 지금까지 해온 노력이 보상처럼 다가오는 순간이었죠.\n\n그때의 기억을 떠올리면서 토스에서는 대출을 모두 상환하는 순간에 축하 메시지를 보내기로 했어요. 이 푸시를 받아 본 사용자 분들이 “힘이 됐다”라는 후기를 많이 남겨주셨었어요.\n\n라이팅 시스템은 살아있는 유기체\n라이팅 프린시플이 처음부터 여덟 가지는 아니었어요. 네 가지로 시작했다가 잘 지켜지는 원칙은 없애고, 새로운 원칙을 추가하기도 하면서 지금의 프린시플이 완성되었죠. 코어밸류나 프린시플은 한 번 만들고 끝나는 게 아니라, 없애거나 더하면서 발전할 수 있어요. 살아있는 유기체처럼요.\n\n예를 들어 Weed cutting 과 Remove empty sentences, Focus on key message. 이 세 가지 원칙은 이름은 조금씩 다르지만, 궁극적으로는 간결한 글쓰기가 목적이죠. Weed cutting이 잘 지켜지면서 토스는 좀 더 높은 수준의 간결함을 추구하게 됐어요.\n\n그래서 파생된 두 가지 원칙을 추가하게 됐어요. Weed cutting만 있을 때는 ‘모든 잡초를 뽑자!’였다면, 지금은 Weed cutting은 문장 안의 잡초를, Remove empty sentences는 화면 안의 잡초를, Focus on key message는 화면 간의 잡초를 없애는 것으로 좀 더 뾰족하게 정의해서 쓰고 있죠.\n\n여러분의 제품에는 어떤 프린시플이 필요한가요? 토스의 프린시플을 대입해봤을 때 이미 잘 지켜지는 것도 있고, 더 세부적으로 신경 쓰고 있는 부분도 있을 거예요. 여러분의 제품에 꼭 맞는 라이팅 원칙들을 발견하게 되면 알려주세요!\n\n","isDisplayingFeedback":true},{"id":21032,"updatedTime":"2023-04-12T17:25:56+09:00","createdTime":"2023-04-12T16:04:04+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"가이드라인을 시스템으로 만드는 법","subtitle":"UX 라이팅은 한 명이 아닌, 팀원 모두가 잘 쓰는 게 중요해요. 이전까지는 세션이나 가이드라인 등의 방법으로 이 문제를 접근해왔지만, 토스는 조금 다르게 풀어봤어요. 시스템으로요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/11/Screen-Shot-2022-11-04-at-5.34.15-PM.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/11/Screen-Shot-2022-11-04-at-5.34.15-PM.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"introducing-toss-error-message-system","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-11-04T16:39:40+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21032,"title":null,"description":"UX 라이팅은 한 명이 아닌, 팀원 모두가 잘 쓰는 게 중요해요. 이전까지는 세션이나 가이드라인 등의 방법으로 이 문제를 접근해왔지만, 토스는 조금 다르게 풀어봤어요. 시스템으로요.","urlSlug":"introducing-toss-error-message-system","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"가이드라인을 시스템으로 만드는 법","description":"UX 라이팅은 한 명이 아닌, 팀원 모두가 잘 쓰는 게 중요해요. 이전까지는 세션이나 가이드라인 등의 방법으로 이 문제를 접근해왔지만, 토스는 조금 다르게 풀어봤어요. 시스템으로요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-6-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2338,"relatedPosts":[{"id":21024,"updatedTime":"2023-07-05T22:07:39+09:00","createdTime":"2023-04-12T16:03:17+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"내 아이디어를 너무 믿지 마세요","subtitle":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"dont-trust-your-gut","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-28T17:31:40+09:00","commentBoard":null,"disclaimer":null},{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":563,"name":"김자유","slug":"jayu-kim","shortDescription":"UX Writer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/jayu-kim.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":4,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"지난 아티클에서는 좋은 에러 메시지의 기준을 이야기했어요.\n\n하지만 기준이 있어도 아무도 그것을 따르지 않고 실제로 적용되지 않으면 의미가 없겠죠. 기준을 만드는 일은 라이팅 팀 단독으로 할 수 있지만, 그것이 팀에 전파되게 하려면 팀원분들의 공감대를 얻어야 해요.\n\n그러기 위해서 좋은 기준을 만드는 것을 넘어, 그 기준을 ‘쓰고 싶다’ 혹은 ‘써야겠다’라는 생각이 들게 문화를 만드는 일이 훨씬 더 중요해요. 이번 글에서는 잘 만든 기준을 팀에 전파하고, 제품에 적용하기 위해 어떤 노력들을 했는지 공유해드리려고 해요.\n\n유저 경험에서 중요한 역할을 하는 에러 메시지\n사실 처음부터 에러 메시지의 기준이 있었던 건 아니었어요. 처음에는 어떤 라이팅 문제를 먼저 해결해야 할까? 라는 고민에서 출발했어요. 사용자가 앱을 처음 접하고 팬이 되기까지 어떤 과정을 겪는지 생각해봤고, 거기서 에러 메시지가 굉장히 중요한 역할을 하겠다는 생각이 들었어요.\n\n매력을 느껴 앱을 다운로드받고, 사용하면서 점점 익숙해질 즈음, 에러 상황을 만났을 때. 바로 그때 치명적으로 부정적인 경험을 한다면 그 다음 단계인 팬으로 이어지는 게 어려울 것 같았거든요.\n\n\n무작정 워싱부터 시작했던 처음\n\n문제 의식은 있었지만, 어떻게 시작해야 할지 모르겠더라고요. 그래서 무작정 사일로로 찾아가 각 제품에 있는 모든 에러 메시지를 하나하나 고치는 것으로 시작했어요.\n\n라이터가 각각 다른 제품을 맡고, 이해되지 않는 것들은 메모를 남겨 가며 꼼꼼하게 워싱했어요. 각자 워싱한 후에 크로스 체크를 하며 비슷한 에러 메시지는 똑같은 문구로 통일하고, ‘Navigating error’라는 큰 기조 아래에서 서로 다르게 생각하는 세세한 부분들을 논의하며 작은 규칙들을 정해갔어요.\n\n*Navigating error: 토스 에러 메시지의 기조. 에러 메시지의 역할은 다음 화면으로 넘어갈 수 있게 안내하는 것이라는 뜻.\n\n그렇게 문구를 한 판씩 완성하고 나서 개발자분들께 새로운 문구를 적용해달라고 요청했어요. 물론 이 작업들이 물 흐르듯 진행되지는 않았고, 여러 문제점들이 있었어요. 저희가 쓴 에러 메시지가 정말 좋은 방향이 맞는지부터, 개발자 분들의 리소스를 써야했기 때문에 이 일이 그만큼 중요하다는 것까지 하나하나 설득하는 과정을 거쳐야 했거든요.\n\n\n에러 메시지에 어떤 내용이 담겨야 하는지, 팀원들을 설득했던 스레드\n\n한 예로는 “(우리 잘못인데)에러 메시지에도 해요체를 적용해야 할까요?”라는 물음에 지금은 당연하게 “네!”라고 답할 수 있지만, 긴 근거를 대며 설득해야 했을 때가 있었어요. 물론 그런 시기가 있었기 때문에 지금은 좋은 에러 메시지에 대해 다들 비슷한 기준과 공감대가 형성되어있고요.\n\n감사하게도 공감해주신 팀원분들께서 적극적으로 협조해주신 덕에, 워싱된 메시지들을 차근차근 적용할 수 있었어요. 특히 사일로에 계신 개발자 분들께 몇 백 개에 육박하는 에러 메시지를 하나씩 뜯어보면서 이 에러가 왜 발생했는지, 어떻게 해결할 수 있는지, 아예 발생하지 않을 수는 없었는지를 귀찮을 정도로 여쭤봤었는데요.\n\n\n하나하나 싱크하며 적용하느라 100개 가까이 되는 스레드\n\n시트를 하나하나 체크해가며 행 단위로 답변해주시고, 다른 곳에서 비슷한 게 쓰이고 있는지, 더 좋은 문구를 쓸 순 없을지 적극적으로 논의해주셨어요. 그렇게 마무리 되었다가도, 더 좋은 문구가 생기면 흔쾌히 이전 버전을 지우고 다시 적용해주시기도 했고요. (함께 해주신 에러 용사님들 정말 감사합니다🥲)\n\n에러 메시지 템플릿\n그렇게 모든 에러 메시지를 하나하나 고치다보니 패턴이 보이기 시작했어요. 똑같은 내용인데 다른 문구를 쓰고 있거나, 전혀 다른 내용인줄 알았는데 하나로 통일할 수 있는 메시지, 다른 상황이지만 해결책이 똑같은 에러들… 이런 메시지를 규격화할 수 있겠다는 생각이 들었죠. 그래서 반복해서 나타나는 상황들을 카테고리화하고 각각의 상황에 맞는 문구를 템플릿으로 만들고, 원칙도 만들었어요.\n\n\n서비스 점검 템플릿\n\n예를 들면 은행에서 시스템 점검을 할 때 안내 다이얼로그를 띄워야 해요. 근데 은행 이름과 점검 시간만 바뀌고, 나머지 내용은 동일하기 때문에 문구를 하나로 통일할 수 있죠. 그래서 통일된 템플릿 문구를 만들었어요.\n\n\n상황별로 세분화된 템플릿\n\n그런데 이 템플릿을 쓰다 보니, 문구를 그대로 쓸 수 없는 상황도 있는 거예요. 정기 점검이 아니라서 점검 시간이 정해져 있지 않거나, 정기 점검이긴 하지만 그 시간이 2분 정도로 너무 짧아서 시간을 기재해줄 필요가 없는 경우처럼요. 그래서 이런 예외 상황별로도 문구 세트를 만들었고, 이제 시스템 점검 에러는 템플릿으로 대부분 커버되는 상태가 됐어요. 그런 식으로 여러가지 상황별 템플릿을 하나씩 추가했어요.\n\n에러 메시지 시스템\n사실 이렇게 템플릿이 있는 것만으로도 문구를 쓰기가 훨씬 쉬워졌지만, 더 간편해질 수는 없을까? 라는 생각이 들었어요. 왜냐하면 템플릿이 노션이나 스프레드 시트 등 디자인 툴 밖에 있었기 때문에, 문구를 쓸 때마다 디자인 화면 밖으로 나갔다가 다시 돌아와야 했기 때문이에요.\n\n게다가 검색에 최적화된 툴들도 아니어서 원하는 문구를 바로 찾기도 어려웠고, 문구만 있었기 때문에 컴포넌트에 하나하나 직접 붙여 넣어야 한다는 점도 번거로웠죠.\n\n이런 접근성 문제를 해결하기 위해, 메시지를 작업 환경 위에서 바로 검색할 수 있으면 좋겠다는 생각이 들었어요. 에러 메시지는 주로 개발자와 디자이너, 두 직군이 작성하고 계신데요.\n\n\n이전에는 메시지를 전부 직접 써야 했지만, 에러 메시지 라이브러리로 한 줄이면 충분해진 코드\n\n개발자 분들을 위한 기능으로는 에러 메시지 라이브러리가 있어요. 코드를 쓰면서 에러 메시지 컴포넌트를 불러올 수 있는 기능인데요. 에러 메시지 작업에 처음부터 함께 해주셨던 개발자 홍욱님께서, 워싱된 문구를 직접 적용하시다가 필요성을 느껴 만들어주셨어요.\n\n이전에는 개발자가 에러 메시지를 쓸 때 디자이너에게 문구를 물어봐야했어요. 그걸 들은 디자이너는 자세한 맥락을 모르니까 PO나 서버 개발자에게 설명을 들어야 했고, 그 후에 다시 디자이너가 문구를 직접 써서 iOS/안드로이드/서버 개발자에게 다시 전달했죠. 이 과정이 너무 번거로워서 디자이너와 논의하지 않고 직접 쓰시거나 다른 제품에서 비슷한 메시지를 복사하시는 경우도 많았고요.\n\n그런데 에러 메시지 라이브러리가 생기고부터는 개발자가 디자이너와 커뮤니케이션할 일도 줄어들고, 하더라도 템플릿이라는 기본값에서 논의가 시작되니 금방 끝낼 수 있게 됐죠. 비슷한 에러끼리는 똑같은 문구로 규격화되어있으니 검색하기도 쉬워지고, 제품에 일관성을 부여하기도 좋아졌고요.\n\n(지금은 일부 사일로에 적합한 메시지들로 구성되어있지만, 라이브러리를 더 풍성하게 채워서 전사로 확장하는 게 앞으로의 과제예요. 💪)\n\n\n관련 키워드를 검색하면 나오는 문구 템플릿\n\n토스는 디자인 툴로 프레이머를 쓰고 있는데요. 디자이너 분들을 위한 기능으로는 프레이머링을 만들었어요. 디자인을 하면서 프레이머 안에서 필요한 문구를 검색하고 바로 붙여넣을 수 있는 기능이에요. ‘구글링 대신 프레이머링 해보세요’라는 의미에서 지은 이름이에요.\n\n프레이머에서는 검색창을 열어 TDS(토스 디자인 시스템)에 등록되어있는 컴포넌트를 검색하고, 스티커처럼 붙여서 디자인할 수 있어요. 이전에는 컴포넌트 안에 ‘동해물과 백두산이’ 같은 더미 텍스트가 들어가있었는데, 자주 쓰는 문구들이 들어가있는 컴포넌트를 프리셋으로 쓸 수 있게 한 게 프레이머링이에요.\n\n\n상황별 템플릿\n\n프레이머링의 좋은 점은 노션이나 스프레드 시트과 다르게, 컴포넌트를 통째로 붙여넣을 수 있다는 점이에요. 노션으로 문구를 검색해서 쓸 때는 문구를 타이틀 따로, 디스크립션 따로 복사해서, 적절한 컴포넌트에 맞게 직접 붙여넣었어야 했어요. 프레이머 안에서는 문구가 들어있는 컴포넌트 자체를 바로 붙여넣을 수 있기 때문에 훨씬 간편해졌죠.\n\n이후에는 개발자 현수님, 현지님, 규진님과 플랫폼 디자이너 정현님의 도움을 받아, 컴포넌트를 불러오면 그 컴포넌트에서 자주 쓰이는 문구 템플릿을 미리보기할 수 있는 기능도 추가했어요.\n\n\n문구를 직접 쓰지 않고 프레이머링을 써달라고 요청하는 라이팅 팀\n\n이전에는 프로덕트 디자이너분들이나 개발자분들이 타사 앱을 참고하거나 슬랙을 검색해서 라이터가 썼던 문구를 참고해서 직접 쓰셔야 했는데요. 이제는 이 템플릿을 복사해서 붙여넣기만 하면 되니까 디자이너분들은 라이팅 팀에 요청할 필요 없고, 라이팅 팀도 매번 같은 문구를 직접 쓰지 않아도 돼서 시간을 많이 아낄 수 있었죠. 게다가 모두가 같은 문구 템플릿을 쓰니 제품 전체의 일관성도 챙길 수 있게 됐고요.\n\nUX 라이팅의 핵심은 함께 쓰기\nUX 라이팅과 카피라이팅의 가장 큰 차이점은 카피라이터는 개인이 잘 쓰는 것이 중요하지만, UX 라이터는 함께 잘 쓰는 것이 중요하다는 점이에요. 카피라이팅은 광고 하나가 제품이지만, UX 라이팅은 앱 전체가 하나의 제품이기 때문이죠.\n\n모든 화면에서 일관적인 커뮤니케이션을 해야 하기 때문에, 좋은 문구를 쓰는 것은 물론 그 문구를 다른 팀원들도 똑같이 써낼 수 있게 만드는 일이 중요해요. 처음에는 모든 에러 메시지를 라이터가 직접 썼지만, 그 에러 메시지를 다른 팀원분들도 직접 쓸 수 있게 만들기 위해서 여러가지 시도들을 한 것처럼요.\n\n모두가 좋은 문장을 쓰게 만드는 일은 직접 메시지의 중요성을 이야기해서 문화적으로 풀 수도, 에러 메시지 라이브러리나 프레이머링처럼 작성의 허들을 낮춰 기술적으로 풀 수도 있어요. 토스에서 시도한 방법들 외에도, 조직마다 잘 맞는 새로운 방법들이 많을 거예요.\n\n이 글을 시작으로 업계에 더 다양하고 효과적인 해결책들이 자주 공유되었으면 해요!","isDisplayingFeedback":true},{"id":21029,"updatedTime":"2023-04-12T17:25:56+09:00","createdTime":"2023-04-12T16:03:51+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"2초만에 불필요한 클릭 없애는 4가지 방법","subtitle":"토스 앱에는 little big detail 이 많은데요, 그중 하나를 소개하고 싶어요.\n바로 불필요한 클릭 없애는 방법이에요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/09/design-article-5-thumbnail.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/09/design-article-5-thumbnail.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"4-ways-for-minimum-input","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-10-20T11:20:00+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21029,"title":null,"description":"토스 앱에는 little big detail 이 많은데요, 그중 하나를 소개하고 싶어요.바로 불필요한 클릭 없애는 방법이에요.왜 불필요한 클릭을 줄여야 할까요? 이유는 단순해요.사용자의 1초를 줄이면 어떤 일이 일어날까요?토스 앱으로 예를 들어볼게요. 클릭 1회를 1초의 시간이 걸린다고...","urlSlug":"4-ways-for-minimum-input","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"2초만에 불필요한 클릭 없애는 4가지 방법","description":"토스 앱에는 little big detail 이 많은데요, 그중 하나를 소개하고 싶어요.\n바로 불필요한 클릭 없애는 방법이에요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://og.toss.tech?title=2%EC%B4%88%EB%A7%8C%EC%97%90%20%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C%20%ED%81%B4%EB%A6%AD%20%EC%97%86%EC%95%A0%EB%8A%94%204%EA%B0%80%EC%A7%80%20%EB%B0%A9%EB%B2%95&imageUrl=https%3A%2F%2Fstatic.toss.im%2Fassets%2Fhomepage%2Ftosstech%2Fog%2Fdesign-article-5-2-og.png&v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2341,"relatedPosts":[{"id":21024,"updatedTime":"2023-07-05T22:07:39+09:00","createdTime":"2023-04-12T16:03:17+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"내 아이디어를 너무 믿지 마세요","subtitle":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"dont-trust-your-gut","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-28T17:31:40+09:00","commentBoard":null,"disclaimer":null},{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":570,"name":"강영화","slug":"younghwa-kang","shortDescription":"Product Designer(Tools)","description":"_","imageUrl":"https://static.toss.im/illusts/profile-younghwa.jpeg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":4,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"토스 앱에는 little big detail 이 많은데요, 그중 하나를 소개하고 싶어요.바로 불필요한 클릭 없애는 방법이에요.\n\n왜 불필요한 클릭을 줄여야 할까요? 이유는 단순해요.\n\n사용자가 더 빠르게 원하는 태스크를 수행할 수 있어요.\n빠른 속도나 빠르다는 인상을 주게 되어 사용자 경험이 좋아져요.\n사용자의 1초를 줄이면 어떤 일이 일어날까요?\n\n토스 앱으로 예를 들어볼게요. 클릭 1회를 1초의 시간이 걸린다고 가정하고요. 2022년 10월 현재 MAU(월간 활성 사용자) 1,437만 명의 클릭 한번 줄인다면 그것만으로도 약 6개월을 아낄 수 있어요. 우리 사용자가 불필요한 일을 하지 않는 대신 더 가치 있는 기능을 찾게 도와주면 이 6개월의 시간은 클릭 한번보다 더 가치 있겠죠? 😉\n\n이렇게 토스에서는 다양한 방법으로 사용자의 클릭을 덜어내려고 해요. 이런 노하우는 디자인 시스템에 구현되어있지요.\n\n모두 다 알려드리고 싶지만, 이 글에는 누구나 활용할 수 있는 아주 쉬운 방법을 알려드릴게요. 이 방법은 텍스트나 정보를 입력받는 인풋 필드에 적용되는 방법이에요. 디자이너뿐 아니라 개발자분들도 바로 적용할 수 있을 만큼 매우 간단해요.\n\n따라와 보세요!\n\nㅤ\n\n1. 정보를 하나만 입력받을 땐 CTA 없애기\n메인 버튼을 CTA라고 하죠. ‘call to action’의 약자에요. 사용자가 정보 하나만을 선택하고 나가는 화면에서는 CTA를 없애보세요. 하나만 선택하는 화면에서 파란색 CTA 버튼을 없애봅시다. 사용자가 하나의 정보만 입력할 때는 요 CTA가 필요 없을 때가 있어요. 사용자가 불필요하게 CTA 버튼 클릭하는 비용을 줄일 수 있어요. 없애봅시다!\n\n\nㅤ\n\n2. 자리수가 정해져 있는 정보를 받는 경우 CTA 없애기\n주민등록번호, 휴대폰 번호 등 필드 자릿수가 정해져 있는 경우 CTA 버튼이 없어도 돼요. 버튼이 없어서 어색하다고 느껴질 수 있지만 UT를 해보면 사용자분들은 스스로 기억하고 있는 번호를 입력하기 바쁘세요. 앞서 쓴 회원가입 퍼널에서도 96%가 조금 넘는 사용자가 주민등록번호 퍼널을 통과하는 등 사용자는 엄청 자연스럽게 받아들인답니다. 확인 버튼을 생략할 수 있다면 없애보세요.\n\n\nㅤ\n\n3. 올바른 키보드가 처음부터 세팅되어있도록 하기\n텍스트를 입력 받는 인풋 필드 같은 경우 키보드 종류를 맥락에 맞게 설정해주세요. 인증번호 입력 받는 화면으로 예를 들어보면요. 인증번호는 숫자로 올 텐데, 기본값으로 한글 키보드가 세팅되어있다면 사용자는 숫자를 입력하기 위해 한 번 더 불필요한 클릭을 해야 합니다. 정보에 맞는 인풋을 받을 수 있도록 신경 쓰는 것만으로 효과 있어요.\n\n\nㅤ\n\n4. Focus 상태로 진입하게 만들기\n키보드가 올라온 상태로 페이지에 진입할 수 있도록 만들어보세요. Focus 상태가 아니라면 사용자는 한 번 더 텍스트 필드를 클릭해야해서 불필요한 클릭이 발생해요.\n\n경험상 적용하는 공수는 매우 적은 데 반해 놓치기 쉬운 디테일이었어요. 놓친 화면이 있다면 적용해보세요!\n\n\nㅤ\n\n사실 위 방법 말고도 사용자에게 정보를 입력받지 않고도 필요한 정보가 모두 입력되면 좋겠죠.\n\n가령, 데모그래피를 활용해서 사용자 대신 정보를 입력해주고 추가로 필요한 정보만 입력받는 퍼널만 만들 수도 있고요. 사용자가 이전에 입력해뒀던 내용에 기반에 적극적인 추천을 해줄 수도 있고요.\n\n토스에서는 아래처럼 여러 가지 시도했는데요. 한번 살펴보세요.\n\n토스 신용카드 가입 과정을 더 쉽게 만들기 위해 여러 차원에서 고민했고요.\n은행 계좌번호를 정확히 모르는 사용자에게 나와의 송금 내역을 기반으로 계좌번호를 정확히 알려주기도 했고요.\n내부용 툴을 만들면서도 사용자가 입력해야 하는 것들을 최대한 빼기 위해 템플릿화하고 자동으로 입력해줬죠.\nㅤ\n\n완전 멀리 나아가서 상상의 나래를 펼쳐본다면 어떨까요?\n\n사용자가 뭘 넣을지 생각만 해도 미리 채워줄 수 있다면?\n사용자 시선을 읽어서 뭘 찾을지 알고 미리 클릭해준다면?\n구두로 말하기만 해도 머신러닝 모델이 다 요약해주고 키워드를 뽑아내 자동으로 입력해준다면?\n이 외에도 끝까지 갈 수 있는 모습을, 사용자의 문제가 아예 없는 미래도 상상해보세요. 모르죠. 의외로 쉽게 적용할 수 있는 아이디어를 얻게 될지도?\n\nㅤ\n\n오늘 읽은 것 하나나 다른 작은 아이템을 여러분 제품에 적용해가면서 사용자의 클릭을 하나라도 덜어보세요.\n\n사용자의 시간은 소중하니까요 ❤️","isDisplayingFeedback":true},{"id":21020,"updatedTime":"2023-04-12T17:25:55+09:00","createdTime":"2023-04-12T16:02:55+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"경험이 부족한 나도 토스에 지원해도 될까?","subtitle":"이력서, 포트폴리오가 아닌 과제 중심으로 역량을 평가한 프로덕트 디자이너 챌린지. 신입이라 선뜻 지원을 못했었는데, 챌린지를 통해 입사할 수 있었어요. 챌린지에 참여하게 된 계기와 문제를 해결하면서 고민했던 부분들, 장표를 어떻게 구성했는지까지 자세한 후기를 공유해드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/10/design-article-4-thumbnail.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"2022 프로덕트 디자이너 챌린지 후기"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/10/design-article-4-thumbnail.png","backgroundColor":null,"isFill":false,"imageAlt":"2022 프로덕트 디자이너 챌린지 후기"},"key":"product-designer-challenge-review","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-10-04T21:13:05+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21020,"title":null,"description":"6월 말 어느 날, IT 동아리 팀원 분이 요런게 있다며 링크를 공유해주셨어요.https://wp.toss.tech/wp-content/uploads/2022/10/IMG_6984.JPG-862x1024.jpg저는 링크를 누르기도 전에 챌린지라는 단어와 이미지만 보고 ‘재밌겠다!’라는 ...","urlSlug":"product-designer-challenge-review","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"경험이 부족한 나도 토스에 지원해도 될까?","description":"이력서, 포트폴리오가 아닌 과제 중심으로 역량을 평가한 프로덕트 디자이너 챌린지. 신입이라 선뜻 지원을 못했었는데, 챌린지를 통해 입사할 수 있었어요. 챌린지에 참여하게 된 계기와 문제를 해결하면서 고민했던 부분들, 장표를 어떻게 구성했는지까지 자세한 후기를 공유해드릴게요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-4-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2337,"relatedPosts":[{"id":21024,"updatedTime":"2023-07-05T22:07:39+09:00","createdTime":"2023-04-12T16:03:17+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"내 아이디어를 너무 믿지 마세요","subtitle":"너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.","bottomButtonConfig":{"ctaType":"EMPHASIS_TEXT","imageUrl":null,"imageAlt":null,"title":"토스 Tools Product Designer가 궁금하다면?","description":"","ctaName":"채용 공고 보기","landingUrl":"https://toss.im/career/job-detail?job_id=5470955003","isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":"supertoss://web?url=https%3A%2F%2Ftoss.im%2Fcareer%2Fjob-detail%3Fjob_id%3D5470955003&external=true&clearHistory=true&swipeRefresh=true","landingExternal":"https://toss.im/career/job-detail?job_id=5470955003"},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/design-article-14-og.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"dont-trust-your-gut","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-28T17:31:40+09:00","commentBoard":null,"disclaimer":null},{"id":21004,"updatedTime":"2023-04-14T11:59:06+09:00","createdTime":"2023-04-12T16:00:54+09:00","categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"추천할 때는 제일 좋은 것 하나면 된다","subtitle":"제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요?","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":null},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2023/03/thumbnail-03.png","backgroundColor":null,"isFill":false,"imageAlt":null},"key":"recommend-just-one","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2023-03-23T16:43:33+09:00","commentBoard":null,"disclaimer":null}],"title":"다른 글 둘러보기"},"editor":{"id":567,"name":"배희영","slug":"heeyoung-bae","shortDescription":"Product Designer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/heeyoung-bae.jpg","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"6월 말 어느 날, IT 동아리 팀원 분이 요런게 있다며 링크를 공유해주셨어요.\n\n\n저는 링크를 누르기도 전에 챌린지라는 단어와 이미지만 보고 ‘재밌겠다!’라는 생각이 들었어요. 링크를 확인해보니 신입이든 10년 차 경력이든 누구나 참여할 수 있다는 사실에 더욱 관심이 가게 되었어요.\n\n“이전 회사에서 어떤 일을 했는지는 중요하지 않아요. 오직, 제출한 솔루션으로만 여러분의 잠재력을 평가합니다.””신입과 경력을 구분하지 않기 때문에 10년 차 이상 혹은 무경험자도 가능합니다.”\n\n토스는 정말 가고 싶었던 회사였지만 경력을 주로 뽑는다는 인식이 있어어요. ‘연차 쌓고 제대로 준비해서 지원해야지!’ 라고 생각하며 쉽게 지원해보지 못했죠. 하지만 챌린지는 제한된 시간 안에 동시에 제공되는 과제로만 평가받을 수 있다는 점이 시도는 해볼 수 있겠다는 생각이 들었던 것 같아요.\n\n한 가지에만 집중할 수 있는 챌린지\n토스 챌린지는 과제가 공개된 시점으로부터 60시간이 주어졌어요. 그래서 시간을 효율적으로 사용하기 위해 가장 먼저 토스에서 챌린지를 통해 평가하고자 하는 게 무엇인지 살펴봤어요.\n\n\n평가 기준과 유의 사항에는 지원자의 관점이 잘 드러난 문제 정의인지, 그에 맞는 합리적인 솔루션인지를 주요하게 보며, 단순한 GUI Redesign은 평가하지 않는다는 내용이 여러 번 언급이 되었는데요.\n\n실제로 UT 영상을 제공해 이 안에서만 문제를 고민할 수 있도록 했고, UT에서 사용된 화면의 에셋들을 모두 제공해주었어요. 그래서 주어진 시간 동안 UI 디자인의 오류보다는 UT 속 유저 경험에 집중했고, 유저가 겪고 있는 문제를 어떤 기준과 근거를 가지고 해결해 나갈 것인지를 중점으로 고민했어요.\n\n이전까지 프로젝트를 하거나 채용 과제를 받으면 항상 UX 리서치부터 UI 디자인까지 모든 단계를 고민했었어요. 한정된 시간 내에 모든 걸 담으려고 하니까 진짜 중요한 문제에 깊게 파고드는 게 힘들었는데요. 토스 챌린지에서는 핵심 역량에 집중할 수 있도록 UT 영상이나 디자인 에셋을 제공해준 점이 가장 큰 차이라고 느꼈어요.\n\n가장 중요한 문제 찾기\n챌린지를 통해서 지원자들의 문제 해결 역량을 중요하게 보겠다는 건 알겠는데, 그럼 어떻게 이 문제 해결 역량을 보여주느냐가 고민이 되었죠. 단순히 여러 문제를 찾고 해결방안을 내놓는 걸 보려는 게 아닐 거라고 생각했어요.\n\n그래서 일단 UT 영상에서 유저가 겪는 불편한 경험을 보이는 대로 나열해봤어요. 확인했을 땐 너무 많은 문제가 보였죠. 근데 이 문제들이 짧은 챌린지 기간 동안 다 풀어야 하는 진짜 중요한 문제들일까? 라는 의문이 들었어요. 그래서 가장 중요한 문제에 집중할 수 있도록 기준을 세워야겠다고 생각해 목표를 세웠어요.\n\n유저는 어떤 목적을 가지고 이 제품을 사용하며, 제품을 통해 얻을 수 있는 가치는 무엇일지 생각했는데요. 이 목표를 달성할 수 없게 하는 가장 치명적인 것이 무엇인지를 기준으로 생각해보니 문제를 해결해야 하는 우선순위가 세워졌어요.\n\n먼저 과제는 가상 서비스로 배달 플랫폼이 주어졌는데요. 배달 서비스를 이용하는 유저는 음식을 빠르게 시키고 배달받기 위해 앱에 진입했을 거예요. 이때 유저가 기대하는 가치는 간편하고 빠른 주문을 하는 거라고 생각해요. 그래서 주문을 한 번에 해결하지 못하고 지체되게 하는 비중이 큰 순으로 문제를 high, medium, low의 단계로 나누었어요.\n\n제가 찾은 문제 그룹은 총 3가지인데요.\n\n\n먼저 주소가 제대로 설정되지 않으면 유저가 배달을 잘못 받게 되거나 했던 테스크를 다시 요구해야 하는 가장 크리티컬한 문제들을 발생시키기 때문에 배달주소설정 문제의 중요도를 high로 가장 높게 선정했어요.\n\n\n다음으로 일정 금액을 채우지 못하면 주문 완료를 하지 못하게 돼요. 이에 대한 정보가 부족해 유저는 인지하지 못하고 주문서를 진입했을 때야 뒤늦게 알아채고 다시 메뉴를 고민하러 돌아가야 하죠. 때문에 치명적이진 않지만, 주문 시간이 지체되게 하므로 최소주문 금액 문제의 중요도를 medium으로 선정했어요.\n\n\n마지막으로 메뉴의 세부 옵션을 선택할 때 필수사항을 선택하지 않으면 메뉴를 담을 수 없게 하지만, 해당 문제를 해결하지 않는다고 해서 크리티컬한 이슈는 발생하지 않기 때문에 우선순위가 가장 낮은 low로 선정했어요.\n\n이렇게 발견한 문제들을 어떻게 개선하고자 하는지 개선 목표도 세웠어요.\n\n한 번에 주문을 완료할 수 있도록 도와주자\n더 빨리 더 간단한 주문으로 주문 시간을 단축시켜주자\n그래서 해결 방법을 생각할 때도 이 개선 목표들을 기준으로 우선순위가 높은 문제에 집중하여 고민했어요.\n\n그 외 신경 쓴 부분들\n\n제출한 과제 페이지 중 일부\n\n첫 번째로 과제물을 구성할 때 제가 풀이한 방식이 전달이 잘 될 수 있도록 한 페이지에 여러 내용을 다 담지 않으려고 했고, 텍스트와 이미지 영역을 확실히 구분했어요.\n\n두 번째로 주어진 시간을 어떻게 낭비하지 않을 수 있을지 고민을 많이 했는데, 문제를 깊게 파고들어 정의하고 풀이하는 데 하루, 이걸 잘 이해할 수 있도록 과제물 구성하는 데 하루를 투자했어요. 화면을 디자인하는 시간은 에셋 덕에 정말 1시간 정도밖에 안 걸렸던 것 같아요!\n\n챌린지를 하고 느낀 것들\n챌린지를 진행하면서 조금 아쉬웠던 부분도 있었는데요. 챌린지의 기간은 직장인들도 참여할 수 있는 금토일 이었어요. 그런데 실제 제공된 시간은 60시간이었고, 공개는 오전 10시였기 때문에 저를 포함해 대부분의 직장인 분들은 금요일 근무 시간과 겹쳐 적어도 8시간은 사용하지 못했다는 점이 아쉬웠어요.\n\n그렇지만 전반적으로 토스 챌린지를 진행하면서 PD의 문제해결 능력을 집중해서 보려는 의도가 느껴졌는데요. 정말 이 챌린지를 통해서 짧은 시간에 고민이 분산되지 않고 핵심 역량을 집중해서 발휘할 수 있었던 거 같아요.\n\n실제로 제가 챌린지를 하면서 했던 고민을 현직자분들도 하고 계시더라고요. 이게 왜 문제인지, 지금 해결해야 되는 문제인지 등을 정의하며 유저가 겪는 진짜 문제를 찾아 집중하고 있었어요. 특히 토스에선 UT를 가볍게 자주 진행할 수 있는데요! 이걸 적극적으로 활용해서 지금 당장 유저가 겪는 문제를 찾고 개선하고 제품을 발전시켜나가고 있었어요.\n\n마지막으로 챌린지를 통해 문제 해결 역량을 어떻게 보여줄 수 있을지 고민이 될 거 같아요. 저는 가장 중요한 건 명확한 문제 정의라고 생각했어요. 그래야 해결하고자 하는 게 분명해지기 때문에, 진짜 문제를 찾는 데 집중했어요. 그래서 유저에게 전달하고자 하는 ‘가치’가 무엇이고, 이 가치를 기준으로 ‘우선순위’를 세우는 방법을 생각했었죠.\n\n이 외에도 진짜 문제를 찾는 더 좋은 방법이 많을 거 같아요. 챌린지에선 누구나 진짜 문제가 무엇인지에 대해 집중해서 고민할 수 있고, 무엇보다 참여하는 것만으로도 토스를 간접 체험할 수 있으니 저처럼 경험이 부족하신 분들이나 토스의 PD가 어떻게 일하는지 궁금하신 분들은 꼭 한 번 도전해보시면 좋을 것 같아요!","isDisplayingFeedback":true},{"id":21027,"updatedTime":"2023-04-12T17:25:55+09:00","createdTime":"2023-04-12T16:03:39+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"디자이너의, 디자이너에 의한, 디자이너를 위한 채용 설계하기","subtitle":"디자이너가 디자이너 채용을 기획한다면 어떻게 될까요? 프로덕트 디자이너 챌린지는 지원자인 디자이너의 입장에서 기획한 채용이에요. 회사가 어떻게 지원자를 검증할지만 생각한 게 아니라, 어떻게 하면 지원자의 역량을 잘 끌어낼 수 있을지 생각하며 3가지 방법을 선택했어요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/09/2022_pd_og.jpg","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"2022 프로덕트 디자이너 챌린지"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/09/2022_pd_og.jpg","backgroundColor":null,"isFill":false,"imageAlt":"2022 프로덕트 디자이너 챌린지"},"key":"2022-product-designer-challenge","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-09-22T15:55:39+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21027,"title":null,"description":"지난 6월, 토스 디자인 챕터는 프로덕트 디자이너 챌린지를 열었어요. 새로운 채용 형식에 많은 분이 관심을 가져주신 덕분에 좋은 분들을 모실 수 있었는데요. 토스가 왜 디자이너 채용으로 챌린지를 열게 되었는지 이야기해보려고 해요.https://wp.toss.tech/wp-content/...","urlSlug":"2022-product-designer-challenge","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"디자이너의, 디자이너에 의한, 디자이너를 위한 채용 설계하기","description":"디자이너가 디자이너 채용을 기획한다면 어떻게 될까요? 프로덕트 디자이너 챌린지는 지원자인 디자이너의 입장에서 기획한 채용이에요. 회사가 어떻게 지원자를 검증할지만 생각한 게 아니라, 어떻게 하면 지원자의 역량을 잘 끌어낼 수 있을지 생각하며 3가지 방법을 선택했어요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-3-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2334,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":564,"name":"윤지영","slug":"jiyoung-yoon","shortDescription":"Product Designer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/jiyoung-yoon.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":1,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"지난 6월, 토스 디자인 챕터는 프로덕트 디자이너 챌린지를 열었어요. 새로운 채용 형식에 많은 분이 관심을 가져주신 덕분에 좋은 분들을 모실 수 있었는데요. 토스가 왜 디자이너 채용으로 챌린지를 열게 되었는지 이야기해보려고 해요.\n\n\n지원자 입장에서 생각하기\n이전에도 토스 디자인 챕터는 디자이너 채용에 새로운 방식을 시도했어요. 바로 2020년부터 시작한  ‘포트폴리오 없는 디자이너 채용’ 전형이에요. 채용의 첫 단계에서 포트폴리오를 제출할 필요 없이 문제 해결에 대한 5가지 질문과 1장의 첨부 이미지로 지원할 수 있어요.\n\n\n\n디자이너는 이직이나 취업을 준비할 때 포트폴리오가 첫 당락을 결정하는 경우가 대부분이에요. 때문에 포트폴리오 제작에 가장 많은 시간을 쏟죠. 좋은 프로젝트를 만나지 못한 경우에는 역량과는 무관하게 포트폴리오 구성이 힘들어요. 또, 아무리 좋은 프로젝트 경험이 있다고 해도 포트폴리오가 준비되지 않은 상태라면 지원을 미루는 경우도 생기죠. 저희는 지원자분들의 이러한 어려움을 깊이 공감하고 해결하고 싶었어요.\n\n핵심적인 5가지의 질문은 지원자분들의 포트폴리오 제작에 대한 부담과 고민을 줄여주면서 문제 해결 역량을 파악하기에 충분해요. 그리고 프로젝트에 관한 상세 자료는 1차 통과 후에만 직무 인터뷰를 위한 자료로 요청드려요. 지금까지도 이 전형으로 좋은 분들을 계속 모시고 있죠.\n\n하지만 2년을 지속하다 보니 또 다른 문제를 발견했어요. 여전히 지원에 부담을 느끼는 분들의 이야기를 들어보니 토스에 지원하려면 엄청난 프로젝트 경험과 경력이 있어야 할 것 같다고 생각하시는 거예요. 지원자의 물리적 허들은 없앴지만, 심리적인 허들이 존재한다는 것을 깨달았어요.\n\n“프로젝트 성격상 보안 이슈로 포트폴리오 구성이 어려워요”“UI 디자인에 많은 시간을 쏟느라 제품의 근본적인 문제를 해결할 여유가 없어요.”“현재 재직중인 곳이 사용자 관점에서 UX를 설계하기 어려운 조직이에요.”\n그래서 한 단계 더 나아가 잠재력과 역량은 충분하지만, 프로덕트 디자이너의 포트폴리오로 뽐낼만한 경험과 기회가 부족한 분들의 문제를 해결해보기로 했어요. 포트폴리오에 넣을 만한 작업이 부족하다면 우리가 그 작업을 만들어줄 수 있지 않을까? 그 과정에서 나온 것이 바로 과제 전형이에요.\n\n지원자 관점으로 과제 만들기\n하지만 디자인 과제가 있다는 말만 들어도 숨이 턱 막히고 막막하게 느껴지지 않나요? 😱 토스의 디자이너 과제 전형은 기존 업계의 과제 전형과는 다르게 만들어야 했어요. 단순한 지원자 역량 검증이 아니라 지원자의 심리적, 물리적 허들을 낮추는 것이 목적이기 때문이에요.\n\n온전히 지원자분들이 프로덕트 디자이너로서의 역량을 잘 보여줄 수 있도록 0부터 100까지 배려하자는 마음으로 과제를 설계했어요. 문제 해결에만 집중할 수 있도록 고려한 점은 크게 3가지로 꼽을 수 있어요.\n\n1. 과제 수행 주말 포함 60시간\n시간만 보면 너무 짧은 거 아니야? 싶을 수 있는데요. 보통 업계의 과제 전형은 포트폴리오 서류 통과 후에 이루어지기 때문에 시간이 넉넉하게 주어져요. 하지만 토스의 과제 전형은 과제 제출이 우선이라 합격이 불확실한 상황에서 지원자분들의 시간을 많이 뺏고 싶지 않았어요.\n\n그리고 재직자분들이 부담스러워하는 평일보다는 주말에 과제를 수행하실 수 있게 만들었죠. 과제의 양이 중요하지 않다고 안내했는데요. 불필요한 일에 공들이지 않고 중요한 일에만 집중할 수 있도록 시간을 효율적으로 쓰는 것도 과제의 힌트예요.\n\n2. 가상 서비스 문제 해결 과제\n과제는 내가 배달 스타트업에 입사했다는 가정으로 시작해요. 단순히 테스트의 느낌이 아니라 우리의 동료로 일을 함께 시작하는 것처럼요.\n\n그리고 금융의 문제 해결이 아닌 완전히 다른 서비스의 문제를 해결하도록 했어요. 오로지 이 과제 전형을 위해 가상의 서비스를 만들었는데요. 실제로 써볼 수 있는 서비스가 아니기 때문에 지원자분들이 최대한 문제에 공감할 수 있도록 일상적으로 많이 사용하는 배달 앱으로 정했어요. 특정 앱의 문제가 아닌 통상적으로 배달앱에서 경험할 수 있는 익숙하면서 불편한 경험을 편집했죠.\n\n지원자분들이 과제를 보며 막연함을 느끼지 않고 바로 작업에 몰입할 수 있도록 과제 개선 범위를 제한했는데요, 문제 상황을 구체적으로 만들고, 특정 문제가 너무 크게 느껴지지도 너무 작게 느껴지지 않게 시나리오를 짰어요. 그리고 의도적으로 비즈니스 목표와 이해관계 및 개발 제약사항들을 제시하지 않았어요. 기획할 때, 문제는 분명하지만 솔루션은 다양할 수 있을 거로 생각했고, 지원자분들의 성향과 관점에 따라 문제가 다르게 풀이되길 원했거든요.\n\n\n3. 과제 수행을 위한 디자인 에셋 제공\n상황만 실제와 유사한 게 아니라, 실제 직무 환경과 비슷해야 더 합리적으로 솔루션을 낼 수 있겠죠?\n\n토스의 프로덕트 디자이너는 디자인 시스템으로 제품을 만들기 때문에 GUI 디테일에 시간을 쓰지 않고 작업 시간 대부분을 제품의 본질을 고민하고 문제 해결에만 집중할 수 있어요. 그래서 지원자분들도 문제 해결에만 집중할 수 있도록 디자인 에셋을 여러 버전으로 모두 만들어 제공해드렸어요.\n\n과제 수행 시간도 60시간이기 때문에 지원자분들이 시간을 더욱더 효율적으로 쓸 수 있도록 했죠. 심지어 장표 레이아웃을 어려워하시는 분이 있으실 것 같아 혹시나 하는 마음으로 과제 템플릿 예시 또한 만들었어요.\n\n\n과제 평가 기준\n보내주신 소중한 과제물들은 한 명의 취향과 의견으로 평가되지 않게끔, 공정하고 객관적인 평가를 위해 여러 명의 디자이너에게 각각 검토받을 수 있도록 했어요. 그리고 검토 전에 아래와 같이 PASS 기준을 싱크했어요.\n\nUX 오류를 단편적으로 해결하는 것이 아닌 제품 전체 경험을 고려하여 근본적으로 해결했는가?\n문제 정의 → 개선안 → 성과가 논리적으로 연결되며 설득력 있는가?\n문제 해결 과정에서 지원자의 뚜렷한 강점이 있는가?\n여러 단계에 걸쳐 검토하다보니, 최종 과제 합격한 과제는 최대 5명의 디자이너에 의해서 검토되었더라구요. 혹시나 하는 마음으로 합격하지 못한 과제들도 일일이 재검토했어요.\n\n과제 전형 성과\n결과적으로 토스에서 진행했던 채용 이벤트 중에서 단일 직무로는 가장 많은 분이 참여해주셨어요. 지원자의 80%는 이전에는 지원하지 않았던 최초 지원이었죠. 목표대로 지원자의 심리적, 물리적 허들을 낮출 수 있었던 것 같아요. 설문 결과를 보니 감사하게도 채용 전형 의도를 잘 알아봐 주신 분들이 많았어요. 오로지 포트폴리오에 의해 지원하시는 분들의 역량이 좌우되지 않는 것, 과제를 통해 잠재적 역량을 파악하고 싶었던 저희의 의도 그대로요.\n\n“까다롭고 어려운 문제보다 늘 쉽게 접하는 문제를 해결하는 것도 중요하다는 것을 깨달았어요”“오로지 지원자가 생각하는 문제점에 대한 논리적 당위성을 묻는 것이라 혼자 많은 생각을 하게 되는 과제라서 좋았어요””과제는 직무맥락에 매우 적합하다고 생각했습니다. 서비스의 문제를 정의하고 해결하는 일을 하는 게 프로덕트 디자이너의 본분이니까요.”\n많은 지원자분들이 짧은 시간에 밀도 높은 솔루션을 내주셔서 하나하나 보며 놀라움을 금치 못했는데요. 불가피하게 많은 분들께 기회를 드리지 못했지만, 이 채용 여정 자체가 지원자분들에게 도움이 되셨으면 좋겠어요.\n\n그리고 고심 끝에 과제 파일을 공개하려고 해요! 과제의 일부를 편집했기 때문에, 완전히 동일하진 않지만 지원하지 않으셨던 분들도 과제를 간접적으로 경험해보실 수 있어요.\n\n과제 자세히 보기\n\n저희는 감사하게도 이번 토스 프로덕트 디자이너 챌린지를 통해 이전에는 모실 수 없었던 디자이너분들을 모실 수 있었어요. 처음 하는 과제 전형이라 부족한 점이 너무 많았는데요, 주신 의견을 모두 소중히 귀담아 앞으로 더 좋은 방식으로 많은 분을 모실 수 있도록 토스 디자인 챕터는 지원자 입장에서 계속 노력하고 고민할게요.\n\n지원자도 채용 서비스의 사용자이니까요!","isDisplayingFeedback":true},{"id":21021,"updatedTime":"2023-04-12T17:25:55+09:00","createdTime":"2023-04-12T16:03:00+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"좋은 에러 메시지를 만드는 6가지 원칙","subtitle":"좋은 에러 메시지란, 사용자가 다음 단계로 갈 수 있게 돕는 메시지예요. 사용자가 다음 단계로 가기 위해 필요한 내용은 어떤 것들이 있을까요? 토스는 6가지 에러 메시지 원칙을 생각하며 문구를 쓰고 있어요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/09/design-article-2-thumbnail.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"토스에서 에러메시지 쓰는 방법 6가지"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/09/design-article-2-thumbnail.png","backgroundColor":null,"isFill":false,"imageAlt":"토스에서 에러메시지 쓰는 방법 6가지"},"key":"how-to-write-error-message","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-09-21T23:24:51+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21021,"title":null,"description":"에러 메시지, 어떻게 쓰는 게 좋을까요?https://wp.toss.tech/wp-content/uploads/2022/09/Untitled-1024x504.png애플 로그인 에러 메시지이 화면은 제가 가장 최근에 겪은 에러 메시지인데요. 로그인을 하려는데 자꾸 오류가 발생했대요.스스로...","urlSlug":"how-to-write-error-message","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"좋은 에러 메시지를 만드는 6가지 원칙","description":"좋은 에러 메시지란, 사용자가 다음 단계로 갈 수 있게 돕는 메시지예요. 사용자가 다음 단계로 가기 위해 필요한 내용은 어떤 것들이 있을까요? 토스는 6가지 에러 메시지 원칙을 생각하며 문구를 쓰고 있어요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-2-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2333,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":563,"name":"김자유","slug":"jayu-kim","shortDescription":"UX Writer","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/jayu-kim.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":4,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"에러 메시지, 어떻게 쓰는 게 좋을까요?\n\n\n애플 로그인 에러 메시지\n\n이 화면은 제가 가장 최근에 겪은 에러 메시지인데요. 로그인을 하려는데 자꾸 오류가 발생했대요.\n\n비밀번호를 틀렸나?\n계정에 문제가 생겼나?\n인터넷 연결이 안 된 건가?\n스스로 에러의 원인을 유추해가며 해결해야 했어요. 결국 원인을 찾지 못해서 30분 간 씨름하다 포기했죠.\n\n물론 계정을 잘못 입력한 것인지, 비밀번호를 잘못 입력한 것인지를 자세하게 알려주면 해커에게도 정보를 알려줄 수 있다는 위험이 있어 일부러 모호하게 메시지를 쓰는 경우도 있는데요.\n\n그럼에도, 적어도 이게 사용자가 스스로 해결할 수 있는 문제인지 아닌지 정도는 알려주어야 해요. 예를 들면 이렇게요.\n\n비밀번호를 틀렸어요 (X)\n김토스님의 정보가 아니에요 (O)\n그렇지 않으면 사용자는 무엇이 잘못된 것인지, 내가 고칠 수 있는 건지 아닌지도 모른 채 아무런 행동도 취할 수 없는 채로 같은 에러 메시지만 보다가 실망하게 될테니까요.\n\n\n토스에서 발견한 에러들\n\n슬프게도 토스에서도 비슷한 에러를 많이 발견할 수 있었어요. 읽어도 에러를 해결할 수 없는 메시지들이요. 제가 30분 동안 고군분투하며 애플에게 실망한 것처럼, 에러는 한 번의 경험만으로도 제품 전체에 대해 안 좋은 인상을 남길 수 있어요. 그래서, 토스에서 나가는 모든 에러 메시지를 고쳐보기로 했어요.\n\n에러 메시지를 쓸 때 가장 중요한 가치는 Navigating, 즉 ‘사용자가 다음 단계로 무엇을 해야 할지 안내하고 있는가’예요. 좋은 에러 메시지에는 이런 내용들이 포함되어야 하는데요.\n\n지금 사용자가 어떤 상황에 처했는지(상황 설명)\n그것이 왜 발생했는지(이유)\n해결하려면 어떻게 해야하는지(해결책)\n이 내용을 녹여내면서, 사용자가 다음 단계로 잘 갈 수 있게 돕는 에러 메시지 원칙이 6가지 있어요. 하나씩 사례를 들어 소개해드릴게요.\n\n1. 최고의 에러는 발생하지 않는 것\n문구를 쓰기 전, 에러 메시지가 꼭 필요한지를 먼저 생각했어요. 최고의 에러는 ‘발생하지 않는 것’이니까요.\n\n\n이 메시지는 연락처 송금 화면에서 내 연락처를 누르면 만나는 에러인데요. 토스에서 스스로 송금하는 건 계좌로만 가능하기 때문에, 연락처 송금을 쓸 수 없어요. 그렇다면, 사용자가 꼭 이 에러를 봐야 할까요? 처음부터 연락처 목록에 내 연락처가 뜨지 않는다면 보지 않아도 될 메시지니까요. 그래서 이 에러는 메시지를 고치는 게 아니라, 연락처 목록에서 내 연락처를 노출하지 않는 방향으로 작업했어요.\n\n일단 에러 메시지부터 써봤는데, 다시 보니 UX를 개선하면 없어도 되는 메시지일 때가 종종 있을 거예요. 메시지를 고치기 전에 ‘이 에러가 꼭 있어야 할까?’를 한 번 더 생각해보면 좋아요.\n\n2. 적절한 컴포넌트 쓰기\n그 다음엔 적절한 컴포넌트를 사용했는지를 생각했어요. 예를 들어 충분히 설명이 필요한 상황인데 다이얼로그를 쓰지 않고 토스트로 짧게 전달해서 오해를 불러 일으킨다든가, 별로 위급한 상황이 아닌데 빨간색을 써서 실제보다 더 심각한 상황처럼 전달하게 된다든가 하는 문제가 생기지 않도록요.\n\n\n이 메시지는 이미 심사가 시작돼서, 앱 안에서 대출을 취소할 수 없을 때 만나는 에러예요. 토스트는 3~5초 사이에 사라지는 컴포넌트인데, 너무 많은 내용이 담겨있죠. 이때 다이얼로그를 써서 유저가 처한 상황, 그 이유, 해결책을 충분히 설명했어요.\n\n3. 스스로 해결할 수 있는 방법 알려주기\n적절한 그릇(컴포넌트)을 골랐다면, 어떤 내용을 담아야 할지 고민해야겠죠. 에러 상황을 맞닥뜨렸을 때 사용자가 가장 원하는 것은 무엇일까요? 바로 다음 화면으로 넘어가는 것이겠죠. 그러려면 사용자가 스스로 에러를 해결할 수 있도록 해결책을 알려줘야 해요. 에러 메시지의 궁극적인 역할이자, 원칙들 중 가장 중요한 내용이기도 해요.\n\n\n이 메시지는 지문이나 페이스 ID같은 생체 인증에 실패했을 때 만나는 에러인데요. 실패했다는 상황만 알려주고 어떻게 해야 하는지는 알려주지 않았어요. 사용자는 몇 번 반복하다 똑같은 에러를 보고선 지쳐 포기할 거예요. 개발자분께 여쭤보니 앱을 재부팅하거나 재설치하면 해결되는 문제더라고요. 그래서 해결책을 알려주기로 했죠.\n\n4. 사용자 입장에서 이해할 수 있는 언어로 쓰기\n공급자가 아닌 사용자의 입장에서 해결책을 전달하는 것도 중요해요.\n\n\n이 메시지는 기간이 만료된 신분증을 썼을 때 만나는 에러인데요. 공급자 입장에서는 실제로 시스템에서 예외 처리된 신분증이기 때문에 알 수 없는이라는 문구를 썼지만, 사용자 입장에서는 저 문구를 이해하기가 어렵죠. 사용자가 직접 에러를 해결할 수 있도록 사용자 입장에서 이유를 이야기해줘야 해요.\n\n\n개발자만 읽을 수 있는 코드로 된 에러나, IT 업계 용어로 이뤄진 에러도 마찬가지예요. 공급자 입장에서는 맞는 말이라도, 유저가 이해할 수 없는 문구라면 ‘그래서 유저가 이 에러를 해결하려면 어떻게 해야 하지?’를 한 번 더 생각해보면 좋아요.\n\n5. 쉽게 해결할 수 있게 도와주기\n해결책을 알려줬는데 그걸 수행하는 과정이 너무 지난해서 사용자가 포기한다면 큰 의미가 없겠죠. 해결 방법을 알려주는 것도 중요하지만, 그것을 최소한의 비용으로 수행할 수 있게 도와주는 것도 에러 메시지의 역할이에요.\n\n\n이 메시지는 대출 신청 중간에 이탈한 분이 다시 신청하려고 할 때, 신청이 불가능하다는 것을 안내하는 에러예요. 하루에 한 번만 신청할 수 있지만, 그 날 꼭 신청해야 하는 분들은 고객센터에 따로 문의하면 처리해드릴 수 있는 상황이었어요.\n\n‘고객센터로 문의해달라’고 문구를 남겨뒀지만, 사용자는 앱을 떠나 전화번호를 누르거나, 토스 앱 안에서 고객센터가 어디있는지 직접 찾아야했죠. 그런 사용자의 수고를 덜기 위해, 탭 한 번으로 문의할 수 있도록 버튼을 추가했어요.\n\n6. 부정적인 감정 최소화하기\n위의 것들을 다 지키면 우리는 최선을 다한 게 맞지만, 그럼에도 사용자는 원래 기대했던 화면을 보지 못한 것이 맞잖아요. 크든 작든 좌절할 수밖에 없는 상황이니, 최대한 그 감정을 배려하여 커뮤니케이션해야 해요.\n\n\n에러 메시지가 주로 ‘안 돼요’, ‘없어요’ 같은 문장이 많잖아요. 부정형 문장을 최대한 긍정형으로 전달하기 위해, 안되는 사실을 전달하는 것보다 할 수 있는 것들을 이야기하는 방식을 선택했어요. 사용자의 선택권을 존중하기 위해 ~해야 해요라고 강요하는 듯한 말투보다, ~할 수 있어요라고 권유하는 말투를 쓰기도 하고요.\n\n에러 메시지를 써야 한다면,이 원칙들을 체크리스트처럼 차례로 확인하면서 작성해보세요!\n\n최고의 에러는 발생하지 않는 것\n적절한 컴포넌트 쓰기\n스스로 해결할 수 있는 방법 알려주기\n사용자 입장에서 이해할 수 있는 언어로 쓰기\n쉽게 해결할 수 있게 도와주기\n부정적인 감정 최소화하기","isDisplayingFeedback":true},{"id":21016,"updatedTime":"2023-04-12T17:25:55+09:00","createdTime":"2023-04-12T16:02:29+09:00","category":null,"categories":[{"name":"디자인","id":353,"slug":"design","parentId":null,"iconUrl":null}],"series":null,"title":"거꾸로 입력하는 가입 화면, 처음에 어떻게 떠올렸을까?","subtitle":"토스의 회원 가입 화면에선 스크롤을 내릴 필요가 없어요. 필요한 정보들을 거꾸로 입력하기 때문이죠. 어색하지 않을까 걱정했지만, 이제는 업계의 표준이 되었죠. 많은 앱에서 이 형태를 적용하고 있어요. 처음 이 화면을 디자인하게 된 과정을 소개해드릴게요.","bottomButtonConfig":{"ctaType":"NONE","imageUrl":null,"imageAlt":null,"title":null,"description":null,"ctaName":null,"landingUrl":null,"isSearchBottomCta":false,"serviceId":null,"stockConfig":null,"landingScheme":null,"landingExternal":null},"coverConfig":{"coverType":"IMAGE","imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/09/design-article-1-thumnail2.png","videoUrl":null,"backgroundColor":null,"isFill":false,"imageAlt":"토스 회원가입 과정"},"thumbnailConfig":{"imageUrl":"https://wp.toss.tech/wp-content/uploads/2022/09/design-article-1-thumnail2.png","backgroundColor":null,"isFill":false,"imageAlt":"토스 회원가입 과정"},"key":"toss-signup-process","minAge":0,"isDisplaying":true,"isDisplayingPublishedTime":true,"workspaceId":15,"isPublished":true,"publishedTime":"2022-09-20T13:55:25+09:00","likeCount":0,"commentBoard":null,"relatedPostTitle":null,"relatedPosts":[],"disclaimer":null,"seoConfig":{"post":21016,"title":null,"description":"토스의 회원 가입 화면에선 스크롤을 내릴 필요가 없어요. 필요한 정보들을 거꾸로 입력하기 때문이죠. 어색하지 않을까 걱정했지만, 이제는 업계의 표준이 되었죠. 많은 앱에서 이 형태를 적용하고 있어요. 처음 이 화면을 디자인하게 된 과정을 소개해드릴게요.","urlSlug":"toss-signup-process","primaryKeyword":null,"relatedKeywords":[],"tags":[]},"openGraph":{"title":"거꾸로 입력하는 가입 화면, 처음에 어떻게 떠올렸을까?","description":"토스의 회원 가입 화면에선 스크롤을 내릴 필요가 없어요. 필요한 정보들을 거꾸로 입력하기 때문이죠. 어색하지 않을까 걱정했지만, 이제는 업계의 표준이 되었죠. 많은 앱에서 이 형태를 적용하고 있어요. 처음 이 화면을 디자인하게 된 과정을 소개해드릴게요.","backgroundColor":"#424242","imageAlt":null,"imageUrl":"https://static.toss.im/assets/homepage/tosstech/og/design-article-1-og.png?v=2","imageType":"직접입력"},"relatedPostConfig":{"id":2336,"relatedPosts":[],"title":"다른 글 둘러보기"},"editor":{"id":566,"name":"정희연","slug":"heeyeun-jung","shortDescription":"Head of UX","description":null,"imageUrl":"https://static.toss.im/assets/toss-tech/heeyeun-jung.png","url":null,"facebook":null,"twitter":null,"instagram":null,"postCount":2,"ogConfig":null,"seoConfig":null,"priority":1000,"isDisplaying":false,"isHomeRecommendation":false},"disclaimerConfig":null,"shortDescription":"때는 바야흐로 2018년 저는 당시에 토스 가입과정을 디자인 하게 되었어요. 토스의 가입 과정은 처음 만들어지고 나서 한동안 개선하지 않은 상태였거든요.\n\n많은 디자이너들이 경험하듯, 가입 과정을 하나하나 뜯어보니 디자인 시안과 실제로 구현된 화면이 약간 다르다는 사실을 발견했어요.\n\n그 화면은 이름과 주민등록번호까지 입력하면 유효성 검사를 하고 휴대폰 번호 필드가 나타나는 구조였어요.\n\n디자인 시안은 이런 모습이었고\n\n\n실제로 구현된 내용은 이랬답니다.\n\n\n차이가 느껴지시나요?\n\n가장 중요한건 키보드 위에 있던 CTA 버튼이 텍스트 필드에 밀려 화면 하단으로 내려간 부분이었어요. 그래서 사용자는 하단에 버튼을 눌러야 다음으로 갈 수 있는지 인지하기가 어려웠죠. 심지어 디바이스의 크기에 따라 통신사 선택 필드가 완전히 가려져 있어서, 스크롤을 내려 통신사를 입력해야하는지 알기도 어려웠어요. 미세하게는 휴대폰번호 입력란에 숫자 키보드가 아닌 국문 키보드가 나온 것도 문제였네요.\n\n나아가 주민번호까지 입력했더니 갑자기 로딩이 돌고, 휴대폰 번호 필드가 나타나서 당황스러운 것도 문제라고 생각했어요. 게다가 이 화면을 개선하던 시점에 기술적 이유로 휴대폰과 통신사를 유효성 검사 없이 모두 받기로 결정했고요.\n\n정리하면 제가 해결해야할 문제는 다음과 같았어요.\n\n로딩이 돌더니 없던 휴대폰 번호, 통신사 필드가 갑자기 생겨나서 당황스럽다.\nCTA 버튼이 갑자기 사라졌다.\n통신사 필드가 있는지 안보인다.\n키보드 높이에 따라 필드가 가려져서 새로운 필드가 생겼는지 눈치채기 어렵다.\n기술적 문제가 생겨서 앞으로는 휴대폰 번호와 통신사를 무조건 받아야 된다.\n가장 쉬운 해결책은 모든 텍스트 필드를 모두 노출하는 것이었어요.\n\n\n하지만 이렇게 하면 아래에 텍스트필드가 있는지 알기 어려운 문제는 동일하죠.\n\n게다가 토스에는 1 thing for 1 page 라는 제품 원칙이 있는데요. 하나의 화면에서 하나의 액션만 시키라는 내용이예요. (1 thing for 1 page에 대한 자세한 내용은 다음에 소개드릴게요~)\n\n그래서 이렇게 네 페이지로 쪼개는 것도 생각해보았어요.\n\n\n그런데 왠지 화면이 길어지고, 이 네가지를 입력하자고 다음을 네번 누르는 게 귀찮게 느껴졌어요.\n\n그렇다면.. 질문을 두개씩 구성할까?\n\n\n이것도 가능한 솔루션이었지만 왠지 성에 차지 않았어요.\n\n그래서 고민하다 만들게된 솔루션은 인터렉션을 도입하는 거였어요.\n\n이 화면이 어떻게 구현된 것인지 느낌이 오시나요?\n\n가장 쉬운 질문인 이름을 입력하고 다음 버튼을 누르면, 입력 필드 포맷에 따라 필드를 자동으로 추가해주는 방식이예요. 주민번호, 통신사, 핸드폰번호 모두 일정한 데이터 형식이었기에 이런 솔루션이 가능했어요. 게다가 텍스트필드가 밑으로 쌓이면 스크롤을 해야하니, 역순으로 쌓이게 만들었고요.\n\n하지만 텍스트필드가 역순으로 쌓인다니 너무 어색하지 않을까요? 이런 우려때문에 많은 사용성 테스트를 해보았는데, 놀랍게도 텍스트필드가 역순으로 쌓인다는 사실을 말해주기 전까지는 아무도 눈치채지 못하셨어요.\n\n혹시 “보이지 않는 고릴라 실험(the invisible gorilla experiment)”을 들어보셨을까요?\n\n흰색 티셔츠를 입은 3명과 검은색 티셔츠를 입은 3명이 모여 돌아가며 농구공을 패스해요. 여기서 실험 참가자는 흰색 티셔츠를 입은 세 명의 패스 횟수를 세어야 해요. 그러다 어느 순간 고릴라 옷을 입은 사람이 등장해 화면의 가운데에서 가슴을 두드리고 사라지죠. 놀라운 점은 이 실험에 참가한 사람의 50%가 고릴라의 존재를 눈치채지 못했다는 사실이예요. 이는 바로 사람들이 집중한 사물 이외엔 바로 옆의 사물이라도 인지하지 못하는 현상에 기인해요.\n\n텍스트필드가 역순으로 쌓이는 걸 인지하지 못한 이유도 같죠. 사람들은 내가 집중하는 “상단의 영역”, “파란색 커서가 있는 텍스트필드”에 집중했기에 텍스트필드가 쌓이는 방향에는 크게 개의치 않았던 거죠.\n\n이 시안을 만들어내는데 약 2주가 걸렸는데요, 아마 동료분들은 4개의 텍스트필드를 1페이지에 넣을지, 4페이지로 쪼갤지, 2페이지로 쪼갤지 결정하는데 2주나 걸린다는 게 의아하셨을지도 모르겠어요. 하지만 이 화면은 지금까지도 토스의 가입과정 경험으로 자리 잡고 있다는 점에서 임팩트있는 2주가 아니었나 생각해요 🥳\n\n이 개선안으로 사람의 인지 능력을 어디까지 마이크로하게 쪼개서 제품 UX에 접목해야 하는지, 낯설지 않은 새로움이란 어떤 경험인지를 탐구할 수 있어서 저에게도 좋은 배움이 되었어요. 이 사례는 토스의 제품 원칙 중 하나인 Sleek experience 의 대표 사례로도 추가될 수 있었고요.\n\n지금 여러분들이 해결하지 못한 어려운 UX 문제가 있나요? 기존에 당연하다고 생각했던 틀을 깨서 해결할 순 없을지 함께 생각해보면 답이 나올지도 몰라요!","isDisplayingFeedback":true}]}